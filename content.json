[{"title":"Creating a Sentiment Analysis Web App","date":"2020-02-23T15:25:00.000Z","path":"2020/02/23/SageMakerProject/","text":"Creating a Sentiment Analysis Web App by using PyTorch and SageMaker Creating a Sentiment Analysis Web AppUsing PyTorch and SageMakerDeep Learning Nanodegree Program | Deployments Now that we have a basic understanding of how SageMaker works we will try to use it to construct a complete project from end to end. Our goal will be to have a simple web page which a user can use to enter a movie review. The web page will then send the review off to our deployed model which will predict the sentiment of the entered review. InstructionsSome template code has already been provided for you, and you will need to implement additional functionality to successfully complete this notebook. You will not need to modify the included code beyond what is requested. Sections that begin with ‘TODO‘ in the header indicate that you need to complete or implement some portion within them. Instructions will be provided for each section and the specifics of the implementation are marked in the code block with a # TODO: ... comment. Please be sure to read the instructions carefully! In addition to implementing code, there will be questions for you to answer which relate to the task and your implementation. Each section where you will answer a question is preceded by a ‘Question:‘ header. Carefully read each question and provide your answer below the ‘Answer:‘ header by editing the Markdown cell. Note: Code and Markdown cells can be executed using the Shift+Enter keyboard shortcut. In addition, a cell can be edited by typically clicking it (double-click for Markdown cells) or by pressing Enter while it is highlighted. General OutlineRecall the general outline for SageMaker projects using a notebook instance. Download or otherwise retrieve the data. Process / Prepare the data. Upload the processed data to S3. Train a chosen model. Test the trained model (typically using a batch transform job). Deploy the trained model. Use the deployed model. For this project, you will be following the steps in the general outline with some modifications. First, you will not be testing the model in its own step. You will still be testing the model, however, you will do it by deploying your model and then using the deployed model by sending the test data to it. One of the reasons for doing this is so that you can make sure that your deployed model is working correctly before moving forward. In addition, you will deploy and use your trained model a second time. In the second iteration you will customize the way that your trained model is deployed by including some of your own code. In addition, your newly deployed model will be used in the sentiment analysis web app. Step 1: Downloading the dataAs in the XGBoost in SageMaker notebook, we will be using the IMDb dataset Maas, Andrew L., et al. Learning Word Vectors for Sentiment Analysis. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies. Association for Computational Linguistics, 2011. 123%mkdir ../data!wget -O ../data/aclImdb_v1.tar.gz http://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz!tar -zxf ../data/aclImdb_v1.tar.gz -C ../data mkdir: cannot create directory ‘../data’: File exists --2020-02-23 10:05:42-- http://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz Resolving ai.stanford.edu (ai.stanford.edu)... 171.64.68.10 Connecting to ai.stanford.edu (ai.stanford.edu)|171.64.68.10|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 84125825 (80M) [application/x-gzip] Saving to: ‘../data/aclImdb_v1.tar.gz’ ../data/aclImdb_v1. 100%[===================&gt;] 80.23M 21.9MB/s in 4.5s 2020-02-23 10:05:47 (17.7 MB/s) - ‘../data/aclImdb_v1.tar.gz’ saved [84125825/84125825]Step 2: Preparing and Processing the dataAlso, as in the XGBoost notebook, we will be doing some initial data processing. The first few steps are the same as in the XGBoost example. To begin with, we will read in each of the reviews and combine them into a single input structure. Then, we will split the dataset into a training set and a testing set. 12345678910111213141516171819202122232425262728import osimport globdef read_imdb_data(data_dir='../data/aclImdb'): data = &#123;&#125; labels = &#123;&#125; for data_type in ['train', 'test']: data[data_type] = &#123;&#125; labels[data_type] = &#123;&#125; for sentiment in ['pos', 'neg']: data[data_type][sentiment] = [] labels[data_type][sentiment] = [] path = os.path.join(data_dir, data_type, sentiment, '*.txt') files = glob.glob(path) for f in files: with open(f) as review: data[data_type][sentiment].append(review.read()) # Here we represent a positive review by '1' and a negative review by '0' labels[data_type][sentiment].append(1 if sentiment == 'pos' else 0) assert len(data[data_type][sentiment]) == len(labels[data_type][sentiment]), \\ \"&#123;&#125;/&#123;&#125; data size does not match labels size\".format(data_type, sentiment) return data, labels 1234data, labels = read_imdb_data()print(\"IMDB reviews: train = &#123;&#125; pos / &#123;&#125; neg, test = &#123;&#125; pos / &#123;&#125; neg\".format( len(data['train']['pos']), len(data['train']['neg']), len(data['test']['pos']), len(data['test']['neg']))) IMDB reviews: train = 12500 pos / 12500 neg, test = 12500 pos / 12500 negNow that we’ve read the raw training and testing data from the downloaded dataset, we will combine the positive and negative reviews and shuffle the resulting records. 1234567891011121314151617from sklearn.utils import shuffledef prepare_imdb_data(data, labels): \"\"\"Prepare training and test sets from IMDb movie reviews.\"\"\" #Combine positive and negative reviews and labels data_train = data['train']['pos'] + data['train']['neg'] data_test = data['test']['pos'] + data['test']['neg'] labels_train = labels['train']['pos'] + labels['train']['neg'] labels_test = labels['test']['pos'] + labels['test']['neg'] #Shuffle reviews and corresponding labels within training and test sets data_train, labels_train = shuffle(data_train, labels_train) data_test, labels_test = shuffle(data_test, labels_test) # Return a unified training data, test data, training labels, test labets return data_train, data_test, labels_train, labels_test 12train_X, test_X, train_y, test_y = prepare_imdb_data(data, labels)print(\"IMDb reviews (combined): train = &#123;&#125;, test = &#123;&#125;\".format(len(train_X), len(test_X))) IMDb reviews (combined): train = 25000, test = 25000Now that we have our training and testing sets unified and prepared, we should do a quick check and see an example of the data our model will be trained on. This is generally a good idea as it allows you to see how each of the further processing steps affects the reviews and it also ensures that the data has been loaded correctly. 12print(train_X[100])print(train_y[100]) Every new fall line-up show deserves, at least, my &quot;3 strikes and you&apos;re out&quot; policy. I give a comedy 3 chances to make me laugh, that is, 3 complete episodes. After Episode 1, I actually said to the TV,&quot;Cancelled tomorrow&quot;. It was that bad. I have now watched the first 4 episodes of &quot;Cavemen&quot; and have yet to manage even a smirk. Not a titter, a guffaw, a chortle, as a matter of fact, no facial movement at all. I will continue to punish myself by watching every future episode because I am convinced that I am clearly missing something in this show. I&apos;m simply not &quot;getting&quot; it, but I believe that a comedy on a major TV network in prime-time, just HAS to be funny; but there are no laughs from me YET. There&apos;s just no way that ABC would put on the least funniest comedy of all time at 8:00 p.m. I KNOW there has got to be an inside joke that just isn&apos;t jiving with my brain. I&apos;ve read each of the previous comments, I &quot;get&quot; the social aspect of it, but, WHERE ARE THE JOKES ???? I shall continue suffering for at least 30 minutes a week, until I have a light-bulb moment and smack myself in the head shouting &quot;Eureka&quot;. 0The first step in processing the reviews is to make sure that any html tags that appear should be removed. In addition we wish to tokenize our input, that way words such as entertained and entertaining are considered the same with regard to sentiment analysis. 123456789101112131415161718import nltkfrom nltk.corpus import stopwordsfrom nltk.stem.porter import *import refrom bs4 import BeautifulSoupdef review_to_words(review): nltk.download(\"stopwords\", quiet=True) stemmer = PorterStemmer() text = BeautifulSoup(review, \"html.parser\").get_text() # Remove HTML tags text = re.sub(r\"[^a-zA-Z0-9]\", \" \", text.lower()) # Convert to lower case words = text.split() # Split string into words words = [w for w in words if w not in stopwords.words(\"english\")] # Remove stopwords words = [PorterStemmer().stem(w) for w in words] # stem return words The review_to_words method defined above uses BeautifulSoup to remove any html tags that appear and uses the nltk package to tokenize the reviews. As a check to ensure we know how everything is working, try applying review_to_words to one of the reviews in the training set. 12# TODO: Apply review_to_words to a review (train_X[100] or any other review)print(review_to_words(train_X[100])) [&apos;everi&apos;, &apos;new&apos;, &apos;fall&apos;, &apos;line&apos;, &apos;show&apos;, &apos;deserv&apos;, &apos;least&apos;, &apos;3&apos;, &apos;strike&apos;, &apos;polici&apos;, &apos;give&apos;, &apos;comedi&apos;, &apos;3&apos;, &apos;chanc&apos;, &apos;make&apos;, &apos;laugh&apos;, &apos;3&apos;, &apos;complet&apos;, &apos;episod&apos;, &apos;episod&apos;, &apos;1&apos;, &apos;actual&apos;, &apos;said&apos;, &apos;tv&apos;, &apos;cancel&apos;, &apos;tomorrow&apos;, &apos;bad&apos;, &apos;watch&apos;, &apos;first&apos;, &apos;4&apos;, &apos;episod&apos;, &apos;cavemen&apos;, &apos;yet&apos;, &apos;manag&apos;, &apos;even&apos;, &apos;smirk&apos;, &apos;titter&apos;, &apos;guffaw&apos;, &apos;chortl&apos;, &apos;matter&apos;, &apos;fact&apos;, &apos;facial&apos;, &apos;movement&apos;, &apos;continu&apos;, &apos;punish&apos;, &apos;watch&apos;, &apos;everi&apos;, &apos;futur&apos;, &apos;episod&apos;, &apos;convinc&apos;, &apos;clearli&apos;, &apos;miss&apos;, &apos;someth&apos;, &apos;show&apos;, &apos;simpli&apos;, &apos;get&apos;, &apos;believ&apos;, &apos;comedi&apos;, &apos;major&apos;, &apos;tv&apos;, &apos;network&apos;, &apos;prime&apos;, &apos;time&apos;, &apos;funni&apos;, &apos;laugh&apos;, &apos;yet&apos;, &apos;way&apos;, &apos;abc&apos;, &apos;would&apos;, &apos;put&apos;, &apos;least&apos;, &apos;funniest&apos;, &apos;comedi&apos;, &apos;time&apos;, &apos;8&apos;, &apos;00&apos;, &apos;p&apos;, &apos;know&apos;, &apos;got&apos;, &apos;insid&apos;, &apos;joke&apos;, &apos;jive&apos;, &apos;brain&apos;, &apos;read&apos;, &apos;previou&apos;, &apos;comment&apos;, &apos;get&apos;, &apos;social&apos;, &apos;aspect&apos;, &apos;joke&apos;, &apos;shall&apos;, &apos;continu&apos;, &apos;suffer&apos;, &apos;least&apos;, &apos;30&apos;, &apos;minut&apos;, &apos;week&apos;, &apos;light&apos;, &apos;bulb&apos;, &apos;moment&apos;, &apos;smack&apos;, &apos;head&apos;, &apos;shout&apos;, &apos;eureka&apos;]Question: Above we mentioned that review_to_words method removes html formatting and allows us to tokenize the words found in a review, for example, converting entertained and entertaining into entertain so that they are treated as though they are the same word. What else, if anything, does this method do to the input? Answer: This method convert all upper case to lower case and all punctuations are removed. The method below applies the review_to_words method to each of the reviews in the training and testing datasets. In addition it caches the results. This is because performing this processing step can take a long time. This way if you are unable to complete the notebook in the current session, you can come back without needing to process the data a second time. 12345678910111213141516171819202122232425262728293031323334353637383940import picklecache_dir = os.path.join(\"../cache\", \"sentiment_analysis\") # where to store cache filesos.makedirs(cache_dir, exist_ok=True) # ensure cache directory existsdef preprocess_data(data_train, data_test, labels_train, labels_test, cache_dir=cache_dir, cache_file=\"preprocessed_data.pkl\"): \"\"\"Convert each review to words; read from cache if available.\"\"\" # If cache_file is not None, try to read from it first cache_data = None if cache_file is not None: try: with open(os.path.join(cache_dir, cache_file), \"rb\") as f: cache_data = pickle.load(f) print(\"Read preprocessed data from cache file:\", cache_file) except: pass # unable to read from cache, but that's okay # If cache is missing, then do the heavy lifting if cache_data is None: # Preprocess training and test data to obtain words for each review #words_train = list(map(review_to_words, data_train)) #words_test = list(map(review_to_words, data_test)) words_train = [review_to_words(review) for review in data_train] words_test = [review_to_words(review) for review in data_test] # Write to cache file for future runs if cache_file is not None: cache_data = dict(words_train=words_train, words_test=words_test, labels_train=labels_train, labels_test=labels_test) with open(os.path.join(cache_dir, cache_file), \"wb\") as f: pickle.dump(cache_data, f) print(\"Wrote preprocessed data to cache file:\", cache_file) else: # Unpack data loaded from cache file words_train, words_test, labels_train, labels_test = (cache_data['words_train'], cache_data['words_test'], cache_data['labels_train'], cache_data['labels_test']) return words_train, words_test, labels_train, labels_test 12# Preprocess datatrain_X, test_X, train_y, test_y = preprocess_data(train_X, test_X, train_y, test_y) Read preprocessed data from cache file: preprocessed_data.pklTransform the dataIn the XGBoost notebook we transformed the data from its word representation to a bag-of-words feature representation. For the model we are going to construct in this notebook we will construct a feature representation which is very similar. To start, we will represent each word as an integer. Of course, some of the words that appear in the reviews occur very infrequently and so likely don’t contain much information for the purposes of sentiment analysis. The way we will deal with this problem is that we will fix the size of our working vocabulary and we will only include the words that appear most frequently. We will then combine all of the infrequent words into a single category and, in our case, we will label it as 1. Since we will be using a recurrent neural network, it will be convenient if the length of each review is the same. To do this, we will fix a size for our reviews and then pad short reviews with the category ‘no word’ (which we will label 0) and truncate long reviews. (TODO) Create a word dictionaryTo begin with, we need to construct a way to map words that appear in the reviews to integers. Here we fix the size of our vocabulary (including the ‘no word’ and ‘infrequent’ categories) to be 5000 but you may wish to change this to see how it affects the model. TODO: Complete the implementation for the build_dict() method below. Note that even though the vocab_size is set to 5000, we only want to construct a mapping for the most frequently appearing 4998 words. This is because we want to reserve the special labels 0 for ‘no word’ and 1 for ‘infrequent word’. 1234567891011121314151617181920212223242526import numpy as npdef build_dict(data, vocab_size = 5000): \"\"\"Construct and return a dictionary mapping each of the most frequently appearing words to a unique integer.\"\"\" # TODO: Determine how often each word appears in `data`. Note that `data` is a list of sentences and that a # sentence is a list of words. word_count = &#123;&#125; # A dict storing the words that appear in the reviews along with how often they occur for sentence in data: for word in sentence: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 # TODO: Sort the words found in `data` so that sorted_words[0] is the most frequently appearing word and # sorted_words[-1] is the least frequently appearing word. sorted_words = sorted(word_count, key=word_count.get, reverse=True) word_dict = &#123;&#125; # This is what we are building, a dictionary that translates words into integers for idx, word in enumerate(sorted_words[:vocab_size - 2]): # The -2 is so that we save room for the 'no word' word_dict[word] = idx + 2 # 'infrequent' labels return word_dict 1word_dict = build_dict(train_X) Question: What are the five most frequently appearing (tokenized) words in the training set? Does it makes sense that these words appear frequently in the training set? Answer: 1print([i for i in word_dict.keys()][:5]) [&apos;movi&apos;, &apos;film&apos;, &apos;one&apos;, &apos;like&apos;, &apos;time&apos;]This makes sense since those words are common in movie reviews Save word_dictLater on when we construct an endpoint which processes a submitted review we will need to make use of the word_dict which we have created. As such, we will save it to a file now for future use. 123data_dir = '../data/pytorch' # The folder we will use for storing dataif not os.path.exists(data_dir): # Make sure that the folder exists os.makedirs(data_dir) 12with open(os.path.join(data_dir, 'word_dict.pkl'), \"wb\") as f: pickle.dump(word_dict, f) Transform the reviewsNow that we have our word dictionary which allows us to transform the words appearing in the reviews into integers, it is time to make use of it and convert our reviews to their integer sequence representation, making sure to pad or truncate to a fixed length, which in our case is 500. 123456789101112131415161718192021222324def convert_and_pad(word_dict, sentence, pad=500): NOWORD = 0 # We will use 0 to represent the 'no word' category INFREQ = 1 # and we use 1 to represent the infrequent words, i.e., words not appearing in word_dict working_sentence = [NOWORD] * pad for word_index, word in enumerate(sentence[:pad]): if word in word_dict: working_sentence[word_index] = word_dict[word] else: working_sentence[word_index] = INFREQ return working_sentence, min(len(sentence), pad)def convert_and_pad_data(word_dict, data, pad=500): result = [] lengths = [] for sentence in data: converted, leng = convert_and_pad(word_dict, sentence, pad) result.append(converted) lengths.append(leng) return np.array(result), np.array(lengths) 12train_X, train_X_len = convert_and_pad_data(word_dict, train_X)test_X, test_X_len = convert_and_pad_data(word_dict, test_X) As a quick check to make sure that things are working as intended, check to see what one of the reviews in the training set looks like after having been processeed. Does this look reasonable? What is the length of a review in the training set? 123# Use this cell to examine one of the processed reviews to make sure everything is working as intended.print('The processed review is:\\n&#123;&#125;.'.format(train_X[7]))print('The length of the review is:\\n&#123;&#125;.'.format(train_X_len[7])) The processed review is: [ 135 3 28 31 272 1280 1 1 669 1663 1 3417 3 94 96 813 147 3 23 8 59 30 1477 1 4 1 43 110 709 3 33 2437 230 4095 358 1 50 575 1 55 75 3439 1 1770 43 260 43 68 1 331 94 1549 419 42 601 283 1477 50 255 1310 1 55 420 50 40 33 75 29 50 22 147 580 74 59 30 4 395 2 119 324 1053 232 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]. The length of the review is: 82.It looks reasonable, and the length of the review is 82. Question: In the cells above we use the preprocess_data and convert_and_pad_data methods to process both the training and testing set. Why or why not might this be a problem? Answer: It might not be a problem for training the model since all reviews are converted into the same length. However, it might require more memory since shorter reviews are converted into longer format. Step 3: Upload the data to S3As in the XGBoost notebook, we will need to upload the training dataset to S3 in order for our training code to access it. For now we will save it locally and we will upload to S3 later on. Save the processed training dataset locallyIt is important to note the format of the data that we are saving as we will need to know it when we write the training code. In our case, each row of the dataset has the form label, length, review[500] where review[500] is a sequence of 500 integers representing the words in the review. 1234import pandas as pd pd.concat([pd.DataFrame(train_y), pd.DataFrame(train_X_len), pd.DataFrame(train_X)], axis=1) \\ .to_csv(os.path.join(data_dir, 'train.csv'), header=False, index=False) Uploading the training dataNext, we need to upload the training data to the SageMaker default S3 bucket so that we can provide access to it while training our model. 12345678import sagemakersagemaker_session = sagemaker.Session()bucket = sagemaker_session.default_bucket()prefix = 'sagemaker/sentiment_rnn'role = sagemaker.get_execution_role() 1input_data = sagemaker_session.upload_data(path=data_dir, bucket=bucket, key_prefix=prefix) NOTE: The cell above uploads the entire contents of our data directory. This includes the word_dict.pkl file. This is fortunate as we will need this later on when we create an endpoint that accepts an arbitrary review. For now, we will just take note of the fact that it resides in the data directory (and so also in the S3 training bucket) and that we will need to make sure it gets saved in the model directory. Step 4: Build and Train the PyTorch ModelIn the XGBoost notebook we discussed what a model is in the SageMaker framework. In particular, a model comprises three objects Model Artifacts, Training Code, and Inference Code, each of which interact with one another. In the XGBoost example we used training and inference code that was provided by Amazon. Here we will still be using containers provided by Amazon with the added benefit of being able to include our own custom code. We will start by implementing our own neural network in PyTorch along with a training script. For the purposes of this project we have provided the necessary model object in the model.py file, inside of the train folder. You can see the provided implementation by running the cell below. 1!pygmentize train/model.py \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mtorch.nn\u001b[39;49;00m \u001b[34mas\u001b[39;49;00m \u001b[04m\u001b[36mnn\u001b[39;49;00m \u001b[34mclass\u001b[39;49;00m \u001b[04m\u001b[32mLSTMClassifier\u001b[39;49;00m(nn.Module): \u001b[33m&quot;&quot;&quot;\u001b[39;49;00m \u001b[33m This is the simple RNN model we will be using to perform Sentiment Analysis.\u001b[39;49;00m \u001b[33m &quot;&quot;&quot;\u001b[39;49;00m \u001b[34mdef\u001b[39;49;00m \u001b[32m__init__\u001b[39;49;00m(\u001b[36mself\u001b[39;49;00m, embedding_dim, hidden_dim, vocab_size): \u001b[33m&quot;&quot;&quot;\u001b[39;49;00m \u001b[33m Initialize the model by settingg up the various layers.\u001b[39;49;00m \u001b[33m &quot;&quot;&quot;\u001b[39;49;00m \u001b[36msuper\u001b[39;49;00m(LSTMClassifier, \u001b[36mself\u001b[39;49;00m).\u001b[32m__init__\u001b[39;49;00m() \u001b[36mself\u001b[39;49;00m.embedding = nn.Embedding(vocab_size, embedding_dim, padding_idx=\u001b[34m0\u001b[39;49;00m) \u001b[36mself\u001b[39;49;00m.lstm = nn.LSTM(embedding_dim, hidden_dim) \u001b[36mself\u001b[39;49;00m.dense = nn.Linear(in_features=hidden_dim, out_features=\u001b[34m1\u001b[39;49;00m) \u001b[36mself\u001b[39;49;00m.sig = nn.Sigmoid() \u001b[36mself\u001b[39;49;00m.word_dict = \u001b[36mNone\u001b[39;49;00m \u001b[34mdef\u001b[39;49;00m \u001b[32mforward\u001b[39;49;00m(\u001b[36mself\u001b[39;49;00m, x): \u001b[33m&quot;&quot;&quot;\u001b[39;49;00m \u001b[33m Perform a forward pass of our model on some input.\u001b[39;49;00m \u001b[33m &quot;&quot;&quot;\u001b[39;49;00m x = x.t() lengths = x[\u001b[34m0\u001b[39;49;00m,:] reviews = x[\u001b[34m1\u001b[39;49;00m:,:] embeds = \u001b[36mself\u001b[39;49;00m.embedding(reviews) lstm_out, _ = \u001b[36mself\u001b[39;49;00m.lstm(embeds) out = \u001b[36mself\u001b[39;49;00m.dense(lstm_out) out = out[lengths - \u001b[34m1\u001b[39;49;00m, \u001b[36mrange\u001b[39;49;00m(\u001b[36mlen\u001b[39;49;00m(lengths))] \u001b[34mreturn\u001b[39;49;00m \u001b[36mself\u001b[39;49;00m.sig(out.squeeze())The important takeaway from the implementation provided is that there are three parameters that we may wish to tweak to improve the performance of our model. These are the embedding dimension, the hidden dimension and the size of the vocabulary. We will likely want to make these parameters configurable in the training script so that if we wish to modify them we do not need to modify the script itself. We will see how to do this later on. To start we will write some of the training code in the notebook so that we can more easily diagnose any issues that arise. First we will load a small portion of the training data set to use as a sample. It would be very time consuming to try and train the model completely in the notebook as we do not have access to a gpu and the compute instance that we are using is not particularly powerful. However, we can work on a small bit of the data to get a feel for how our training script is behaving. 1234567891011121314import torchimport torch.utils.data# Read in only the first 250 rowstrain_sample = pd.read_csv(os.path.join(data_dir, 'train.csv'), header=None, names=None, nrows=250)# Turn the input pandas dataframe into tensorstrain_sample_y = torch.from_numpy(train_sample[[0]].values).float().squeeze()train_sample_X = torch.from_numpy(train_sample.drop([0], axis=1).values).long()# Build the datasettrain_sample_ds = torch.utils.data.TensorDataset(train_sample_X, train_sample_y)# Build the dataloadertrain_sample_dl = torch.utils.data.DataLoader(train_sample_ds, batch_size=50) (TODO) Writing the training methodNext we need to write the training code itself. This should be very similar to training methods that you have written before to train PyTorch models. We will leave any difficult aspects such as model saving / loading and parameter loading until a little later. 12345678910111213141516171819def train(model, train_loader, epochs, optimizer, loss_fn, device): for epoch in range(1, epochs + 1): model.train() total_loss = 0 for batch in train_loader: batch_X, batch_y = batch batch_X = batch_X.to(device) batch_y = batch_y.to(device) # TODO: Complete this train method to train the model provided. optimizer.zero_grad() output = model.forward(batch_X) loss = loss_fn(output, batch_y) loss.backward() optimizer.step() total_loss += loss.data.item() print(\"Epoch: &#123;&#125;, BCELoss: &#123;&#125;\".format(epoch, total_loss / len(train_loader))) Supposing we have the training method above, we will test that it is working by writing a bit of code in the notebook that executes our training method on the small sample training set that we loaded earlier. The reason for doing this in the notebook is so that we have an opportunity to fix any errors that arise early when they are easier to diagnose. 123456789import torch.optim as optimfrom train.model import LSTMClassifierdevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")model = LSTMClassifier(32, 100, 5000).to(device)optimizer = optim.Adam(model.parameters())loss_fn = torch.nn.BCELoss()train(model, train_sample_dl, 5, optimizer, loss_fn, device) Epoch: 1, BCELoss: 0.6931784152984619 Epoch: 2, BCELoss: 0.683626139163971 Epoch: 3, BCELoss: 0.6755886435508728 Epoch: 4, BCELoss: 0.6667218565940857 Epoch: 5, BCELoss: 0.6559338450431824In order to construct a PyTorch model using SageMaker we must provide SageMaker with a training script. We may optionally include a directory which will be copied to the container and from which our training code will be run. When the training container is executed it will check the uploaded directory (if there is one) for a requirements.txt file and install any required Python libraries, after which the training script will be run. (TODO) Training the modelWhen a PyTorch model is constructed in SageMaker, an entry point must be specified. This is the Python file which will be executed when the model is trained. Inside of the train directory is a file called train.py which has been provided and which contains most of the necessary code to train our model. The only thing that is missing is the implementation of the train() method which you wrote earlier in this notebook. TODO: Copy the train() method written above and paste it into the train/train.py file where required. The way that SageMaker passes hyperparameters to the training script is by way of arguments. These arguments can then be parsed and used in the training script. To see how this is done take a look at the provided train/train.py file. 123456789101112from sagemaker.pytorch import PyTorchestimator = PyTorch(entry_point=\"train.py\", source_dir=\"train\", role=role, framework_version='0.4.0', train_instance_count=1, train_instance_type='ml.p2.xlarge', hyperparameters=&#123; 'epochs': 10, 'hidden_dim': 200, &#125;) 1estimator.fit(&#123;'training': input_data&#125;) 2020-02-23 10:29:09 Starting - Starting the training job... 2020-02-23 10:29:11 Starting - Launching requested ML instances...... 2020-02-23 10:30:10 Starting - Preparing the instances for training...... 2020-02-23 10:31:12 Downloading - Downloading input data... 2020-02-23 10:31:56 Training - Downloading the training image..\u001b[34mbash: cannot set terminal process group (-1): Inappropriate ioctl for device\u001b[0m \u001b[34mbash: no job control in this shell\u001b[0m \u001b[34m2020-02-23 10:32:19,999 sagemaker-containers INFO Imported framework sagemaker_pytorch_container.training\u001b[0m \u001b[34m2020-02-23 10:32:20,024 sagemaker_pytorch_container.training INFO Block until all host DNS lookups succeed.\u001b[0m 2020-02-23 10:32:19 Training - Training image download completed. Training in progress.\u001b[34m2020-02-23 10:32:26,248 sagemaker_pytorch_container.training INFO Invoking user training script.\u001b[0m \u001b[34m2020-02-23 10:32:26,469 sagemaker-containers INFO Module train does not provide a setup.py. \u001b[0m \u001b[34mGenerating setup.py\u001b[0m \u001b[34m2020-02-23 10:32:26,470 sagemaker-containers INFO Generating setup.cfg\u001b[0m \u001b[34m2020-02-23 10:32:26,470 sagemaker-containers INFO Generating MANIFEST.in\u001b[0m \u001b[34m2020-02-23 10:32:26,470 sagemaker-containers INFO Installing module with the following command:\u001b[0m \u001b[34m/usr/bin/python -m pip install -U . -r requirements.txt\u001b[0m \u001b[34mProcessing /opt/ml/code\u001b[0m \u001b[34mCollecting pandas (from -r requirements.txt (line 1))\u001b[0m \u001b[34m Downloading https://files.pythonhosted.org/packages/74/24/0cdbf8907e1e3bc5a8da03345c23cbed7044330bb8f73bb12e711a640a00/pandas-0.24.2-cp35-cp35m-manylinux1_x86_64.whl (10.0MB)\u001b[0m \u001b[34mCollecting numpy (from -r requirements.txt (line 2)) Downloading https://files.pythonhosted.org/packages/52/e6/1715e592ef47f28f3f50065322423bb75619ed2f7c24be86380ecc93503c/numpy-1.18.1-cp35-cp35m-manylinux1_x86_64.whl (19.9MB)\u001b[0m \u001b[34mCollecting nltk (from -r requirements.txt (line 3)) Downloading https://files.pythonhosted.org/packages/f6/1d/d925cfb4f324ede997f6d47bea4d9babba51b49e87a767c170b77005889d/nltk-3.4.5.zip (1.5MB)\u001b[0m \u001b[34mCollecting beautifulsoup4 (from -r requirements.txt (line 4))\u001b[0m \u001b[34m Downloading https://files.pythonhosted.org/packages/cb/a1/c698cf319e9cfed6b17376281bd0efc6bfc8465698f54170ef60a485ab5d/beautifulsoup4-4.8.2-py3-none-any.whl (106kB)\u001b[0m \u001b[34mCollecting html5lib (from -r requirements.txt (line 5)) Downloading https://files.pythonhosted.org/packages/a5/62/bbd2be0e7943ec8504b517e62bab011b4946e1258842bc159e5dfde15b96/html5lib-1.0.1-py2.py3-none-any.whl (117kB)\u001b[0m \u001b[34mRequirement already satisfied, skipping upgrade: python-dateutil&gt;=2.5.0 in /usr/local/lib/python3.5/dist-packages (from pandas-&gt;-r requirements.txt (line 1)) (2.7.5)\u001b[0m \u001b[34mCollecting pytz&gt;=2011k (from pandas-&gt;-r requirements.txt (line 1)) Downloading https://files.pythonhosted.org/packages/e7/f9/f0b53f88060247251bf481fa6ea62cd0d25bf1b11a87888e53ce5b7c8ad2/pytz-2019.3-py2.py3-none-any.whl (509kB)\u001b[0m \u001b[34mRequirement already satisfied, skipping upgrade: six in /usr/local/lib/python3.5/dist-packages (from nltk-&gt;-r requirements.txt (line 3)) (1.11.0)\u001b[0m \u001b[34mCollecting soupsieve&gt;=1.2 (from beautifulsoup4-&gt;-r requirements.txt (line 4)) Downloading https://files.pythonhosted.org/packages/05/cf/ea245e52f55823f19992447b008bcbb7f78efc5960d77f6c34b5b45b36dd/soupsieve-2.0-py2.py3-none-any.whl\u001b[0m \u001b[34mCollecting webencodings (from html5lib-&gt;-r requirements.txt (line 5)) Downloading https://files.pythonhosted.org/packages/f4/24/2a3e3df732393fed8b3ebf2ec078f05546de641fe1b667ee316ec1dcf3b7/webencodings-0.5.1-py2.py3-none-any.whl\u001b[0m \u001b[34mBuilding wheels for collected packages: nltk, train Running setup.py bdist_wheel for nltk: started\u001b[0m \u001b[34m Running setup.py bdist_wheel for nltk: finished with status &apos;done&apos; Stored in directory: /root/.cache/pip/wheels/96/86/f6/68ab24c23f207c0077381a5e3904b2815136b879538a24b483 Running setup.py bdist_wheel for train: started Running setup.py bdist_wheel for train: finished with status &apos;done&apos; Stored in directory: /tmp/pip-ephem-wheel-cache-1z_fwhiw/wheels/35/24/16/37574d11bf9bde50616c67372a334f94fa8356bc7164af8ca3\u001b[0m \u001b[34mSuccessfully built nltk train\u001b[0m \u001b[34mInstalling collected packages: pytz, numpy, pandas, nltk, soupsieve, beautifulsoup4, webencodings, html5lib, train\u001b[0m \u001b[34m Found existing installation: numpy 1.15.4 Uninstalling numpy-1.15.4: Successfully uninstalled numpy-1.15.4\u001b[0m \u001b[34mSuccessfully installed beautifulsoup4-4.8.2 html5lib-1.0.1 nltk-3.4.5 numpy-1.18.1 pandas-0.24.2 pytz-2019.3 soupsieve-2.0 train-1.0.0 webencodings-0.5.1\u001b[0m \u001b[34mYou are using pip version 18.1, however version 20.0.2 is available.\u001b[0m \u001b[34mYou should consider upgrading via the &apos;pip install --upgrade pip&apos; command.\u001b[0m \u001b[34m2020-02-23 10:32:39,087 sagemaker-containers INFO Invoking user script \u001b[0m \u001b[34mTraining Env: \u001b[0m \u001b[34m{ &quot;channel_input_dirs&quot;: { &quot;training&quot;: &quot;/opt/ml/input/data/training&quot; }, &quot;current_host&quot;: &quot;algo-1&quot;, &quot;module_dir&quot;: &quot;s3://sagemaker-us-east-2-621192006701/sagemaker-pytorch-2020-02-23-10-29-09-269/source/sourcedir.tar.gz&quot;, &quot;user_entry_point&quot;: &quot;train.py&quot;, &quot;output_intermediate_dir&quot;: &quot;/opt/ml/output/intermediate&quot;, &quot;model_dir&quot;: &quot;/opt/ml/model&quot;, &quot;output_data_dir&quot;: &quot;/opt/ml/output/data&quot;, &quot;hyperparameters&quot;: { &quot;hidden_dim&quot;: 200, &quot;epochs&quot;: 10 }, &quot;framework_module&quot;: &quot;sagemaker_pytorch_container.training:main&quot;, &quot;resource_config&quot;: { &quot;network_interface_name&quot;: &quot;eth0&quot;, &quot;current_host&quot;: &quot;algo-1&quot;, &quot;hosts&quot;: [ &quot;algo-1&quot; ] }, &quot;num_gpus&quot;: 1, &quot;output_dir&quot;: &quot;/opt/ml/output&quot;, &quot;num_cpus&quot;: 4, &quot;log_level&quot;: 20, &quot;network_interface_name&quot;: &quot;eth0&quot;, &quot;input_config_dir&quot;: &quot;/opt/ml/input/config&quot;, &quot;additional_framework_parameters&quot;: {}, &quot;job_name&quot;: &quot;sagemaker-pytorch-2020-02-23-10-29-09-269&quot;, &quot;input_data_config&quot;: { &quot;training&quot;: { &quot;TrainingInputMode&quot;: &quot;File&quot;, &quot;S3DistributionType&quot;: &quot;FullyReplicated&quot;, &quot;RecordWrapperType&quot;: &quot;None&quot; } }, &quot;module_name&quot;: &quot;train&quot;, &quot;hosts&quot;: [ &quot;algo-1&quot; ], &quot;input_dir&quot;: &quot;/opt/ml/input&quot;\u001b[0m \u001b[34m} \u001b[0m \u001b[34mEnvironment variables: \u001b[0m \u001b[34mSM_NUM_CPUS=4\u001b[0m \u001b[34mSM_HP_EPOCHS=10\u001b[0m \u001b[34mSM_TRAINING_ENV={&quot;additional_framework_parameters&quot;:{},&quot;channel_input_dirs&quot;:{&quot;training&quot;:&quot;/opt/ml/input/data/training&quot;},&quot;current_host&quot;:&quot;algo-1&quot;,&quot;framework_module&quot;:&quot;sagemaker_pytorch_container.training:main&quot;,&quot;hosts&quot;:[&quot;algo-1&quot;],&quot;hyperparameters&quot;:{&quot;epochs&quot;:10,&quot;hidden_dim&quot;:200},&quot;input_config_dir&quot;:&quot;/opt/ml/input/config&quot;,&quot;input_data_config&quot;:{&quot;training&quot;:{&quot;RecordWrapperType&quot;:&quot;None&quot;,&quot;S3DistributionType&quot;:&quot;FullyReplicated&quot;,&quot;TrainingInputMode&quot;:&quot;File&quot;}},&quot;input_dir&quot;:&quot;/opt/ml/input&quot;,&quot;job_name&quot;:&quot;sagemaker-pytorch-2020-02-23-10-29-09-269&quot;,&quot;log_level&quot;:20,&quot;model_dir&quot;:&quot;/opt/ml/model&quot;,&quot;module_dir&quot;:&quot;s3://sagemaker-us-east-2-621192006701/sagemaker-pytorch-2020-02-23-10-29-09-269/source/sourcedir.tar.gz&quot;,&quot;module_name&quot;:&quot;train&quot;,&quot;network_interface_name&quot;:&quot;eth0&quot;,&quot;num_cpus&quot;:4,&quot;num_gpus&quot;:1,&quot;output_data_dir&quot;:&quot;/opt/ml/output/data&quot;,&quot;output_dir&quot;:&quot;/opt/ml/output&quot;,&quot;output_intermediate_dir&quot;:&quot;/opt/ml/output/intermediate&quot;,&quot;resource_config&quot;:{&quot;current_host&quot;:&quot;algo-1&quot;,&quot;hosts&quot;:[&quot;algo-1&quot;],&quot;network_interface_name&quot;:&quot;eth0&quot;},&quot;user_entry_point&quot;:&quot;train.py&quot;}\u001b[0m \u001b[34mSM_MODULE_NAME=train\u001b[0m \u001b[34mSM_MODEL_DIR=/opt/ml/model\u001b[0m \u001b[34mSM_INPUT_DATA_CONFIG={&quot;training&quot;:{&quot;RecordWrapperType&quot;:&quot;None&quot;,&quot;S3DistributionType&quot;:&quot;FullyReplicated&quot;,&quot;TrainingInputMode&quot;:&quot;File&quot;}}\u001b[0m \u001b[34mSM_NUM_GPUS=1\u001b[0m \u001b[34mSM_NETWORK_INTERFACE_NAME=eth0\u001b[0m \u001b[34mSM_HPS={&quot;epochs&quot;:10,&quot;hidden_dim&quot;:200}\u001b[0m \u001b[34mSM_FRAMEWORK_MODULE=sagemaker_pytorch_container.training:main\u001b[0m \u001b[34mSM_OUTPUT_DIR=/opt/ml/output\u001b[0m \u001b[34mSM_OUTPUT_INTERMEDIATE_DIR=/opt/ml/output/intermediate\u001b[0m \u001b[34mSM_FRAMEWORK_PARAMS={}\u001b[0m \u001b[34mSM_MODULE_DIR=s3://sagemaker-us-east-2-621192006701/sagemaker-pytorch-2020-02-23-10-29-09-269/source/sourcedir.tar.gz\u001b[0m \u001b[34mPYTHONPATH=/usr/local/bin:/usr/lib/python35.zip:/usr/lib/python3.5:/usr/lib/python3.5/plat-x86_64-linux-gnu:/usr/lib/python3.5/lib-dynload:/usr/local/lib/python3.5/dist-packages:/usr/lib/python3/dist-packages\u001b[0m \u001b[34mSM_CHANNELS=[&quot;training&quot;]\u001b[0m \u001b[34mSM_USER_ARGS=[&quot;--epochs&quot;,&quot;10&quot;,&quot;--hidden_dim&quot;,&quot;200&quot;]\u001b[0m \u001b[34mSM_CHANNEL_TRAINING=/opt/ml/input/data/training\u001b[0m \u001b[34mSM_INPUT_CONFIG_DIR=/opt/ml/input/config\u001b[0m \u001b[34mSM_HOSTS=[&quot;algo-1&quot;]\u001b[0m \u001b[34mSM_RESOURCE_CONFIG={&quot;current_host&quot;:&quot;algo-1&quot;,&quot;hosts&quot;:[&quot;algo-1&quot;],&quot;network_interface_name&quot;:&quot;eth0&quot;}\u001b[0m \u001b[34mSM_USER_ENTRY_POINT=train.py\u001b[0m \u001b[34mSM_HP_HIDDEN_DIM=200\u001b[0m \u001b[34mSM_INPUT_DIR=/opt/ml/input\u001b[0m \u001b[34mSM_CURRENT_HOST=algo-1\u001b[0m \u001b[34mSM_OUTPUT_DATA_DIR=/opt/ml/output/data\u001b[0m \u001b[34mSM_LOG_LEVEL=20 \u001b[0m \u001b[34mInvoking script with the following command: \u001b[0m \u001b[34m/usr/bin/python -m train --epochs 10 --hidden_dim 200 \u001b[0m \u001b[34mUsing device cuda.\u001b[0m \u001b[34mGet train data loader.\u001b[0m \u001b[34mModel loaded with embedding_dim 32, hidden_dim 200, vocab_size 5000.\u001b[0m \u001b[34mEpoch: 1, BCELoss: 0.6749516141657926\u001b[0m \u001b[34mEpoch: 2, BCELoss: 0.5924099878389009\u001b[0m \u001b[34mEpoch: 3, BCELoss: 0.50403351017407\u001b[0m \u001b[34mEpoch: 4, BCELoss: 0.4240985257284982\u001b[0m \u001b[34mEpoch: 5, BCELoss: 0.38010544862066\u001b[0m \u001b[34mEpoch: 6, BCELoss: 0.3434085663484067\u001b[0m \u001b[34mEpoch: 7, BCELoss: 0.319852275811896\u001b[0m \u001b[34mEpoch: 8, BCELoss: 0.32171173728242214\u001b[0m \u001b[34mEpoch: 9, BCELoss: 0.29324838214991045\u001b[0m 2020-02-23 10:35:41 Uploading - Uploading generated training model\u001b[34mEpoch: 10, BCELoss: 0.2656841928861579\u001b[0m \u001b[34m2020-02-23 10:35:40,457 sagemaker-containers INFO Reporting training SUCCESS\u001b[0m 2020-02-23 10:35:48 Completed - Training job completed Training seconds: 276 Billable seconds: 276Step 5: Testing the modelAs mentioned at the top of this notebook, we will be testing this model by first deploying it and then sending the testing data to the deployed endpoint. We will do this so that we can make sure that the deployed model is working correctly. Step 6: Deploy the model for testingNow that we have trained our model, we would like to test it to see how it performs. Currently our model takes input of the form review_length, review[500] where review[500] is a sequence of 500 integers which describe the words present in the review, encoded using word_dict. Fortunately for us, SageMaker provides built-in inference code for models with simple inputs such as this. There is one thing that we need to provide, however, and that is a function which loads the saved model. This function must be called model_fn() and takes as its only parameter a path to the directory where the model artifacts are stored. This function must also be present in the python file which we specified as the entry point. In our case the model loading function has been provided and so no changes need to be made. NOTE: When the built-in inference code is run it must import the model_fn() method from the train.py file. This is why the training code is wrapped in a main guard ( ie, if __name__ == &#39;__main__&#39;: ) Since we don’t need to change anything in the code that was uploaded during training, we can simply deploy the current model as-is. NOTE: When deploying a model you are asking SageMaker to launch an compute instance that will wait for data to be sent to it. As a result, this compute instance will continue to run until you shut it down. This is important to know since the cost of a deployed endpoint depends on how long it has been running for. In other words If you are no longer using a deployed endpoint, shut it down! TODO: Deploy the trained model. 12# TODO: Deploy the trained modelpredictor = estimator.deploy(initial_instance_count=1, instance_type='ml.m4.xlarge') -----------!Step 7 - Use the model for testingOnce deployed, we can read in the test data and send it off to our deployed model to get some results. Once we collect all of the results we can determine how accurate our model is. 1test_X = pd.concat([pd.DataFrame(test_X_len), pd.DataFrame(test_X)], axis=1) 123456789# We split the data into chunks and send each chunk seperately, accumulating the results.def predict(data, rows=512): split_array = np.array_split(data, int(data.shape[0] / float(rows) + 1)) predictions = np.array([]) for array in split_array: predictions = np.append(predictions, predictor.predict(array)) return predictions 12predictions = predict(test_X.values)predictions = [round(num) for num in predictions] 12from sklearn.metrics import accuracy_scoreaccuracy_score(test_y, predictions) 0.8506Question: How does this model compare to the XGBoost model you created earlier? Why might these two models perform differently on this dataset? Which do you think is better for sentiment analysis? Answer: The result from the RNN model is quite similar to the XGBoost model. Therefore, both models are preferred in sentiment analysis. (TODO) More testingWe now have a trained model which has been deployed and which we can send processed reviews to and which returns the predicted sentiment. However, ultimately we would like to be able to send our model an unprocessed review. That is, we would like to send the review itself as a string. For example, suppose we wish to send the following review to our model. 1test_review = 'The simplest pleasures in life are the best, and this film is one of them. Combining a rather basic storyline of love and adventure this movie transcends the usual weekend fair with wit and unmitigated charm.' The question we now need to answer is, how do we send this review to our model? Recall in the first section of this notebook we did a bunch of data processing to the IMDb dataset. In particular, we did two specific things to the provided reviews. Removed any html tags and stemmed the input Encoded the review as a sequence of integers using word_dict In order process the review we will need to repeat these two steps. TODO: Using the review_to_words and convert_and_pad methods from section one, convert test_review into a numpy array test_data suitable to send to our model. Remember that our model expects input of the form review_length, review[500]. 123# TODO: Convert test_review into a form usable by the model and save the results in test_datatest_data = review_to_words(test_review)test_data = [np.array(convert_and_pad(word_dict, test_data)[0])] Now that we have processed the review, we can send the resulting array to our model to predict the sentiment of the review. 1predictor.predict(test_data) array(0.6213178, dtype=float32)Since the return value of our model is close to 1, we can be certain that the review we submitted is positive. Delete the endpointOf course, just like in the XGBoost notebook, once we’ve deployed an endpoint it continues to run until we tell it to shut down. Since we are done using our endpoint for now, we can delete it. 1estimator.delete_endpoint() Step 6 (again) - Deploy the model for the web appNow that we know that our model is working, it’s time to create some custom inference code so that we can send the model a review which has not been processed and have it determine the sentiment of the review. As we saw above, by default the estimator which we created, when deployed, will use the entry script and directory which we provided when creating the model. However, since we now wish to accept a string as input and our model expects a processed review, we need to write some custom inference code. We will store the code that we write in the serve directory. Provided in this directory is the model.py file that we used to construct our model, a utils.py file which contains the review_to_words and convert_and_pad pre-processing functions which we used during the initial data processing, and predict.py, the file which will contain our custom inference code. Note also that requirements.txt is present which will tell SageMaker what Python libraries are required by our custom inference code. When deploying a PyTorch model in SageMaker, you are expected to provide four functions which the SageMaker inference container will use. model_fn: This function is the same function that we used in the training script and it tells SageMaker how to load our model. input_fn: This function receives the raw serialized input that has been sent to the model’s endpoint and its job is to de-serialize and make the input available for the inference code. output_fn: This function takes the output of the inference code and its job is to serialize this output and return it to the caller of the model’s endpoint. predict_fn: The heart of the inference script, this is where the actual prediction is done and is the function which you will need to complete. For the simple website that we are constructing during this project, the input_fn and output_fn methods are relatively straightforward. We only require being able to accept a string as input and we expect to return a single value as output. You might imagine though that in a more complex application the input or output may be image data or some other binary data which would require some effort to serialize. (TODO) Writing inference codeBefore writing our custom inference code, we will begin by taking a look at the code which has been provided. 1!pygmentize serve/predict.py \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36margparse\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mjson\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mos\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mpickle\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36msys\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36msagemaker_containers\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mpandas\u001b[39;49;00m \u001b[34mas\u001b[39;49;00m \u001b[04m\u001b[36mpd\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mnumpy\u001b[39;49;00m \u001b[34mas\u001b[39;49;00m \u001b[04m\u001b[36mnp\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mtorch\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mtorch.nn\u001b[39;49;00m \u001b[34mas\u001b[39;49;00m \u001b[04m\u001b[36mnn\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mtorch.optim\u001b[39;49;00m \u001b[34mas\u001b[39;49;00m \u001b[04m\u001b[36moptim\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m \u001b[04m\u001b[36mtorch.utils.data\u001b[39;49;00m \u001b[34mfrom\u001b[39;49;00m \u001b[04m\u001b[36mmodel\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m LSTMClassifier \u001b[34mfrom\u001b[39;49;00m \u001b[04m\u001b[36mutils\u001b[39;49;00m \u001b[34mimport\u001b[39;49;00m review_to_words, convert_and_pad \u001b[34mdef\u001b[39;49;00m \u001b[32mmodel_fn\u001b[39;49;00m(model_dir): \u001b[33m&quot;&quot;&quot;Load the PyTorch model from the `model_dir` directory.&quot;&quot;&quot;\u001b[39;49;00m \u001b[34mprint\u001b[39;49;00m(\u001b[33m&quot;\u001b[39;49;00m\u001b[33mLoading model.\u001b[39;49;00m\u001b[33m&quot;\u001b[39;49;00m) \u001b[37m# First, load the parameters used to create the model.\u001b[39;49;00m model_info = {} model_info_path = os.path.join(model_dir, \u001b[33m&apos;\u001b[39;49;00m\u001b[33mmodel_info.pth\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mwith\u001b[39;49;00m \u001b[36mopen\u001b[39;49;00m(model_info_path, \u001b[33m&apos;\u001b[39;49;00m\u001b[33mrb\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mas\u001b[39;49;00m f: model_info = torch.load(f) \u001b[34mprint\u001b[39;49;00m(\u001b[33m&quot;\u001b[39;49;00m\u001b[33mmodel_info: {}\u001b[39;49;00m\u001b[33m&quot;\u001b[39;49;00m.format(model_info)) \u001b[37m# Determine the device and construct the model.\u001b[39;49;00m device = torch.device(\u001b[33m&quot;\u001b[39;49;00m\u001b[33mcuda\u001b[39;49;00m\u001b[33m&quot;\u001b[39;49;00m \u001b[34mif\u001b[39;49;00m torch.cuda.is_available() \u001b[34melse\u001b[39;49;00m \u001b[33m&quot;\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m&quot;\u001b[39;49;00m) model = LSTMClassifier(model_info[\u001b[33m&apos;\u001b[39;49;00m\u001b[33membedding_dim\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m], model_info[\u001b[33m&apos;\u001b[39;49;00m\u001b[33mhidden_dim\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m], model_info[\u001b[33m&apos;\u001b[39;49;00m\u001b[33mvocab_size\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m]) \u001b[37m# Load the store model parameters.\u001b[39;49;00m model_path = os.path.join(model_dir, \u001b[33m&apos;\u001b[39;49;00m\u001b[33mmodel.pth\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mwith\u001b[39;49;00m \u001b[36mopen\u001b[39;49;00m(model_path, \u001b[33m&apos;\u001b[39;49;00m\u001b[33mrb\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mas\u001b[39;49;00m f: model.load_state_dict(torch.load(f)) \u001b[37m# Load the saved word_dict.\u001b[39;49;00m word_dict_path = os.path.join(model_dir, \u001b[33m&apos;\u001b[39;49;00m\u001b[33mword_dict.pkl\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mwith\u001b[39;49;00m \u001b[36mopen\u001b[39;49;00m(word_dict_path, \u001b[33m&apos;\u001b[39;49;00m\u001b[33mrb\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mas\u001b[39;49;00m f: model.word_dict = pickle.load(f) model.to(device).eval() \u001b[34mprint\u001b[39;49;00m(\u001b[33m&quot;\u001b[39;49;00m\u001b[33mDone loading model.\u001b[39;49;00m\u001b[33m&quot;\u001b[39;49;00m) \u001b[34mreturn\u001b[39;49;00m model \u001b[34mdef\u001b[39;49;00m \u001b[32minput_fn\u001b[39;49;00m(serialized_input_data, content_type): \u001b[34mprint\u001b[39;49;00m(\u001b[33m&apos;\u001b[39;49;00m\u001b[33mDeserializing the input data.\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mif\u001b[39;49;00m content_type == \u001b[33m&apos;\u001b[39;49;00m\u001b[33mtext/plain\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m: data = serialized_input_data.decode(\u001b[33m&apos;\u001b[39;49;00m\u001b[33mutf-8\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mreturn\u001b[39;49;00m data \u001b[34mraise\u001b[39;49;00m \u001b[36mException\u001b[39;49;00m(\u001b[33m&apos;\u001b[39;49;00m\u001b[33mRequested unsupported ContentType in content_type: \u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m + content_type) \u001b[34mdef\u001b[39;49;00m \u001b[32moutput_fn\u001b[39;49;00m(prediction_output, accept): \u001b[34mprint\u001b[39;49;00m(\u001b[33m&apos;\u001b[39;49;00m\u001b[33mSerializing the generated output.\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[34mreturn\u001b[39;49;00m \u001b[36mstr\u001b[39;49;00m(prediction_output) \u001b[34mdef\u001b[39;49;00m \u001b[32mpredict_fn\u001b[39;49;00m(input_data, model): \u001b[34mprint\u001b[39;49;00m(\u001b[33m&apos;\u001b[39;49;00m\u001b[33mInferring sentiment of input data.\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) device = torch.device(\u001b[33m&quot;\u001b[39;49;00m\u001b[33mcuda\u001b[39;49;00m\u001b[33m&quot;\u001b[39;49;00m \u001b[34mif\u001b[39;49;00m torch.cuda.is_available() \u001b[34melse\u001b[39;49;00m \u001b[33m&quot;\u001b[39;49;00m\u001b[33mcpu\u001b[39;49;00m\u001b[33m&quot;\u001b[39;49;00m) \u001b[34mif\u001b[39;49;00m model.word_dict \u001b[35mis\u001b[39;49;00m \u001b[36mNone\u001b[39;49;00m: \u001b[34mraise\u001b[39;49;00m \u001b[36mException\u001b[39;49;00m(\u001b[33m&apos;\u001b[39;49;00m\u001b[33mModel has not been loaded properly, no word_dict.\u001b[39;49;00m\u001b[33m&apos;\u001b[39;49;00m) \u001b[37m# TODO: Process input_data so that it is ready to be sent to our model.\u001b[39;49;00m \u001b[37m# You should produce two variables:\u001b[39;49;00m \u001b[37m# data_X - A sequence of length 500 which represents the converted review\u001b[39;49;00m \u001b[37m# data_len - The length of the review\u001b[39;49;00m data_X = \u001b[36mNone\u001b[39;49;00m data_len = \u001b[36mNone\u001b[39;49;00m \u001b[37m# Using data_X and data_len we construct an appropriate input tensor. Remember\u001b[39;49;00m \u001b[37m# that our model expects input data of the form &apos;len, review[500]&apos;.\u001b[39;49;00m data_pack = np.hstack((data_len, data_X)) data_pack = data_pack.reshape(\u001b[34m1\u001b[39;49;00m, -\u001b[34m1\u001b[39;49;00m) data = torch.from_numpy(data_pack) data = data.to(device) \u001b[37m# Make sure to put the model into evaluation mode\u001b[39;49;00m model.eval() \u001b[37m# TODO: Compute the result of applying the model to the input data. The variable `result` should\u001b[39;49;00m \u001b[37m# be a numpy array which contains a single integer which is either 1 or 0\u001b[39;49;00m result = \u001b[36mNone\u001b[39;49;00m \u001b[34mreturn\u001b[39;49;00m resultAs mentioned earlier, the model_fn method is the same as the one provided in the training code and the input_fn and output_fn methods are very simple and your task will be to complete the predict_fn method. Make sure that you save the completed file as predict.py in the serve directory. TODO: Complete the predict_fn() method in the serve/predict.py file. Deploying the modelNow that the custom inference code has been written, we will create and deploy our model. To begin with, we need to construct a new PyTorchModel object which points to the model artifacts created during training and also points to the inference code that we wish to use. Then we can call the deploy method to launch the deployment container. NOTE: The default behaviour for a deployed PyTorch model is to assume that any input passed to the predictor is a numpy array. In our case we want to send a string so we need to construct a simple wrapper around the RealTimePredictor class to accomodate simple strings. In a more complicated situation you may want to provide a serialization object, for example if you wanted to sent image data. 1234567891011121314from sagemaker.predictor import RealTimePredictorfrom sagemaker.pytorch import PyTorchModelclass StringPredictor(RealTimePredictor): def __init__(self, endpoint_name, sagemaker_session): super(StringPredictor, self).__init__(endpoint_name, sagemaker_session, content_type='text/plain')model = PyTorchModel(model_data=estimator.model_data, role = role, framework_version='0.4.0', entry_point='predict.py', source_dir='serve', predictor_cls=StringPredictor)predictor = model.deploy(initial_instance_count=1, instance_type='ml.m4.xlarge') -----------!Testing the modelNow that we have deployed our model with the custom inference code, we should test to see if everything is working. Here we test our model by loading the first 250 positive and negative reviews and send them to the endpoint, then collect the results. The reason for only sending some of the data is that the amount of time it takes for our model to process the input and then perform inference is quite long and so testing the entire data set would be prohibitive. 12345678910111213141516171819202122232425262728293031323334353637import globdef test_reviews(data_dir='../data/aclImdb', stop=250): results = [] ground = [] # We make sure to test both positive and negative reviews for sentiment in ['pos', 'neg']: path = os.path.join(data_dir, 'test', sentiment, '*.txt') files = glob.glob(path) files_read = 0 print('Starting ', sentiment, ' files') # Iterate through the files and send them to the predictor for f in files: with open(f) as review: # First, we store the ground truth (was the review positive or negative) if sentiment == 'pos': ground.append(1) else: ground.append(0) # Read in the review and convert to 'utf-8' for transmission via HTTP review_input = review.read().encode('utf-8') # Send the review to the predictor and store the results results.append(float(predictor.predict(review_input))) # Sending reviews to our endpoint one at a time takes a while so we # only send a small number of reviews files_read += 1 if files_read == stop: break return ground, results 1ground, results = test_reviews() Starting pos files Starting neg files12from sklearn.metrics import accuracy_scoreaccuracy_score(ground, results) 0.854As an additional test, we can try sending the test_review that we looked at earlier. 1predictor.predict(test_review) b&apos;1.0&apos;Now that we know our endpoint is working as expected, we can set up the web page that will interact with it. If you don’t have time to finish the project now, make sure to skip down to the end of this notebook and shut down your endpoint. You can deploy it again when you come back. Step 7 (again): Use the model for the web app TODO: This entire section and the next contain tasks for you to complete, mostly using the AWS console. So far we have been accessing our model endpoint by constructing a predictor object which uses the endpoint and then just using the predictor object to perform inference. What if we wanted to create a web app which accessed our model? The way things are set up currently makes that not possible since in order to access a SageMaker endpoint the app would first have to authenticate with AWS using an IAM role which included access to SageMaker endpoints. However, there is an easier way! We just need to use some additional AWS services. The diagram above gives an overview of how the various services will work together. On the far right is the model which we trained above and which is deployed using SageMaker. On the far left is our web app that collects a user’s movie review, sends it off and expects a positive or negative sentiment in return. In the middle is where some of the magic happens. We will construct a Lambda function, which you can think of as a straightforward Python function that can be executed whenever a specified event occurs. We will give this function permission to send and recieve data from a SageMaker endpoint. Lastly, the method we will use to execute the Lambda function is a new endpoint that we will create using API Gateway. This endpoint will be a url that listens for data to be sent to it. Once it gets some data it will pass that data on to the Lambda function and then return whatever the Lambda function returns. Essentially it will act as an interface that lets our web app communicate with the Lambda function. Setting up a Lambda functionThe first thing we are going to do is set up a Lambda function. This Lambda function will be executed whenever our public API has data sent to it. When it is executed it will receive the data, perform any sort of processing that is required, send the data (the review) to the SageMaker endpoint we’ve created and then return the result. Part A: Create an IAM Role for the Lambda functionSince we want the Lambda function to call a SageMaker endpoint, we need to make sure that it has permission to do so. To do this, we will construct a role that we can later give the Lambda function. Using the AWS Console, navigate to the IAM page and click on Roles. Then, click on Create role. Make sure that the AWS service is the type of trusted entity selected and choose Lambda as the service that will use this role, then click Next: Permissions. In the search box type sagemaker and select the check box next to the AmazonSageMakerFullAccess policy. Then, click on Next: Review. Lastly, give this role a name. Make sure you use a name that you will remember later on, for example LambdaSageMakerRole. Then, click on Create role. Part B: Create a Lambda functionNow it is time to actually create the Lambda function. Using the AWS Console, navigate to the AWS Lambda page and click on Create a function. When you get to the next page, make sure that Author from scratch is selected. Now, name your Lambda function, using a name that you will remember later on, for example sentiment_analysis_func. Make sure that the Python 3.6 runtime is selected and then choose the role that you created in the previous part. Then, click on Create Function. On the next page you will see some information about the Lambda function you’ve just created. If you scroll down you should see an editor in which you can write the code that will be executed when your Lambda function is triggered. In our example, we will use the code below. 12345678910111213141516171819202122# We need to use the low-level library to interact with SageMaker since the SageMaker API# is not available natively through Lambda.import boto3def lambda_handler(event, context): # The SageMaker runtime is what allows us to invoke the endpoint that we've created. runtime = boto3.Session().client('sagemaker-runtime') # Now we use the SageMaker runtime to invoke our endpoint, sending the review we were given response = runtime.invoke_endpoint(EndpointName = '**ENDPOINT NAME HERE**', # The name of the endpoint we created ContentType = 'text/plain', # The data format that is expected Body = event['body']) # The actual review # The response is an HTTP response whose body contains the result of our inference result = response['Body'].read().decode('utf-8') return &#123; 'statusCode' : 200, 'headers' : &#123; 'Content-Type' : 'text/plain', 'Access-Control-Allow-Origin' : '*' &#125;, 'body' : result &#125; Once you have copy and pasted the code above into the Lambda code editor, replace the **ENDPOINT NAME HERE** portion with the name of the endpoint that we deployed earlier. You can determine the name of the endpoint using the code cell below. 1predictor.endpoint &apos;sagemaker-pytorch-2020-02-23-11-11-09-175&apos;Once you have added the endpoint name to the Lambda function, click on Save. Your Lambda function is now up and running. Next we need to create a way for our web app to execute the Lambda function. Setting up API GatewayNow that our Lambda function is set up, it is time to create a new API using API Gateway that will trigger the Lambda function we have just created. Using AWS Console, navigate to Amazon API Gateway and then click on Get started. On the next page, make sure that New API is selected and give the new api a name, for example, sentiment_analysis_api. Then, click on Create API. Now we have created an API, however it doesn’t currently do anything. What we want it to do is to trigger the Lambda function that we created earlier. Select the Actions dropdown menu and click Create Method. A new blank method will be created, select its dropdown menu and select POST, then click on the check mark beside it. For the integration point, make sure that Lambda Function is selected and click on the Use Lambda Proxy integration. This option makes sure that the data that is sent to the API is then sent directly to the Lambda function with no processing. It also means that the return value must be a proper response object as it will also not be processed by API Gateway. Type the name of the Lambda function you created earlier into the Lambda Function text entry box and then click on Save. Click on OK in the pop-up box that then appears, giving permission to API Gateway to invoke the Lambda function you created. The last step in creating the API Gateway is to select the Actions dropdown and click on Deploy API. You will need to create a new Deployment stage and name it anything you like, for example prod. You have now successfully set up a public API to access your SageMaker model. Make sure to copy or write down the URL provided to invoke your newly created public API as this will be needed in the next step. This URL can be found at the top of the page, highlighted in blue next to the text Invoke URL. Step 8: Deploying our web appNow that we have a publicly available API, we can start using it in a web app. For our purposes, we have provided a simple static html file which can make use of the public api you created earlier. In the website folder there should be a file called index.html. Download the file to your computer and open that file up in a text editor of your choice. There should be a line which contains **REPLACE WITH PUBLIC API URL**. Replace this string with the url that you wrote down in the last step and then save the file. Now, if you open index.html on your local computer, your browser will behave as a local web server and you can use the provided site to interact with your SageMaker model. If you’d like to go further, you can host this html file anywhere you’d like, for example using github or hosting a static site on Amazon’s S3. Once you have done this you can share the link with anyone you’d like and have them play with it too! Important Note In order for the web app to communicate with the SageMaker endpoint, the endpoint has to actually be deployed and running. This means that you are paying for it. Make sure that the endpoint is running when you want to use the web app but that you shut it down when you don’t need it, otherwise you will end up with a surprisingly large AWS bill. TODO: Make sure that you include the edited index.html file in your project submission. Now that your web app is working, trying playing around with it and see how well it works. Question: Give an example of a review that you entered into your web app. What was the predicted sentiment of your example review? Answer: I tried to use real reviews based on the movie ‘1917’, the performance is good. Delete the endpointRemember to always shut down your endpoint if you are no longer using it. You are charged for the length of time that the endpoint is running so if you forget and leave it on you could end up with an unexpectedly large bill. 1predictor.delete_endpoint()","comments":true,"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"第一个python package -- actupac","date":"2020-02-20T09:57:35.000Z","path":"2020/02/20/actupac_package/","text":"一个自己做的精算python包,实现内推和外推利率,并且画出利率曲线。该篇是使用说明和例子。 基本介绍actupac 是一个精算的python包,目前的功能是内推和外推利率,并且画出利率曲线。代码地址:https://github.com/JasonVictor17/actupac 安装方式1pip install actupac Collecting actupac Downloading https://files.pythonhosted.org/packages/78/6d/100b147d64d2b2653f93818af3da6013f23b53120bdc66e1092133500ff3/actupac-0.1.tar.gz Building wheels for collected packages: actupac Building wheel for actupac (setup.py): started Building wheel for actupac (setup.py): finished with status &apos;done&apos; Created wheel for actupac: filename=actupac-0.1-cp37-none-any.whl size=5979 sha256=7eb4984f5edbdd2af0de32a2fb795215bc159ce70f39eb398dead35d5f97950f Stored in directory: C:\\Users\\jasonguo\\AppData\\Local\\pip\\Cache\\wheels\\83\\19\\8e\\472924dcac472b470f64c7e2fdd5553ea1af6857d213253170 Successfully built actupac Installing collected packages: actupac Successfully installed actupac-0.1 Note: you may need to restart the kernel to use updated packages.导入包12from actupac import Interpolationfrom actupac import Extrapolation 使用方法1. 内推目前有三种方法:piecewise linear, piecewise constant, 以及 cubic spline。 其中 cubic spline 使用两端二次导为零的方法,所以是natural spline。 数据需要存储在csv格式文件中,第一列为年份,第二列为利率即可,不需要列名等。 可以改变的参数是内推点的个数,以下以9个点为例子: 1234# Read the datasetsample = Interpolation()df = sample.read_data('interest.csv')df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Years Yields 0 1 1.129 1 2 1.224 2 3 1.364 3 4 1.540 4 5 1.707 12345# calculate means and standard deviation and discount ratesprint(sample.mean)print(sample.stdev)discount = sample.discount_rate()discount[0:5] 2.3666 0.492 [0.9887734928804884, 0.9758172050673466, 0.9599059193497299, 0.9402589151464628, 0.9181908613542313]12# plot the distribution of the datasetsample.plot_histogram() 1234# interpolate with piecewise linear model with 9 interpolated points between each known yearlinear = sample.piecewise_linear(9)print(linear.head())sample.piecewise_linear_plot() Years Yields Pt Ft 0 1.0 1.1290 0.988773 1.234261 1 1.1 1.1385 0.987555 1.253285 2 1.2 1.1480 0.986318 1.272309 3 1.3 1.1575 0.985065 1.291333 4 1.4 1.1670 0.983795 1.310358 1234# interpolate with piecewise constant model with 9 interpolated points between each known yearconstant = sample.piecewise_constant(9)print(constant.head())sample.piecewise_constant_plot() Years Yields Pt Ft 0 1.0 1.129000 0.988773 1.31987 1 1.1 1.146273 0.987470 1.31987 2 1.2 1.160667 0.986169 1.31987 3 1.3 1.172846 0.984869 1.31987 4 1.4 1.183286 0.983570 1.31987 1234# interpolate with cubic spline (natural spline) model with 9 interpolated points between each known yearcubic = sample.cubic(9)print(cubic.head())sample.cubic_plot() Years Yields Pt Ft 0 1.0 1.129000 0.988773 1.224226 1 1.1 1.137589 0.987564 1.242089 2 1.2 1.146233 0.986339 1.260836 3 1.3 1.154987 0.985097 1.280690 4 1.4 1.163908 0.983837 1.301870 2. 外推目前只有 Smith Wilson 方法进行同时外推和内推, 需要手动输入已知数据创建为列表形式即可。 可变参数有三个,n是步长,0.1代表0.1年为一个步长;max_year是外推的最大年份, UFR 是 Ultimate forward rate 可以根据需要改变。 12a = list([1,2,3,4,5,10,15,20,30,50])b = list([3.2870,3.1280,3.2240,3.3680,3.4710,3.9860,4.2070,4.0540,3.4320,2.9310]) 123# read the data and creat a dataframesample2 = Extrapolation(a,b)sample2.dataframe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Years Yields 0 1.0 3.287 1 2.0 3.128 2 3.0 3.224 3 4.0 3.368 4 5.0 3.471 5 10.0 3.986 6 15.0 4.207 7 20.0 4.054 8 30.0 3.432 9 50.0 2.931 12# results sample2.Smith_Wilson(n=0.1,max_year=70,UFR=4.2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Years Yields Discount rates Forward rates 0 0.0 NaN 1.000000 3.401529 1 0.1 3.395757 0.996610 3.395344 2 0.2 3.392675 0.993238 3.382345 3 0.3 3.387329 0.989889 3.362554 4 0.4 3.379725 0.986572 3.335994 ... ... ... ... ... 696 69.6 3.151262 0.111550 4.059759 697 69.7 3.152554 0.111099 4.061264 698 69.8 3.153844 0.110650 4.062754 699 69.9 3.155132 0.110202 4.064228 700 70.0 3.156419 0.109756 NaN 701 rows × 4 columns 12# plotssample2.Smith_Wilson_plot()","comments":true,"tags":[{"name":"精算","slug":"精算","permalink":"http://yoursite.com/tags/%E7%B2%BE%E7%AE%97/"}]},{"title":"Identify Customer Segments","date":"2020-02-05T09:04:35.000Z","path":"2020/02/05/Identify_Customer_Segments/","text":"Identify segments of the population that form the core customer base for a mail-order sales company in Germany. These segments can then be used to direct marketing campaigns towards audiences that will have the highest expected rate of returns. Project: Identify Customer SegmentsIn this project, you will apply unsupervised learning techniques to identify segments of the population that form the core customer base for a mail-order sales company in Germany. These segments can then be used to direct marketing campaigns towards audiences that will have the highest expected rate of returns. The data that you will use has been provided by our partners at Bertelsmann Arvato Analytics, and represents a real-life data science task. This notebook will help you complete this task by providing a framework within which you will perform your analysis steps. In each step of the project, you will see some text describing the subtask that you will perform, followed by one or more code cells for you to complete your work. Feel free to add additional code and markdown cells as you go along so that you can explore everything in precise chunks. The code cells provided in the base template will outline only the major tasks, and will usually not be enough to cover all of the minor tasks that comprise it. It should be noted that while there will be precise guidelines on how you should handle certain tasks in the project, there will also be places where an exact specification is not provided. There will be times in the project where you will need to make and justify your own decisions on how to treat the data. These are places where there may not be only one way to handle the data. In real-life tasks, there may be many valid ways to approach an analysis task. One of the most important things you can do is clearly document your approach so that other scientists can understand the decisions you’ve made. At the end of most sections, there will be a Markdown cell labeled Discussion. In these cells, you will report your findings for the completed section, as well as document the decisions that you made in your approach to each subtask. Your project will be evaluated not just on the code used to complete the tasks outlined, but also your communication about your observations and conclusions at each stage. 1234567891011# import libraries here; add more as necessaryimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as snsimport refrom sklearn.preprocessing import StandardScalerfrom sklearn.decomposition import PCAfrom sklearn.cluster import KMeans# magic word for producing visualizations in notebook%matplotlib inline Step 0: Load the DataThere are four files associated with this project (not including this one): Udacity_AZDIAS_Subset.csv: Demographics data for the general population of Germany; 891211 persons (rows) x 85 features (columns). Udacity_CUSTOMERS_Subset.csv: Demographics data for customers of a mail-order company; 191652 persons (rows) x 85 features (columns). Data_Dictionary.md: Detailed information file about the features in the provided datasets. AZDIAS_Feature_Summary.csv: Summary of feature attributes for demographics data; 85 features (rows) x 4 columns Each row of the demographics files represents a single person, but also includes information outside of individuals, including information about their household, building, and neighborhood. You will use this information to cluster the general population into groups with similar demographic properties. Then, you will see how the people in the customers dataset fit into those created clusters. The hope here is that certain clusters are over-represented in the customers data, as compared to the general population; those over-represented clusters will be assumed to be part of the core userbase. This information can then be used for further applications, such as targeting for a marketing campaign. To start off with, load in the demographics data for the general population into a pandas DataFrame, and do the same for the feature attributes summary. Note for all of the .csv data files in this project: they’re semicolon (;) delimited, so you’ll need an additional argument in your read_csv() call to read in the data properly. Also, considering the size of the main dataset, it may take some time for it to load completely. Once the dataset is loaded, it’s recommended that you take a little bit of time just browsing the general structure of the dataset and feature summary file. You’ll be getting deep into the innards of the cleaning in the first major step of the project, so gaining some general familiarity can help you get your bearings. 12345# Load in the general demographics data.azdias = pd.read_csv('Udacity_AZDIAS_Subset.csv',sep=';')# Load in the feature summary file.feat_info = pd.read_csv('AZDIAS_Feature_Summary.csv',sep=';') 123456# Check the structure of the data after it's loaded (e.g. print the number of# rows and columns, print the first few rows).# Info for general demographics data.print(\"Total number of rows: &#123;&#125;\".format(azdias.shape[0]))print(\"Total number of columns: &#123;&#125;\".format(azdias.shape[1]))azdias.head() Total number of rows: 891221 Total number of columns: 85 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } AGER_TYP ALTERSKATEGORIE_GROB ANREDE_KZ CJT_GESAMTTYP FINANZ_MINIMALIST FINANZ_SPARER FINANZ_VORSORGER FINANZ_ANLEGER FINANZ_UNAUFFAELLIGER FINANZ_HAUSBAUER ... PLZ8_ANTG1 PLZ8_ANTG2 PLZ8_ANTG3 PLZ8_ANTG4 PLZ8_BAUMAX PLZ8_HHZ PLZ8_GBZ ARBEIT ORTSGR_KLS9 RELAT_AB 0 -1 2 1 2.0 3 4 3 5 5 3 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1 -1 1 2 5.0 1 5 2 5 4 5 ... 2.0 3.0 2.0 1.0 1.0 5.0 4.0 3.0 5.0 4.0 2 -1 3 2 3.0 1 4 1 2 3 5 ... 3.0 3.0 1.0 0.0 1.0 4.0 4.0 3.0 5.0 2.0 3 2 4 2 2.0 4 2 5 2 1 2 ... 2.0 2.0 2.0 0.0 1.0 3.0 4.0 2.0 3.0 3.0 4 -1 3 1 5.0 4 3 4 1 3 2 ... 2.0 4.0 2.0 1.0 2.0 3.0 3.0 4.0 6.0 5.0 5 rows × 85 columns 1234# info for the feature summary fileprint(\"Total number of rows: &#123;&#125;\".format(feat_info.shape[0]))print(\"Total number of columns: &#123;&#125;\".format(feat_info.shape[1]))feat_info.head() Total number of rows: 85 Total number of columns: 4 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } attribute information_level type missing_or_unknown 0 AGER_TYP person categorical [-1,0] 1 ALTERSKATEGORIE_GROB person ordinal [-1,0,9] 2 ANREDE_KZ person categorical [-1,0] 3 CJT_GESAMTTYP person categorical [0] 4 FINANZ_MINIMALIST person ordinal [-1] Tip: Add additional cells to keep everything in reasonably-sized chunks! Keyboard shortcut esc --&gt; a (press escape to enter command mode, then press the ‘A’ key) adds a new cell before the active cell, and esc --&gt; b adds a new cell after the active cell. If you need to convert an active cell to a markdown cell, use esc --&gt; m and to convert to a code cell, use esc --&gt; y. Step 1: PreprocessingStep 1.1: Assess Missing DataThe feature summary file contains a summary of properties for each demographics data column. You will use this file to help you make cleaning decisions during this stage of the project. First of all, you should assess the demographics data in terms of missing data. Pay attention to the following points as you perform your analysis, and take notes on what you observe. Make sure that you fill in the Discussion cell with your findings and decisions at the end of each step that has one! Step 1.1.1: Convert Missing Value Codes to NaNsThe fourth column of the feature attributes summary (loaded in above as feat_info) documents the codes from the data dictionary that indicate missing or unknown data. While the file encodes this as a list (e.g. [-1,0]), this will get read in as a string object. You’ll need to do a little bit of parsing to make use of it to identify and clean the data. Convert data that matches a ‘missing’ or ‘unknown’ value code into a numpy NaN value. You might want to see how much data takes on a ‘missing’ or ‘unknown’ code, and how much data is naturally missing, as a point of interest. As one more reminder, you are encouraged to add additional cells to break up your analysis into manageable chunks. 123# How much data is naturally missing in the dataset for each column.nature_missing = azdias.isna().sum()nature_missing[nature_missing != 0] CJT_GESAMTTYP 4854 GFK_URLAUBERTYP 4854 LP_LEBENSPHASE_FEIN 4854 LP_LEBENSPHASE_GROB 4854 LP_FAMILIE_FEIN 4854 LP_FAMILIE_GROB 4854 LP_STATUS_FEIN 4854 LP_STATUS_GROB 4854 RETOURTYP_BK_S 4854 SOHO_KZ 73499 TITEL_KZ 73499 ALTER_HH 73499 ANZ_PERSONEN 73499 ANZ_TITEL 73499 HH_EINKOMMEN_SCORE 18348 KK_KUNDENTYP 584612 W_KEIT_KIND_HH 107602 WOHNDAUER_2008 73499 ANZ_HAUSHALTE_AKTIV 93148 ANZ_HH_TITEL 97008 GEBAEUDETYP 93148 KONSUMNAEHE 73969 MIN_GEBAEUDEJAHR 93148 OST_WEST_KZ 93148 WOHNLAGE 93148 CAMEO_DEUG_2015 98979 CAMEO_DEU_2015 98979 CAMEO_INTL_2015 98979 KBA05_ANTG1 133324 KBA05_ANTG2 133324 KBA05_ANTG3 133324 KBA05_ANTG4 133324 KBA05_BAUMAX 133324 KBA05_GBZ 133324 BALLRAUM 93740 EWDICHTE 93740 INNENSTADT 93740 GEBAEUDETYP_RASTER 93155 KKK 121196 MOBI_REGIO 133324 ONLINE_AFFINITAET 4854 REGIOTYP 121196 KBA13_ANZAHL_PKW 105800 PLZ8_ANTG1 116515 PLZ8_ANTG2 116515 PLZ8_ANTG3 116515 PLZ8_ANTG4 116515 PLZ8_BAUMAX 116515 PLZ8_HHZ 116515 PLZ8_GBZ 116515 ARBEIT 97216 ORTSGR_KLS9 97216 RELAT_AB 97216 dtype: int64123456# Identify missing or unknown data values and convert them to NaNs.pattern = re.compile(r'\\-\\d+|\\d+') # find all numbersfor i in range (len(feat_info)): index = pattern.findall(feat_info['missing_or_unknown'][i]) index = list(map(int, index)) azdias.iloc[:,i] = azdias.iloc[:,i].replace(index,np.nan) 12345pattern = re.compile(r'[A-Z]+') # find all XXi = np.arange(57,60)for each in i: index = pattern.findall(feat_info['missing_or_unknown'][each])[0] azdias.iloc[:,each] = azdias.iloc[:,each].replace(index,np.nan) 123# How mcuh data takes on a 'missing' or 'unknown' codeindicated_miss = azdias.isna().sum()-nature_missingindicated_miss[indicated_miss != 0] AGER_TYP 685843 ALTERSKATEGORIE_GROB 2881 GEBURTSJAHR 392318 HEALTH_TYP 111196 LP_LEBENSPHASE_FEIN 92778 LP_LEBENSPHASE_GROB 89718 LP_FAMILIE_FEIN 72938 LP_FAMILIE_GROB 72938 NATIONALITAET_KZ 108315 PRAEGENDE_JUGENDJAHRE 108164 SHOPPER_TYP 111196 TITEL_KZ 815562 VERS_TYP 111196 ALTER_HH 236768 W_KEIT_KIND_HH 40386 ANZ_HAUSHALTE_AKTIV 6463 CAMEO_DEUG_2015 373 CAMEO_DEU_2015 373 CAMEO_INTL_2015 373 KBA05_BAUMAX 343200 KKK 36868 REGIOTYP 36868 ARBEIT 159 ORTSGR_KLS9 58 RELAT_AB 159 dtype: int64Step 1.1.2: Assess Missing Data in Each ColumnHow much missing data is present in each column? There are a few columns that are outliers in terms of the proportion of values that are missing. You will want to use matplotlib’s hist() function to visualize the distribution of missing value counts to find these columns. Identify and document these columns. While some of these columns might have justifications for keeping or re-encoding the data, for this project you should just remove them from the dataframe. (Feel free to make remarks about these outlier columns in the discussion, however!) For the remaining features, are there any patterns in which columns have, or share, missing data? 123456# Perform an assessment of how much missing data there is in each column of the dataset.count_nan = azdias.isna().sum().sort_values(ascending = False)count_nan = count_nan[count_nan != 0] # sort the countsplt.hist(count_nan,bins=30)plt.show() Based on the graph we can notice most counts of missing values are centered around 150,000, and some are actually have a lot of missing values. 123456789count_nan = (count_nan/891221)[0:10]names = list(count_nan.index)plt.figure()plt.bar(np.arange(len(names)),count_nan, alpha=0.5)plt.xticks(np.arange(len(names)),names,rotation = 60,fontsize=10)plt.ylabel('Percentage')plt.title('Percentage of missing values')plt.tight_layout()plt.show() From the graph above we can see top six variables have over 30% values are missing, those should be removed. 12345# Remove the outlier columns from the dataset. (You'll perform other data# engineering tasks such as re-encoding and imputation later.)remove_names = list(count_nan[0:6].index)deleted_var = azdias[remove_names] # save deleted variablesazdias.drop(remove_names,axis=1,inplace=True) 1print(\"Total number of columns: &#123;&#125;\".format(azdias.shape[1])) Total number of columns: 791234# Investigate patterns in the amount of missing data in each column.count_nan = azdias.isna().sum().sort_values(ascending = False)count_nan = count_nan[count_nan != 0] count_nan KKK 158064 REGIOTYP 158064 W_KEIT_KIND_HH 147988 MOBI_REGIO 133324 KBA05_ANTG4 133324 KBA05_ANTG3 133324 KBA05_ANTG2 133324 KBA05_ANTG1 133324 KBA05_GBZ 133324 PLZ8_ANTG2 116515 PLZ8_ANTG1 116515 PLZ8_ANTG3 116515 PLZ8_ANTG4 116515 PLZ8_BAUMAX 116515 PLZ8_HHZ 116515 PLZ8_GBZ 116515 HEALTH_TYP 111196 SHOPPER_TYP 111196 VERS_TYP 111196 NATIONALITAET_KZ 108315 PRAEGENDE_JUGENDJAHRE 108164 KBA13_ANZAHL_PKW 105800 ANZ_HAUSHALTE_AKTIV 99611 CAMEO_INTL_2015 99352 CAMEO_DEU_2015 99352 CAMEO_DEUG_2015 99352 LP_LEBENSPHASE_FEIN 97632 RELAT_AB 97375 ARBEIT 97375 ORTSGR_KLS9 97274 ANZ_HH_TITEL 97008 LP_LEBENSPHASE_GROB 94572 INNENSTADT 93740 BALLRAUM 93740 EWDICHTE 93740 GEBAEUDETYP_RASTER 93155 OST_WEST_KZ 93148 MIN_GEBAEUDEJAHR 93148 WOHNLAGE 93148 GEBAEUDETYP 93148 LP_FAMILIE_FEIN 77792 LP_FAMILIE_GROB 77792 KONSUMNAEHE 73969 ANZ_PERSONEN 73499 ANZ_TITEL 73499 WOHNDAUER_2008 73499 SOHO_KZ 73499 HH_EINKOMMEN_SCORE 18348 CJT_GESAMTTYP 4854 GFK_URLAUBERTYP 4854 RETOURTYP_BK_S 4854 ONLINE_AFFINITAET 4854 LP_STATUS_FEIN 4854 LP_STATUS_GROB 4854 ALTERSKATEGORIE_GROB 2881 dtype: int64Discussion 1.1.2: Assess Missing Data in Each ColumnSome columns have exactly the same amount of missing values, which means they might also share those missing values. The variables which have more than 30% missing values are deleted. The deleted variables are TITEL_KZ, AGER_TYP, KK_KUNDENTYP, KBA05_BAUMAX, GEBURTSJAHR, ALTER_HH. Step 1.1.3: Assess Missing Data in Each RowNow, you’ll perform a similar assessment for the rows of the dataset. How much data is missing in each row? As with the columns, you should see some groups of points that have a very different numbers of missing values. Divide the data into two subsets: one for data points that are above some threshold for missing values, and a second subset for points below that threshold. In order to know what to do with the outlier rows, we should see if the distribution of data values on columns that are not missing data (or are missing very little data) are similar or different between the two groups. Select at least five of these columns and compare the distribution of values. You can use seaborn’s countplot() function to create a bar chart of code frequencies and matplotlib’s subplot() function to put bar charts for the two subplots side by side. To reduce repeated code, you might want to write a function that can perform this comparison, taking as one of its arguments a column to be compared. Depending on what you observe in your comparison, this will have implications on how you approach your conclusions later in the analysis. If the distributions of non-missing features look similar between the data with many missing values and the data with few or no missing values, then we could argue that simply dropping those points from the analysis won’t present a major issue. On the other hand, if the data with many missing values looks very different from the data with few or no missing values, then we should make a note on those data as special. We’ll revisit these data later on. Either way, you should continue your analysis for now using just the subset of the data with few or no missing values. 12345# How much data is missing in each row of the dataset?row_miss = azdias.isna().sum(axis = 1)sns.countplot(row_miss)plt.xticks(rotation = 90,fontsize=10)plt.show() 1234# Write code to divide the data into two subsets based on the number of missing# values in each row.azdias_no_miss = azdias[azdias.isna().sum(axis = 1) == 0]azdias_with_miss = azdias[azdias.isna().sum(axis = 1) &gt;= 1] 1234# Compare the distribution of values for at least five columns where there are# no missing values, between the two subsets.list(azdias.isna().sum().sort_values().head(20).index) # choose columns with no missing values [&apos;ZABEOTYP&apos;, &apos;SEMIO_REL&apos;, &apos;SEMIO_MAT&apos;, &apos;SEMIO_VERT&apos;, &apos;SEMIO_LUST&apos;, &apos;SEMIO_ERL&apos;, &apos;SEMIO_KULT&apos;, &apos;SEMIO_RAT&apos;, &apos;SEMIO_KRIT&apos;, &apos;SEMIO_DOM&apos;, &apos;SEMIO_KAEM&apos;, &apos;GREEN_AVANTGARDE&apos;, &apos;SEMIO_PFLICHT&apos;, &apos;FINANZTYP&apos;, &apos;FINANZ_HAUSBAUER&apos;, &apos;FINANZ_UNAUFFAELLIGER&apos;, &apos;FINANZ_ANLEGER&apos;, &apos;FINANZ_VORSORGER&apos;, &apos;FINANZ_SPARER&apos;, &apos;FINANZ_MINIMALIST&apos;]12345678# define a functiondef compare_dist(name): plt.figure(figsize=(10,5)) ax = plt.subplot(1,2,1) plt.hist(azdias_no_miss[name],bins = 30) ax2 = plt.subplot(1,2,2) plt.hist(azdias_with_miss[name],bins = 30) plt.show() 12# 'ZABEOTYP'compare_dist('ZABEOTYP') 12# 'SEMIO_LUST'compare_dist('SEMIO_LUST') 12# 'GREEN_AVANTGARDE'compare_dist('GREEN_AVANTGARDE') 12# 'FINANZ_HAUSBAUER'compare_dist('FINANZ_HAUSBAUER') 12# 'SEMIO_RAT'compare_dist('SEMIO_RAT') Discussion 1.1.3: Assess Missing Data in Each RowI divide the dataset in two subsets, one without missing values and the other with missing values. I did this because rows without missing values takes the big amount. The data with missing values is not qualitatively different from the data with no missing values, based on five bar charts above. Step 1.2: Select and Re-Encode FeaturesChecking for missing data isn’t the only way in which you can prepare a dataset for analysis. Since the unsupervised learning techniques to be used will only work on data that is encoded numerically, you need to make a few encoding changes or additional assumptions to be able to make progress. In addition, while almost all of the values in the dataset are encoded using numbers, not all of them represent numeric values. Check the third column of the feature summary (feat_info) for a summary of types of measurement. For numeric and interval data, these features can be kept without changes. Most of the variables in the dataset are ordinal in nature. While ordinal values may technically be non-linear in spacing, make the simplifying assumption that the ordinal variables can be treated as being interval in nature (that is, kept without any changes). Special handling may be necessary for the remaining two variable types: categorical, and ‘mixed’. In the first two parts of this sub-step, you will perform an investigation of the categorical and mixed-type features and make a decision on each of them, whether you will keep, drop, or re-encode each. Then, in the last part, you will create a new data frame with only the selected and engineered columns. Data wrangling is often the trickiest part of the data analysis process, and there’s a lot of it to be done here. But stick with it: once you’re done with this step, you’ll be ready to get to the machine learning parts of the project! 12345678910111213141516# How many features are there of each data type?# azdias_less_miss # use dataset with less missing valuesfor each in remove_names: feat_info = feat_info[feat_info['attribute'] != each] categorical_v = feat_info[feat_info['type'] == 'categorical']ordinal_v = feat_info[feat_info['type'] == 'ordinal']numeric_v = feat_info[feat_info['type'] == 'numeric']mixed_v = feat_info[feat_info['type'] == 'mixed']interval_v = feat_info[feat_info['type'] == 'interval']print(\"Total number of numeric variables: &#123;&#125;\".format(len(numeric_v)))print(\"Total number of interval variables: &#123;&#125;\".format(len(interval_v)))print(\"Total number of ordinal variables: &#123;&#125;\".format(len(ordinal_v)))print(\"Total number of categorical variables: &#123;&#125;\".format(len(categorical_v)))print(\"Total number of mixed variables: &#123;&#125;\".format(len(mixed_v))) Total number of numeric variables: 6 Total number of interval variables: 0 Total number of ordinal variables: 49 Total number of categorical variables: 18 Total number of mixed variables: 6Step 1.2.1: Re-Encode Categorical FeaturesFor categorical data, you would ordinarily need to encode the levels as dummy variables. Depending on the number of categories, perform one of the following: For binary (two-level) categoricals that take numeric values, you can keep them without needing to do anything. There is one binary variable that takes on non-numeric values. For this one, you need to re-encode the values as numbers or create a dummy variable. For multi-level categoricals (three or more values), you can choose to encode the values using multiple dummy variables (e.g. via OneHotEncoder), or (to keep things straightforward) just drop them from the analysis. As always, document your choices in the Discussion section. 123456# Assess categorical variables: which are binary, which are multi-level, and# which one needs to be re-encoded?binary_v = ['ANREDE_KZ', 'GREEN_AVANTGARDE','SOHO_KZ','VERS_TYP','OST_WEST_KZ'] # all binary variables and 'OST_WEST_KZ' should be re-encodedmulti_level_v=categorical_vfor each in binary_v: multi_level_v = multi_level_v[multi_level_v['attribute'] != each] 1234# Re-encode categorical variable(s) to be kept in the analysis.# re-encode the binary variableazdias_no_miss.loc[:, 'OST_WEST_KZ'] = azdias_no_miss.loc[:, 'OST_WEST_KZ'].replace('O',0)azdias_no_miss.loc[:, 'OST_WEST_KZ'] = azdias_no_miss.loc[:, 'OST_WEST_KZ'].replace('W',1) 123# re-encode the multi-level variablesmulti_level_row = azdias_no_miss[multi_level_v['attribute']]multi_level_full = pd.get_dummies(multi_level_row.astype(str)) 123456# Change the original datasetnames = list(multi_level_v['attribute'])azdias_no_miss.drop(names,axis=1,inplace = True)azdias_no_miss = pd.concat([azdias_no_miss, multi_level_full],axis=1 )encoded = list(azdias_no_miss.columns)print(\"&#123;&#125; total features after one-hot encoding.\".format(len(encoded))) 191 total features after one-hot encoding.Discussion 1.2.1: Re-Encode Categorical FeaturesFor binary variable ‘OST_WEST_KZ’ I transform it to numeric values, For multi-level variables I transform all of them into dummy variables. Step 1.2.2: Engineer Mixed-Type FeaturesThere are a handful of features that are marked as “mixed” in the feature summary that require special treatment in order to be included in the analysis. There are two in particular that deserve attention; the handling of the rest are up to your own choices: “PRAEGENDE_JUGENDJAHRE” combines information on three dimensions: generation by decade, movement (mainstream vs. avantgarde), and nation (east vs. west). While there aren’t enough levels to disentangle east from west, you should create two new variables to capture the other two dimensions: an interval-type variable for decade, and a binary variable for movement. “CAMEO_INTL_2015” combines information on two axes: wealth and life stage. Break up the two-digit codes by their ‘tens’-place and ‘ones’-place digits into two new ordinal variables (which, for the purposes of this project, is equivalent to just treating them as their raw numeric values). If you decide to keep or engineer new features around the other mixed-type features, make sure you note your steps in the Discussion section. Be sure to check Data_Dictionary.md for the details needed to finish these tasks. 123456789101112131415161718192021# Investigate \"PRAEGENDE_JUGENDJAHRE\" and engineer two new variables.# movement: 1 for Mainstream, 0 for Avantgardemovement = azdias_no_miss['PRAEGENDE_JUGENDJAHRE'] == 1 | 3 | 5 | 8 | 10 | 12 | 14movement = movement.astype(int)decade = []i = 0temp = azdias_no_miss['PRAEGENDE_JUGENDJAHRE']for each in temp: if each == 1 or each == 2: i = 1 elif each == 3 or each == 4: i = 2 elif each == 5 or each == 6 or each == 7: i = 3 elif each == 8 or each ==9: i = 4 elif each == 10 or each ==11 or each ==12 or each ==13: i = 5 else: i = 6 decade.append(i) 1234# Investigate \"CAMEO_INTL_2015\" and engineer two new variables.wealth = azdias_no_miss['CAMEO_INTL_2015'].astype(int)/10wealth = wealth.astype(int)life_stage = azdias_no_miss['CAMEO_INTL_2015'].astype(int) % 10 123# Drop original columns and add the new columnsnames = list(mixed_v['attribute'])azdias_no_miss.drop(names,axis=1,inplace = True) 1234azdias_no_miss['movement'] = movementazdias_no_miss['decade'] = decadeazdias_no_miss['wealth'] = wealthazdias_no_miss['life_stage'] = life_stage Discussion 1.2.2: Engineer Mixed-Type FeaturesI transformed “PRAEGENDE_JUGENDJAHRE” and “CAMEO_INTL_2015” . For other variables I just dropped them since some are overlapped with existed variables, for example, “LP_LEBENSPHASE_GROB”. Step 1.2.3: Complete Feature SelectionIn order to finish this step up, you need to make sure that your data frame now only has the columns that you want to keep. To summarize, the dataframe should consist of the following: All numeric, interval, and ordinal type columns from the original dataset. Binary categorical features (all numerically-encoded). Engineered features from other multi-level categorical features and mixed features. Make sure that for any new columns that you have engineered, that you’ve excluded the original columns from the final dataset. Otherwise, their values will interfere with the analysis later on the project. For example, you should not keep “PRAEGENDE_JUGENDJAHRE”, since its values won’t be useful for the algorithm: only the values derived from it in the engineered features you created should be retained. As a reminder, your data should only be from the subset with few or no missing values. 12# If there are other re-engineering tasks you need to perform, make sure you# take care of them here. (Dealing with missing data will come in step 2.1.) 12# Do whatever you need to in order to ensure that the dataframe only contains# the columns that should be passed to the algorithm functions. Step 1.3: Create a Cleaning FunctionEven though you’ve finished cleaning up the general population demographics data, it’s important to look ahead to the future and realize that you’ll need to perform the same cleaning steps on the customer demographics data. In this substep, complete the function below to execute the main feature selection, encoding, and re-engineering steps you performed above. Then, when it comes to looking at the customer data in Step 3, you can just run this function on that DataFrame to get the trimmed dataset in a single step. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091def clean_data(df): \"\"\" Perform feature trimming, re-encoding, and engineering for demographics data INPUT: Demographics DataFrame OUTPUT: Trimmed and cleaned demographics DataFrame \"\"\" feat_info = pd.read_csv('AZDIAS_Feature_Summary.csv',sep=';') # Put in code here to execute all main cleaning steps: # convert missing value codes into NaNs, ... # Identify missing or unknown data values and convert them to NaNs. pattern = re.compile(r'\\-\\d+|\\d+') # find all numbers for i in range (len(feat_info)): index = pattern.findall(feat_info['missing_or_unknown'][i]) index = list(map(int, index)) df.iloc[:,i] = df.iloc[:,i].replace(index,np.nan) pattern = re.compile(r'[A-Z]+') # find all XX i = np.arange(57,60) for each in i: index = pattern.findall(feat_info['missing_or_unknown'][each])[0] df.iloc[:,each] = df.iloc[:,each].replace(index,np.nan) # remove selected columns and rows, ... count_nan = df.isna().sum().sort_values(ascending = False) count_nan = count_nan[count_nan != 0] # sort the counts remove_names = ['TITEL_KZ','AGER_TYP','KK_KUNDENTYP','KBA05_BAUMAX','GEBURTSJAHR','ALTER_HH']# save deleted variables df.drop(remove_names,axis=1,inplace=True) azdias_no_miss = df[df.isna().sum(axis = 1) == 0] azdias_with_miss = df[df.isna().sum(axis = 1) &gt;= 1] # select, re-encode, and engineer column values. for each in remove_names: feat_info = feat_info[feat_info['attribute'] != each] categorical_v = feat_info[feat_info['type'] == 'categorical'] ordinal_v = feat_info[feat_info['type'] == 'ordinal'] numeric_v = feat_info[feat_info['type'] == 'numeric'] mixed_v = feat_info[feat_info['type'] == 'mixed'] interval_v = feat_info[feat_info['type'] == 'interval'] binary_v = ['ANREDE_KZ', 'GREEN_AVANTGARDE','SOHO_KZ','VERS_TYP','OST_WEST_KZ'] # all binary variables and 'OST_WEST_KZ' should be re-encoded multi_level_v=categorical_v for each in binary_v: multi_level_v = multi_level_v[multi_level_v['attribute'] != each] azdias_no_miss.loc[:, 'OST_WEST_KZ'] = azdias_no_miss.loc[:, 'OST_WEST_KZ'].replace('O',0) azdias_no_miss.loc[:, 'OST_WEST_KZ'] = azdias_no_miss.loc[:, 'OST_WEST_KZ'].replace('W',1) # re-encode the multi-level variables multi_level_row = azdias_no_miss[multi_level_v['attribute']] multi_level_full = pd.get_dummies(multi_level_row.astype(str)) # Change the original dataset names = list(multi_level_v['attribute']) azdias_no_miss.drop(names,axis=1,inplace = True) azdias_no_miss = pd.concat([azdias_no_miss, multi_level_full],axis=1 ) movement = azdias_no_miss['PRAEGENDE_JUGENDJAHRE'] == 1 | 3 | 5 | 8 | 10 | 12 | 14 movement = movement.astype(int) decade = [] i = 0 temp = azdias_no_miss['PRAEGENDE_JUGENDJAHRE'] for each in temp: if each == 1 or each == 2: i = 1 elif each == 3 or each == 4: i = 2 elif each == 5 or each == 6 or each == 7: i = 3 elif each == 8 or each ==9: i = 4 elif each == 10 or each ==11 or each ==12 or each ==13: i = 5 else: i = 6 decade.append(i) # Investigate \"CAMEO_INTL_2015\" and engineer two new variables. wealth = azdias_no_miss['CAMEO_INTL_2015'].astype(int)/10 wealth = wealth.astype(int) life_stage = azdias_no_miss['CAMEO_INTL_2015'].astype(int) % 10 # Drop original columns and add the new columns names = list(mixed_v['attribute']) azdias_no_miss.drop(names,axis=1,inplace = True) azdias_no_miss['movement'] = movement azdias_no_miss['decade'] = decade azdias_no_miss['wealth'] = wealth azdias_no_miss['life_stage'] = life_stage # Return the cleaned dataframe. return azdias_no_miss Step 2: Feature TransformationStep 2.1: Apply Feature ScalingBefore we apply dimensionality reduction techniques to the data, we need to perform feature scaling so that the principal component vectors are not influenced by the natural differences in scale for features. Starting from this part of the project, you’ll want to keep an eye on the API reference page for sklearn to help you navigate to all of the classes and functions that you’ll need. In this substep, you’ll need to check the following: sklearn requires that data not have missing values in order for its estimators to work properly. So, before applying the scaler to your data, make sure that you’ve cleaned the DataFrame of the remaining missing values. This can be as simple as just removing all data points with missing data, or applying an Imputer to replace all missing values. You might also try a more complicated procedure where you temporarily remove missing values in order to compute the scaling parameters before re-introducing those missing values and applying imputation. Think about how much missing data you have and what possible effects each approach might have on your analysis, and justify your decision in the discussion section below. For the actual scaling function, a StandardScaler instance is suggested, scaling each feature to mean 0 and standard deviation 1. For these classes, you can make use of the .fit_transform() method to both fit a procedure to the data as well as apply the transformation to the data at the same time. Don’t forget to keep the fit sklearn objects handy, since you’ll be applying them to the customer demographics data towards the end of the project. 12# If you've not yet cleaned the dataset of all NaN values, then investigate and# do that now. 1234# Apply feature scaling to the general population demographics data.scaler = StandardScaler()azdias_trans = pd.DataFrame(scaler.fit_transform(azdias_no_miss))azdias_trans.columns = azdias_no_miss.columns Discussion 2.1: Apply Feature ScalingI removed all missing values brfore, and I transformed all features with StandardScaler. Step 2.2: Perform Dimensionality ReductionOn your scaled data, you are now ready to apply dimensionality reduction techniques. Use sklearn’s PCA class to apply principal component analysis on the data, thus finding the vectors of maximal variance in the data. To start, you should not set any parameters (so all components are computed) or set a number of components that is at least half the number of features (so there’s enough features to see the general trend in variability). Check out the ratio of variance explained by each principal component as well as the cumulative variance explained. Try plotting the cumulative or sequential values using matplotlib’s plot() function. Based on what you find, select a value for the number of transformed features you’ll retain for the clustering part of the project. Once you’ve made a choice for the number of components to keep, make sure you re-fit a PCA instance to perform the decided-on transformation. 1234# Apply PCA to the data.from sklearn.decomposition import PCApca = PCA()azdias_pca = pca.fit_transform(azdias_trans) 123# Investigate the variance accounted for by each principal component.var_ratio = pca.explained_variance_ratio_plt.plot(var_ratio) [&lt;matplotlib.lines.Line2D at 0x1f0a9327e08&gt;] 1plt.plot(np.cumsum(var_ratio)) [&lt;matplotlib.lines.Line2D at 0x1f0a8f7dc08&gt;] 123# Re-apply PCA to the data while selecting for number of components to retain.pca = PCA(n_components=100)azdias_pca = pca.fit_transform(azdias_trans) Discussion 2.2: Perform Dimensionality ReductionWith 100 components, over 80% variance can be explained. Thus I choose 100 components. Step 2.3: Interpret Principal ComponentsNow that we have our transformed principal components, it’s a nice idea to check out the weight of each variable on the first few components to see if they can be interpreted in some fashion. As a reminder, each principal component is a unit vector that points in the direction of highest variance (after accounting for the variance captured by earlier principal components). The further a weight is from zero, the more the principal component is in the direction of the corresponding feature. If two features have large weights of the same sign (both positive or both negative), then increases in one tend expect to be associated with increases in the other. To contrast, features with different signs can be expected to show a negative correlation: increases in one variable should result in a decrease in the other. To investigate the features, you should map each weight to their corresponding feature name, then sort the features according to weight. The most interesting features for each principal component, then, will be those at the beginning and end of the sorted list. Use the data dictionary document to help you understand these most prominent features, their relationships, and what a positive or negative value on the principal component might indicate. You should investigate and interpret feature associations from the first three principal components in this substep. To help facilitate this, you should write a function that you can call at any time to print the sorted list of feature weights, for the i-th principal component. This might come in handy in the next step of the project, when you interpret the tendencies of the discovered clusters. 123456# Map weights for the first principal component to corresponding feature names# and then print the linked values, sorted by weight.# HINT: Try defining a function here or in a new cell that you can reuse in the# other cells.feature_select = pd.DataFrame(pca.components_,columns=azdias_trans.columns).Tfeature_select[0].sort_values() MOBI_REGIO -0.202737 FINANZ_MINIMALIST -0.195380 KBA05_ANTG1 -0.190736 PLZ8_ANTG1 -0.180144 KBA05_GBZ -0.179441 ... PLZ8_ANTG4 0.172431 PLZ8_ANTG3 0.178166 HH_EINKOMMEN_SCORE 0.178693 wealth 0.180169 LP_STATUS_GROB_1.0 0.192540 Name: 0, Length: 189, dtype: float641234# Map weights for the second principal component to corresponding feature names# and then print the linked values, sorted by weight.feature_select[1].sort_values() decade -0.228497 SEMIO_REL -0.213832 FINANZ_SPARER -0.212535 FINANZ_UNAUFFAELLIGER -0.207468 SEMIO_PFLICHT -0.205000 ... RETOURTYP_BK_S 0.156204 SEMIO_ERL 0.181138 ZABEOTYP_3 0.197800 FINANZ_VORSORGER 0.205081 ALTERSKATEGORIE_GROB 0.225616 Name: 1, Length: 189, dtype: float64123# Map weights for the third principal component to corresponding feature names# and then print the linked values, sorted by weight.feature_select[2].sort_values() ANREDE_KZ -0.346752 SEMIO_KAEM -0.319185 SEMIO_DOM -0.286983 SEMIO_KRIT -0.262582 SEMIO_ERL -0.199994 ... FINANZTYP_5 0.135987 SEMIO_KULT 0.246536 SEMIO_SOZ 0.257146 SEMIO_FAM 0.260536 SEMIO_VERT 0.324047 Name: 2, Length: 189, dtype: float64Discussion 2.3: Interpret Principal ComponentsComponent 1: Movement patterns and social status are negatively correlated, which means higher movement higher income. Also wealth and social status are positively correlated. Therefore, the first component is correalted with people’s wealth. Component 2: Estimated age based on given name analysis is negatively correlated with variable decade, since they are negatively correlated by nature. Thus this one is correlated with ages. Component 3: People who is not likely to be dreamful is more likely to be a male. This Component is related to the gender. Step 3: ClusteringStep 3.1: Apply Clustering to General PopulationYou’ve assessed and cleaned the demographics data, then scaled and transformed them. Now, it’s time to see how the data clusters in the principal components space. In this substep, you will apply k-means clustering to the dataset and use the average within-cluster distances from each point to their assigned cluster’s centroid to decide on a number of clusters to keep. Use sklearn’s KMeans class to perform k-means clustering on the PCA-transformed data. Then, compute the average difference from each point to its assigned cluster’s center. Hint: The KMeans object’s .score() method might be useful here, but note that in sklearn, scores tend to be defined so that larger is better. Try applying it to a small, toy dataset, or use an internet search to help your understanding. Perform the above two steps for a number of different cluster counts. You can then see how the average distance decreases with an increasing number of clusters. However, each additional cluster provides a smaller net benefit. Use this fact to select a final number of clusters in which to group the data. Warning: because of the large size of the dataset, it can take a long time for the algorithm to resolve. The more clusters to fit, the longer the algorithm will take. You should test for cluster counts through at least 10 clusters to get the full picture, but you shouldn’t need to test for a number of clusters above about 30. Once you’ve selected a final number of clusters to use, re-fit a KMeans instance to perform the clustering operation. Make sure that you also obtain the cluster assignments for the general demographics data, since you’ll be using them in the final Step 3.3. 12345678# Function to calculate K-Means score for a centroiddef get_kmeans_score(data, center): kmeans = KMeans(n_clusters = center, random_state=2020) model = kmeans.fit(data) score = np.abs(model.score(data)) return score 123456score = []centroids = [2,5,10,11,12,13,14,16,20,23,25]for each in centroids: score.append(get_kmeans_score(azdias_pca,each)) print('Finished for:',each) Finished for: 2 Finished for: 5 Finished for: 10 Finished for: 11 Finished for: 12 Finished for: 13 Finished for: 14 Finished for: 16 Finished for: 20 Finished for: 23 Finished for: 251234# Investigate the change in within-cluster distance across number of clusters.# HINT: Use matplotlib's plot function to visualize this relationship.plt.plot(centroids,score,color='blue') [&lt;matplotlib.lines.Line2D at 0x1f0a955a4c8&gt;] 1234# Re-fit the k-means model with the selected number of clusters and obtain# cluster predictions for the general population demographics data.kmeans = KMeans(n_clusters = 11, random_state=2020)result = kmeans.fit_predict(azdias_pca) Discussion 3.1: Apply Clustering to General PopulationThe first elbow occurs at ‘n_clusters = 5’, the second elbow occurs at 11, therefore I choose 11 centroids. Step 3.2: Apply All Steps to the Customer DataNow that you have clusters and cluster centers for the general population, it’s time to see how the customer data maps on to those clusters. Take care to not confuse this for re-fitting all of the models to the customer data. Instead, you’re going to use the fits from the general population to clean, transform, and cluster the customer data. In the last step of the project, you will interpret how the general population fits apply to the customer data. Don’t forget when loading in the customers data, that it is semicolon (;) delimited. Apply the same feature wrangling, selection, and engineering steps to the customer demographics using the clean_data() function you created earlier. (You can assume that the customer demographics data has similar meaning behind missing data patterns as the general demographics data.) Use the sklearn objects from the general demographics data, and apply their transformations to the customers data. That is, you should not be using a .fit() or .fit_transform() method to re-fit the old objects, nor should you be creating new sklearn objects! Carry the data through the feature scaling, PCA, and clustering steps, obtaining cluster assignments for all of the data in the customer demographics data. 12# Load in the customer demographics data.customers = pd.read_csv('Udacity_CUSTOMERS_Subset.csv',sep=';') 1234# Apply preprocessing, feature transformation, and clustering from the general# demographics onto the customer data, obtaining cluster predictions for the# customer demographics data.customers.shape (191652, 85)1customers_clean = clean_data(customers) 1customers_clean.shape (115643, 188)1234# feature transformationscaler = StandardScaler()customers_clean_trans = pd.DataFrame(scaler.fit_transform(customers_clean))customers_clean_trans.columns = customers_clean.columns 123# pcapca = PCA(n_components=100)customers_pca = pca.fit_transform(customers_clean_trans) 123# cluster predictions for the customer data.kmeans = KMeans(n_clusters = 11, random_state=2020)result_customer = kmeans.fit_predict(customers_pca) Step 3.3: Compare Customer Data to Demographics DataAt this point, you have clustered data based on demographics of the general population of Germany, and seen how the customer data for a mail-order sales company maps onto those demographic clusters. In this final substep, you will compare the two cluster distributions to see where the strongest customer base for the company is. Consider the proportion of persons in each cluster for the general population, and the proportions for the customers. If we think the company’s customer base to be universal, then the cluster assignment proportions should be fairly similar between the two. If there are only particular segments of the population that are interested in the company’s products, then we should see a mismatch from one to the other. If there is a higher proportion of persons in a cluster for the customer data compared to the general population (e.g. 5% of persons are assigned to a cluster for the general population, but 15% of the customer data is closest to that cluster’s centroid) then that suggests the people in that cluster to be a target audience for the company. On the other hand, the proportion of the data in a cluster being larger in the general population than the customer data (e.g. only 2% of customers closest to a population centroid that captures 6% of the data) suggests that group of persons to be outside of the target demographics. Take a look at the following points in this step: Compute the proportion of data points in each cluster for the general population and the customer data. Visualizations will be useful here: both for the individual dataset proportions, but also to visualize the ratios in cluster representation between groups. Seaborn’s countplot() or barplot() function could be handy. Recall the analysis you performed in step 1.1.3 of the project, where you separated out certain data points from the dataset if they had more than a specified threshold of missing values. If you found that this group was qualitatively different from the main bulk of the data, you should treat this as an additional data cluster in this analysis. Make sure that you account for the number of data points in this subset, for both the general population and customer datasets, when making your computations! Which cluster or clusters are overrepresented in the customer dataset compared to the general population? Select at least one such cluster and infer what kind of people might be represented by that cluster. Use the principal component interpretations from step 2.3 or look at additional components to help you make this inference. Alternatively, you can use the .inverse_transform() method of the PCA and StandardScaler objects to transform centroids back to the original data space and interpret the retrieved values directly. Perform a similar investigation for the underrepresented clusters. Which cluster or clusters are underrepresented in the customer dataset compared to the general population, and what kinds of people are typified by these clusters? 123456789# Compare the proportion of data in each cluster for the customer data to the# proportion of data in each cluster for the general population.result_customer = pd.Series(result_customer)customer_dist = result_customer.value_counts().sort_index()result = pd.Series(result)population_dist = result.value_counts().sort_index()final_df = pd.DataFrame([population_dist,customer_dist]).Tfinal_df.columns = ['population_count','customer_count']final_df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } population_count customer_count 0 90763 4965 1 22018 7866 2 42219 19958 3 89706 12487 4 87209 3989 5 53588 8490 6 54843 13308 7 77417 14154 8 69022 2203 9 28866 10496 10 7558 17727 12345678fig = plt.figure(figsize=(12,4))ax1 = fig.add_subplot(1,2,1)sns.barplot(x=final_df.index,y='population_count', data = final_df)plt.title(\"Distribution of General Population\")ax2 = fig.add_subplot(1,2,2)sns.barplot(x=final_df.index,y='customer_count', data = final_df)plt.title(\"Distribution of Customer data\")plt.show() 123456temp_po = final_df['population_count']/final_df['population_count'].sum()temp2_cu = final_df['customer_count']/final_df['customer_count'].sum()final_df_percent = pd.DataFrame([temp_po,temp2_cu]).Tfinal_df_percent.columns = ['population_percent','customer_percent']diff = final_df_percent['population_percent']-final_df_percent['customer_percent']diff.sort_values() 10 -0.141163 2 -0.104838 9 -0.044444 1 -0.032690 6 -0.027077 7 0.001829 5 0.012572 3 0.035963 8 0.091703 0 0.102704 4 0.105441 dtype: float64123456# What kinds of people are part of a cluster that is overrepresented in the# customer data compared to the general population? Category 10cc10 = kmeans.cluster_centers_[10]cc10 = pd.Series(cc10)cc10.sort_values(ascending=False, inplace=True)cc10.head() 2 1.776055 4 1.090018 3 0.780223 10 0.501790 6 0.247969 dtype: float641feature_select[2].sort_values() ANREDE_KZ -0.346752 SEMIO_KAEM -0.319185 SEMIO_DOM -0.286983 SEMIO_KRIT -0.262582 SEMIO_ERL -0.199994 ... FINANZTYP_5 0.135987 SEMIO_KULT 0.246536 SEMIO_SOZ 0.257146 SEMIO_FAM 0.260536 SEMIO_VERT 0.324047 Name: 2, Length: 189, dtype: float641feature_select[4].sort_values() LP_FAMILIE_FEIN_1.0 -0.327135 LP_FAMILIE_GROB_1.0 -0.327135 W_KEIT_KIND_HH -0.220503 GREEN_AVANTGARDE -0.140996 LP_STATUS_GROB_2.0 -0.136988 ... REGIOTYP 0.155014 LP_FAMILIE_FEIN_10.0 0.192443 KKK 0.204874 LP_FAMILIE_GROB_5.0 0.253148 ANZ_PERSONEN 0.285127 Name: 4, Length: 189, dtype: float64123456# What kinds of people are part of a cluster that is underrepresented in the# customer data compared to the general population? Category 4cc4 = kmeans.cluster_centers_[4]cc4 = pd.Series(cc4)cc4.sort_values(ascending=False, inplace=True)cc4.head() 1 6.917713 6 3.135301 3 1.403937 8 1.179948 22 1.159860 dtype: float641feature_select[1].sort_values() decade -0.228497 SEMIO_REL -0.213832 FINANZ_SPARER -0.212535 FINANZ_UNAUFFAELLIGER -0.207468 SEMIO_PFLICHT -0.205000 ... RETOURTYP_BK_S 0.156204 SEMIO_ERL 0.181138 ZABEOTYP_3 0.197800 FINANZ_VORSORGER 0.205081 ALTERSKATEGORIE_GROB 0.225616 Name: 1, Length: 189, dtype: float641feature_select[6].sort_values() GEBAEUDETYP_1.0 -0.236870 GEBAEUDETYP_RASTER -0.209850 LP_STATUS_GROB_2.0 -0.195907 CAMEO_DEUG_2015_6 -0.169896 KBA05_ANTG3 -0.151434 ... KBA05_ANTG4 0.139343 LP_STATUS_GROB_4.0 0.145008 LP_STATUS_FEIN_6.0 0.264746 GEBAEUDETYP_3.0 0.290512 LP_STATUS_GROB_3.0 0.295362 Name: 6, Length: 189, dtype: float64Discussion 3.3: Compare Customer Data to Demographics DataOverrepresented: The category 10, which represents females who are dreamful and might be single parent with child of full age.Underrepresented: The category 4, which represents elderly independent workers with age greater than 60, financial typology is ‘be prepared’. Congratulations on making it this far in the project! Before you finish, make sure to check through the entire notebook from top to bottom to make sure that your analysis follows a logical flow and all of your findings are documented in Discussion cells. Once you’ve checked over all of your work, you should export the notebook as an HTML document to submit for evaluation. You can do this from the menu, navigating to File -&gt; Download as -&gt; HTML (.html). You will submit both that document and this notebook for your project submission. 12","comments":true,"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"无监督学习","slug":"无监督学习","permalink":"http://yoursite.com/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hexo 如何优雅的加入Rmarkdown生成的html/pdf文件","date":"2020-01-25T21:13:35.000Z","path":"2020/01/25/Hexo 如何优雅的加入Rmarkdown生成的html文件/","text":"如何加入自己创建的html文件,以及如何忽略在_source文件夹中的.md 或者 .html文件。 在加入Rmarkdown生成的html的时候我发现自身的排版非常难看,也不会自动在博客生成标签和分类,那么有一个解决办法就是插入html文件在博客里。插入的方法是在markdown中使用iframe: 1&lt;iframe src&#x3D;&quot;filename.html&quot; width&#x3D;&quot;700&quot; height&#x3D;&quot;800&quot;&gt;&lt;&#x2F;iframe&gt; 同样和插入图片方式大同小异我们创建一个和md文件一模一样名字的文件夹,把要插入的html文件放入其中就行,不需要绝对路径。 但是这时候就有一个问题,hexo会自动扫描所有_source文件夹中的文件,那么html文件就会被扫描到从而被渲染后上传到博客里,我们不希望有重复的内容,那么应该如何让hexo跳过扫描呢? 网上有几种方法,一种是在html文件的开头加上 123--- layout: false --- 但是测试后发现并没有什么用。于是测试第二种方法,在站点配置文件下: 1skip_render: &quot;filename.html&quot; 同样测试发现行不通,查阅官方文档后发现可能因为版本问题路径不对,应该为: 1skip_render: &quot;_posts&#x2F;文件夹名&#x2F;文件名.html&quot;&quot; 从_posts开始,如此一来就可以忽略这个文件渲染了,当然还可以忽略其他文件,也可以利用正则表达式来忽略某类命名的文件,目前还用不到。 希望大家少走弯路! 最后附上一个插入pdf的方法: 1&#123;% pdf .&#x2F;filename.pdf %&#125; 同样把文件放在md同名文件夹下就行了。 目录: 用GitHub搭建个人博客(目录)","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"银行客户画像分析2-机器学习 with Python","date":"2020-01-25T19:13:35.000Z","path":"2020/01/25/bank_user_profile2/","text":"分析银行客户画像并预测是否会在该银行存款,本篇基于上一篇,使用Python进行模型建立,模型选择,参数优化,特征选择等。 12345678# Import libraries necessary for this projectimport numpy as npimport pandas as pdfrom time import timefrom IPython.display import display # Allows the use of display() for DataFrames# Import train_test_splitfrom sklearn.model_selection import train_test_split%matplotlib inline 12data = pd.read_csv(\"processed_data1.csv\")target = data['target'] 1data = data.drop('Unnamed: 0', axis = 1) 1features = data.drop('target', axis = 1) 分训练集和测试集123456789# Split the 'features' and 'income' data into training and testing setsX_train, X_test, y_train, y_test = train_test_split(features, target, test_size = 0.2, random_state = 0)# Show the results of the splitprint(\"Training set has &#123;&#125; samples.\".format(X_train.shape[0]))print(\"Testing set has &#123;&#125; samples.\".format(X_test.shape[0])) Training set has 32950 samples. Testing set has 8238 samples.建立模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from sklearn.metrics import fbeta_scorefrom sklearn.metrics import accuracy_scoredef train_predict(learner, sample_size, X_train, y_train, X_test, y_test): ''' inputs: - learner: the learning algorithm to be trained and predicted on - sample_size: the size of samples (number) to be drawn from training set - X_train: features training set - y_train: income training set - X_test: features testing set - y_test: income testing set ''' results = &#123;&#125; # Fit the learner to the training data using slicing with 'sample_size' using .fit(training_features[:], training_labels[:]) start = time() # Get start time learner = learner.fit(X_train[:sample_size:], y_train[:sample_size].values.ravel()) end = time() # Get end time # Calculate the training time results['train_time'] = end - start # Get the predictions on the test set(X_test), # then get predictions on the first 300 training samples(X_train) using .predict() start = time() # Get start time predictions_test = learner.predict(X_test) predictions_train = learner.predict(X_train[:300]) end = time() # Get end time # Calculate the total prediction time results['pred_time'] = end - start # Compute accuracy on the first 300 training samples which is y_train[:300] results['acc_train'] = accuracy_score(y_train[:300], predictions_train) # Compute accuracy on test set using accuracy_score() results['acc_test'] = accuracy_score(y_test, predictions_test) # Compute F-score on the the first 300 training samples using fbeta_score() results['f_train'] = fbeta_score(y_train[:300], predictions_train, beta = 0.5) # Compute F-score on the test set which is y_test results['f_test'] = fbeta_score(y_test, predictions_test, beta = 0.5) # Success print(\"&#123;&#125; trained on &#123;&#125; samples.\".format(learner.__class__.__name__, sample_size)) # Return the results return results 训练模型123456789101112131415161718192021222324# Import the three supervised learning models from sklearnfrom sklearn.linear_model import LogisticRegressionfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.neighbors import KNeighborsClassifier import randomrandom.seed(2020)# Initialize the three modelsclf_A = LogisticRegression(solver = 'liblinear') # set the default value manually in order to get rid of warningsclf_B = RandomForestClassifier(n_estimators = 100) # set the default value manually in order to get rid of warningsclf_C = KNeighborsClassifier() # set the default value manually in order to get rid of warnings# Calculate the number of samples for 1%, 10%, and 100% of the training datasamples_100 = len(y_train)samples_10 = int(len(y_train)*0.1)samples_1 = int(len(y_train)*0.01)# Collect results on the learnersresults = &#123;&#125;for clf in [clf_A, clf_B, clf_C]: clf_name = clf.__class__.__name__ results[clf_name] = &#123;&#125; for i, samples in enumerate([samples_1, samples_10, samples_100]): results[clf_name][i] = \\ train_predict(clf, samples, X_train, y_train, X_test, y_test) LogisticRegression trained on 329 samples. LogisticRegression trained on 3295 samples. LogisticRegression trained on 32950 samples. RandomForestClassifier trained on 329 samples. RandomForestClassifier trained on 3295 samples. RandomForestClassifier trained on 32950 samples. KNeighborsClassifier trained on 329 samples. KNeighborsClassifier trained on 3295 samples. KNeighborsClassifier trained on 32950 samples.1results {&apos;LogisticRegression&apos;: {0: {&apos;train_time&apos;: 0.0019948482513427734, &apos;pred_time&apos;: 0.004987239837646484, &apos;acc_train&apos;: 0.8866666666666667, &apos;acc_test&apos;: 0.8869871327992231, &apos;f_train&apos;: 0.6201550387596898, &apos;f_test&apos;: 0.39245863793766833}, 1: {&apos;train_time&apos;: 0.01795196533203125, &apos;pred_time&apos;: 0.003989219665527344, &apos;acc_train&apos;: 0.86, &apos;acc_test&apos;: 0.8990046127700898, &apos;f_train&apos;: 0.4744525547445255, &apos;f_test&apos;: 0.4798698657991053}, 2: {&apos;train_time&apos;: 0.3007650375366211, &apos;pred_time&apos;: 0.003989219665527344, &apos;acc_train&apos;: 0.8533333333333334, &apos;acc_test&apos;: 0.8980335032774945, &apos;f_train&apos;: 0.42635658914728686, &apos;f_test&apos;: 0.45267489711934156}}, &apos;RandomForestClassifier&apos;: {0: {&apos;train_time&apos;: 0.0638282299041748, &apos;pred_time&apos;: 0.0827479362487793, &apos;acc_train&apos;: 1.0, &apos;acc_test&apos;: 0.8874726875455208, &apos;f_train&apos;: 1.0, &apos;f_test&apos;: 0.35665914221218964}, 1: {&apos;train_time&apos;: 0.2373659610748291, &apos;pred_time&apos;: 0.10571742057800293, &apos;acc_train&apos;: 0.9966666666666667, &apos;acc_test&apos;: 0.8958485069191552, &apos;f_train&apos;: 0.9954751131221717, &apos;f_test&apos;: 0.4736275565123789}, 2: {&apos;train_time&apos;: 2.7166779041290283, &apos;pred_time&apos;: 0.16755199432373047, &apos;acc_train&apos;: 0.99, &apos;acc_test&apos;: 0.896091284292304, &apos;f_train&apos;: 0.9859154929577465, &apos;f_test&apos;: 0.47669868374244045}}, &apos;KNeighborsClassifier&apos;: {0: {&apos;train_time&apos;: 0.0019948482513427734, &apos;pred_time&apos;: 0.3361320495605469, &apos;acc_train&apos;: 0.8833333333333333, &apos;acc_test&apos;: 0.888443797038116, &apos;f_train&apos;: 0.5982905982905984, &apos;f_test&apos;: 0.3638017280582083}, 1: {&apos;train_time&apos;: 0.007975578308105469, &apos;pred_time&apos;: 1.4731249809265137, &apos;acc_train&apos;: 0.88, &apos;acc_test&apos;: 0.8903860160233066, &apos;f_train&apos;: 0.5813953488372093, &apos;f_test&apos;: 0.430752453653217}, 2: {&apos;train_time&apos;: 0.4777207374572754, &apos;pred_time&apos;: 6.75963830947876, &apos;acc_train&apos;: 0.8633333333333333, &apos;acc_test&apos;: 0.8956057295460063, &apos;f_train&apos;: 0.5202312138728323, &apos;f_test&apos;: 0.47895997263085877}}}最好的是KNN,在训练所有训练集后,准确率达到89.6%,但是$F_{0.5}$ score 只有0.48,意味着在预测非存款对象的准确度远高于预测存款对象的准确度,这不利于我们找出潜在的存款对象,我们继续利用网格搜索来优化我们的参数和模型。 其他数据集123456789101112131415161718i = ['2','3','4','5']accuracy_all = []f_all = []for each in i: data = pd.read_csv(\"processed_data\"+ each +\".csv\") target = data['target'] data = data.drop('Unnamed: 0', axis = 1) features = data.drop('target', axis = 1) X_train, X_test, y_train, y_test = train_test_split(features, target, test_size = 0.2, random_state = 0) clf_C = KNeighborsClassifier() learner = clf_C.fit(X_train, y_train.values.ravel()) predictions_test = learner.predict(X_test) accuracy_all.append(accuracy_score(y_test, predictions_test)) f_all.append(fbeta_score(y_test, predictions_test, beta = 0.5)) 12print(accuracy_all)print(f_all) [0.895241563486283, 0.8958485069191552, 0.8969410050983249, 0.8958485069191552] [0.4761904761904762, 0.481064483111566, 0.48780487804878053, 0.47987616099071206]准确性和$F_{0.5}$ score 在不同数据集差不多,说明cart来填补缺失值的方法有一致性。 网格搜索12345678910111213141516171819202122232425262728293031323334from sklearn.model_selection import GridSearchCVfrom sklearn.metrics import make_scorerrandom.seed(42)# Initialize the classifierclf = KNeighborsClassifier()# Create the parameters list you wish to tune, using a dictionary if needed.k_range = list(range(1,10))parameters = &#123; 'algorithm' : ['auto','ball_tree','kd_tree','brute'], 'weights' : ['uniform','distance'], 'n_neighbors' : k_range&#125;# Make an fbeta_score scoring object using make_scorer()scorer = make_scorer(fbeta_score, beta = 0.5)# Perform grid search on the classifier using 'scorer' as the scoring method using GridSearchCV()grid_obj = GridSearchCV(clf, parameters, scoring=scorer, cv = 10)# Fit the grid search object to the training data and find the optimal parameters using fit()grid_fit = grid_obj.fit(X_train, y_train.values.ravel())# Get the estimatorbest_clf = grid_fit.best_estimator_# Make predictions using the unoptimized and modelpredictions = (clf.fit(X_train, y_train.values.ravel())).predict(X_test)best_predictions = best_clf.predict(X_test)# Report the before-and-afterscoresprint(\"Unoptimized model\\n------\")print(\"Accuracy score on testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, predictions)))print(\"F-score on testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, predictions, beta = 0.5)))print(\"\\nOptimized Model\\n------\")print(\"Final accuracy score on the testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, best_predictions)))print(\"Final F-score on the testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, best_predictions, beta = 0.5)))print('best params are:',str(grid_obj.best_params_)) Unoptimized model ------ Accuracy score on testing data: 0.8958 F-score on testing data: 0.4799 Optimized Model ------ Final accuracy score on the testing data: 0.8989 Final F-score on the testing data: 0.4920 best params are: {&apos;algorithm&apos;: &apos;brute&apos;, &apos;n_neighbors&apos;: 9, &apos;weights&apos;: &apos;uniform&apos;}Cutoff value1234data = pd.read_csv(\"processed_data5.csv\")target = data['target']data = data.drop('Unnamed: 0', axis = 1)features = data.drop('target', axis = 1) 1234567891011121314# accurate and f score in test set with cutoff = 0.5random.seed(42)X_train, X_test, y_train, y_test = train_test_split(features, target, test_size = 0.1, random_state = 0)X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.1, random_state=0)clf_C = KNeighborsClassifier(algorithm = 'brute',n_neighbors = 9, weights = 'uniform')learner = clf_C.fit(X_train, y_train.values.ravel())predictions_test = learner.predict(X_test)print(accuracy_score(y_test, predictions_test))print(fbeta_score(y_test, predictions_test, beta = 0.5)) 0.8990046127700898 0.48920863309352521234from sklearn.metrics import confusion_matrixfrom sklearn.metrics import precision_scorefrom sklearn.metrics import recall_scoreconfusion_matrix(y_test, predictions_test) # 默认cutoff为p = 0.5 array([[3567, 98], [ 318, 136]], dtype=int64)123456predictions_test_p = learner.predict_proba(X_test)predictions_test_p=pd.DataFrame(predictions_test_p)[1]# 我们看到选取0.3 cutoff 真的1的预测数明显上升predictions_test_pfinal = predictions_test_p&gt;=0.3predictions_test_pfinal=predictions_test_pfinal.astype(int)confusion_matrix(y_test, predictions_test_pfinal) array([[3377, 288], [ 230, 224]], dtype=int64)12345678910111213# 找到最佳cutoffi = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1]accuracy_s = []f_s = []precision_s = []recall_s=[]for each in i: predictions_test_pfinal = predictions_test_p&gt;=each predictions_test_pfinal=predictions_test_pfinal.astype(int) f_s.append(fbeta_score(y_test, predictions_test_pfinal, beta = 1)) accuracy_s.append(accuracy_score(y_test, predictions_test_pfinal)) precision_s.append(precision_score(y_test, predictions_test_pfinal)) recall_s.append(recall_score(y_test, predictions_test_pfinal)) 123456789import matplotlib.pyplot as pltplt.plot(i,precision_s, color='green', label='precision')plt.plot(i,recall_s, color='red', label='recall')plt.plot(i,accuracy_s, color='blue', label='accuracy')plt.plot(i,f_s,color='black',label='F1 score')plt.legend()plt.xlabel('cutoff value')plt.ylabel('rate')plt.show() 根据图表我们可以看出在 cutoff value大致在0.33左右我们大致得到一个比较均衡的预测结果,如果我们要提高precision,也就是保证精准的找到愿意存款的人,那么我们可以选择较高的cutoff value来保持精准定位,但同时也会放弃更多的潜在的客户(节约成本),如果我们要提高recall,也就是希望覆盖更多的潜在客户,那么就要选择较低的cutoff value,这样成本会上升。 最后我们在验证集中验证我们的结论,我们先选择p=0.18 123456789# validation setpredictions_val_p = learner.predict_proba(X_val)predictions_val_p=pd.DataFrame(predictions_val_p)[1]predictions_val_pfinal = predictions_val_p&gt;=0.18predictions_val_pfinal=predictions_val_pfinal.astype(int)print(confusion_matrix(y_val, predictions_val_pfinal))print(recall_score(y_val, predictions_val_pfinal))print(precision_score(y_val, predictions_val_pfinal)) [[2724 542] [ 173 268]] 0.6077097505668935 0.3308641975308642可以发现在总共441位潜在客户里我们预测到了268位,达到了60.7%。但是我们预测的810位顾客里只有268位是正确的,精准度为33%。当然不使用模型的精准度为11.9%。 12345678# validation setpredictions_val_p = learner.predict_proba(X_val)predictions_val_p=pd.DataFrame(predictions_val_p)[1]predictions_val_pfinal = predictions_val_p&gt;=0.8predictions_val_pfinal=predictions_val_pfinal.astype(int)print(confusion_matrix(y_val, predictions_val_pfinal))print(recall_score(y_val, predictions_val_pfinal))print(precision_score(y_val, predictions_val_pfinal)) [[3257 9] [ 419 22]] 0.049886621315192746 0.7096774193548387可以发现调高cutoff value后,我们的预测变得更加谨慎,在预测的31位潜在客户里有22位是真的潜在客户,达到了71%的正确率。但是覆盖面不够广,损失了大多数的潜在客户。 Feature Selection123456789101112131415# Import a supervised learning model that has 'feature_importances_'from sklearn.model_selection import RandomizedSearchCV# Train the supervised model on the training set using .fit(X_train, y_train)param_dist = &#123;\"max_depth\": [3, None], \"n_estimators\": list(range(10, 200)), \"max_features\": list(range(1, X_test.shape[1]+1)), \"min_samples_split\": list(range(2, 11)), \"min_samples_leaf\": list(range(1, 11)), \"bootstrap\": [True, False], \"criterion\": [\"gini\", \"entropy\"]&#125;model = RandomizedSearchCV(clf_B, param_distributions=param_dist)model.fit(X_train, y_train.values.ravel())# TODO: Extract the feature importances using .feature_importances_ importances = model.best_estimator_.feature_importances_ C:\\Users\\jasonguo\\Anaconda3\\lib\\site-packages\\sklearn\\model_selection\\_split.py:1978: FutureWarning: The default value of cv will change from 3 to 5 in version 0.22. Specify it explicitly to silence this warning. warnings.warn(CV_WARNING, FutureWarning)123456789101112131415161718192021222324# Plotimport matplotlib.pyplot as pldef feature_plot(importances, X_train, y_train): # Display the five most important features indices = np.argsort(importances)[::-1] columns = X_train.columns.values[indices[:5]] values = importances[indices][:5] # Creat the plot fig = pl.figure(figsize = (9,5)) pl.title(\"Normalized Weights for First Five Most Predictive Features\", fontsize = 16) pl.bar(np.arange(5), values, width = 0.6, align=\"center\", color = '#00A000', \\ label = \"Feature Weight\") pl.bar(np.arange(5) - 0.3, np.cumsum(values), width = 0.2, align = \"center\", color = '#00A0A0', \\ label = \"Cumulative Feature Weight\") pl.xticks(np.arange(5), columns) pl.xlim((-0.5, 4.5)) pl.ylabel(\"Weight\", fontsize = 12) pl.xlabel(\"Feature\", fontsize = 12) pl.legend(loc = 'upper center') pl.tight_layout() pl.show() 1feature_plot(importances, X_train, y_train) 可以看到前五个重要的指标,第一个是雇佣员工数,第二个是欧洲银行间利率,第三个是年龄,第四个和第五个都是受访相关参数。私以为,机器学习和计量经济学的方法不同之处在于机器学习更加注重预测结果的准确性,而忽视了预测结果和参数直接的因果关系,这些因果关系是很难通过机器学习的一些方法被解释的,即使预测结果非常准确,但是一些参数可能和预测目标没有实际的相关性。接下来就使用计量经济学的方法来研究哪些因素可能导致用户存款。 12345678910111213141516171819from sklearn.base import clone# Reduce the feature spaceX_train_reduced = X_train[X_train.columns.values[(np.argsort(importances)[::-1])[:5]]]X_test_reduced = X_test[X_test.columns.values[(np.argsort(importances)[::-1])[:5]]]# Train on the \"best\" model found from grid search earlierclf = (clone(best_clf)).fit(X_train_reduced, y_train)# Make new predictionsreduced_predictions = clf.predict(X_test_reduced)# Report scores from the final model using both versions of dataprint(\"Final Model trained on full data\\n------\")print(\"Accuracy on testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, best_predictions)))print(\"F-score on testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, best_predictions, beta = 0.5)))print(\"\\nFinal Model trained on reduced data\\n------\")print(\"Accuracy on testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, reduced_predictions)))print(\"F-score on testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, reduced_predictions, beta = 0.5))) Final Model trained on full data ------ Accuracy on testing data: 0.8989 F-score on testing data: 0.4920 Final Model trained on reduced data ------ Accuracy on testing data: 0.8934 F-score on testing data: 0.4420可以发现只取排名前五个参数的模型,F score 下降了一些, 意味着预测有存款意向的人的准确度变低了一些,但不是很多。 12","comments":true,"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"银行客户画像分析1-数据预处理 with R","date":"2020-01-24T16:13:35.000Z","path":"2020/01/24/bank_user_profile/","text":"分析银行客户画像并预测是否会在该银行存款,本篇使用R语言进行数据预处理,使用CART方法填补缺失值,数据标准化以及one-hot encoding。","comments":true,"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"监督学习-寻找潜在的捐款者","date":"2020-01-22T15:53:35.000Z","path":"2020/01/22/寻找潜在的捐款者/","text":"Supervised LearningProject: Finding Donors for CharityMLIn this project, you will employ several supervised algorithms of your choice to accurately model individuals’ income using data collected from the 1994 U.S. Census. You will then choose the best candidate algorithm from preliminary results and further optimize this algorithm to best model the data. Your goal with this implementation is to construct a model that accurately predicts whether an individual makes more than $50,000. This sort of task can arise in a non-profit setting, where organizations survive on donations. Understanding an individual’s income can help a non-profit better understand how large of a donation to request, or whether or not they should reach out to begin with. While it can be difficult to determine an individual’s general income bracket directly from public sources, we can (as we will see) infer this value from other publically available features. The dataset for this project originates from the UCI Machine Learning Repository. The datset was donated by Ron Kohavi and Barry Becker, after being published in the article “Scaling Up the Accuracy of Naive-Bayes Classifiers: A Decision-Tree Hybrid”. You can find the article by Ron Kohavi online. The data we investigate here consists of small changes to the original dataset, such as removing the &#39;fnlwgt&#39; feature and records with missing or ill-formatted entries. Exploring the DataRun the code cell below to load necessary Python libraries and load the census data. Note that the last column from this dataset, &#39;income&#39;, will be our target label (whether an individual makes more than, or at most, $50,000 annually). All other columns are features about each individual in the census database. 1234567891011121314151617# Import libraries necessary for this projectimport numpy as npimport pandas as pdfrom time import timefrom IPython.display import display # Allows the use of display() for DataFrames# Import supplementary visualization code visuals.pyimport visuals as vs# Pretty display for notebooks%matplotlib inline# Load the Census datasetdata = pd.read_csv(\"census.csv\")# Success - Display the first recorddisplay(data.head(n=1)) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age workclass education_level education-num marital-status occupation relationship race sex capital-gain capital-loss hours-per-week native-country income 0 39 State-gov Bachelors 13.0 Never-married Adm-clerical Not-in-family White Male 2174.0 0.0 40.0 United-States &lt;=50K Implementation: Data ExplorationA cursory investigation of the dataset will determine how many individuals fit into either group, and will tell us about the percentage of these individuals making more than $50,000. In the code cell below, you will need to compute the following: The total number of records, &#39;n_records&#39; The number of individuals making more than $50,000 annually, &#39;n_greater_50k&#39;. The number of individuals making at most $50,000 annually, &#39;n_at_most_50k&#39;. The percentage of individuals making more than $50,000 annually, &#39;greater_percent&#39;. ** HINT: ** You may need to look at the table above to understand how the &#39;income&#39; entries are formatted. 1234567891011121314151617# TODO: Total number of recordsn_records = len(data)# TODO: Number of records where individual's income is more than $50,000n_greater_50k = len(data.income[data.income == '&gt;50K'])# TODO: Number of records where individual's income is at most $50,000n_at_most_50k = len(data.income[data.income == '&lt;=50K'])# TODO: Percentage of individuals whose income is more than $50,000greater_percent = n_greater_50k/n_records*100# Print the resultsprint(\"Total number of records: &#123;&#125;\".format(n_records))print(\"Individuals making more than $50,000: &#123;&#125;\".format(n_greater_50k))print(\"Individuals making at most $50,000: &#123;&#125;\".format(n_at_most_50k))print(\"Percentage of individuals making more than $50,000: &#123;&#125;%\".format(greater_percent)) Total number of records: 45222 Individuals making more than $50,000: 11208 Individuals making at most $50,000: 34014 Percentage of individuals making more than $50,000: 24.78439697492371%** Featureset Exploration ** age: continuous. workclass: Private, Self-emp-not-inc, Self-emp-inc, Federal-gov, Local-gov, State-gov, Without-pay, Never-worked. education: Bachelors, Some-college, 11th, HS-grad, Prof-school, Assoc-acdm, Assoc-voc, 9th, 7th-8th, 12th, Masters, 1st-4th, 10th, Doctorate, 5th-6th, Preschool. education-num: continuous. marital-status: Married-civ-spouse, Divorced, Never-married, Separated, Widowed, Married-spouse-absent, Married-AF-spouse. occupation: Tech-support, Craft-repair, Other-service, Sales, Exec-managerial, Prof-specialty, Handlers-cleaners, Machine-op-inspct, Adm-clerical, Farming-fishing, Transport-moving, Priv-house-serv, Protective-serv, Armed-Forces. relationship: Wife, Own-child, Husband, Not-in-family, Other-relative, Unmarried. race: Black, White, Asian-Pac-Islander, Amer-Indian-Eskimo, Other. sex: Female, Male. capital-gain: continuous. capital-loss: continuous. hours-per-week: continuous. native-country: United-States, Cambodia, England, Puerto-Rico, Canada, Germany, Outlying-US(Guam-USVI-etc), India, Japan, Greece, South, China, Cuba, Iran, Honduras, Philippines, Italy, Poland, Jamaica, Vietnam, Mexico, Portugal, Ireland, France, Dominican-Republic, Laos, Ecuador, Taiwan, Haiti, Columbia, Hungary, Guatemala, Nicaragua, Scotland, Thailand, Yugoslavia, El-Salvador, Trinadad&amp;Tobago, Peru, Hong, Holand-Netherlands. Preparing the DataBefore data can be used as input for machine learning algorithms, it often must be cleaned, formatted, and restructured — this is typically known as preprocessing. Fortunately, for this dataset, there are no invalid or missing entries we must deal with, however, there are some qualities about certain features that must be adjusted. This preprocessing can help tremendously with the outcome and predictive power of nearly all learning algorithms. Transforming Skewed Continuous FeaturesA dataset may sometimes contain at least one feature whose values tend to lie near a single number, but will also have a non-trivial number of vastly larger or smaller values than that single number. Algorithms can be sensitive to such distributions of values and can underperform if the range is not properly normalized. With the census dataset two features fit this description: ‘capital-gain&#39; and &#39;capital-loss&#39;. Run the code cell below to plot a histogram of these two features. Note the range of the values present and how they are distributed. 123456# Split the data into features and target labelincome_raw = data['income']features_raw = data.drop('income', axis = 1)# Visualize skewed continuous features of original datavs.distribution(data) For highly-skewed feature distributions such as &#39;capital-gain&#39; and &#39;capital-loss&#39;, it is common practice to apply a logarithmic transformation on the data so that the very large and very small values do not negatively affect the performance of a learning algorithm. Using a logarithmic transformation significantly reduces the range of values caused by outliers. Care must be taken when applying this transformation however: The logarithm of 0 is undefined, so we must translate the values by a small amount above 0 to apply the the logarithm successfully. Run the code cell below to perform a transformation on the data and visualize the results. Again, note the range of values and how they are distributed. 1234567# Log-transform the skewed featuresskewed = ['capital-gain', 'capital-loss']features_log_transformed = pd.DataFrame(data = features_raw)features_log_transformed[skewed] = features_raw[skewed].apply(lambda x: np.log(x + 1))# Visualize the new log distributionsvs.distribution(features_log_transformed, transformed = True) Normalizing Numerical FeaturesIn addition to performing transformations on features that are highly skewed, it is often good practice to perform some type of scaling on numerical features. Applying a scaling to the data does not change the shape of each feature’s distribution (such as &#39;capital-gain&#39; or &#39;capital-loss&#39; above); however, normalization ensures that each feature is treated equally when applying supervised learners. Note that once scaling is applied, observing the data in its raw form will no longer have the same original meaning, as exampled below. Run the code cell below to normalize each numerical feature. We will use sklearn.preprocessing.MinMaxScaler for this. 123456789101112# Import sklearn.preprocessing.StandardScalerfrom sklearn.preprocessing import MinMaxScaler# Initialize a scaler, then apply it to the featuresscaler = MinMaxScaler() # default=(0, 1)numerical = ['age', 'education-num', 'capital-gain', 'capital-loss', 'hours-per-week']features_log_minmax_transform = pd.DataFrame(data = features_log_transformed)features_log_minmax_transform[numerical] = scaler.fit_transform(features_log_transformed[numerical])# Show an example of a record with scaling applieddisplay(features_log_minmax_transform.head(n = 5)) /home/jason/anaconda3/lib/python3.7/site-packages/sklearn/preprocessing/data.py:334: DataConversionWarning: Data with input dtype int64, float64 were all converted to float64 by MinMaxScaler. return self.partial_fit(X, y) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age workclass education_level education-num marital-status occupation relationship race sex capital-gain capital-loss hours-per-week native-country 0 0.301370 State-gov Bachelors 0.800000 Never-married Adm-clerical Not-in-family White Male 0.667492 0.0 0.397959 United-States 1 0.452055 Self-emp-not-inc Bachelors 0.800000 Married-civ-spouse Exec-managerial Husband White Male 0.000000 0.0 0.122449 United-States 2 0.287671 Private HS-grad 0.533333 Divorced Handlers-cleaners Not-in-family White Male 0.000000 0.0 0.397959 United-States 3 0.493151 Private 11th 0.400000 Married-civ-spouse Handlers-cleaners Husband Black Male 0.000000 0.0 0.397959 United-States 4 0.150685 Private Bachelors 0.800000 Married-civ-spouse Prof-specialty Wife Black Female 0.000000 0.0 0.397959 Cuba Implementation: Data PreprocessingFrom the table in Exploring the Data above, we can see there are several features for each record that are non-numeric. Typically, learning algorithms expect input to be numeric, which requires that non-numeric features (called categorical variables) be converted. One popular way to convert categorical variables is by using the one-hot encoding scheme. One-hot encoding creates a “dummy” variable for each possible category of each non-numeric feature. For example, assume someFeature has three possible entries: A, B, or C. We then encode this feature into someFeature_A, someFeature_B and someFeature_C. someFeature someFeature_A someFeature_B someFeature_C 0 B 0 1 0 1 C —-&gt; one-hot encode —-&gt; 0 0 1 2 A 1 0 0 Additionally, as with the non-numeric features, we need to convert the non-numeric target label, &#39;income&#39; to numerical values for the learning algorithm to work. Since there are only two possible categories for this label (“&lt;=50K” and “&gt;50K”), we can avoid using one-hot encoding and simply encode these two categories as 0 and 1, respectively. In code cell below, you will need to implement the following: Use pandas.get_dummies() to perform one-hot encoding on the &#39;features_log_minmax_transform&#39; data. Convert the target label &#39;income_raw&#39; to numerical entries. Set records with “&lt;=50K” to 0 and records with “&gt;50K” to 1. 123456789101112# TODO: One-hot encode the 'features_log_minmax_transform' data using pandas.get_dummies()features_final = pd.get_dummies(features_log_minmax_transform)# TODO: Encode the 'income_raw' data to numerical valuesincome = pd.get_dummies(income_raw, drop_first=True)# Print the number of features after one-hot encodingencoded = list(features_final.columns)print(\"&#123;&#125; total features after one-hot encoding.\".format(len(encoded)))# Uncomment the following line to see the encoded feature names# print (encoded) 103 total features after one-hot encoding.Shuffle and Split DataNow all categorical variables have been converted into numerical features, and all numerical features have been normalized. As always, we will now split the data (both features and their labels) into training and test sets. 80% of the data will be used for training and 20% for testing. Run the code cell below to perform this split. 123456789101112# Import train_test_splitfrom sklearn.model_selection import train_test_split# Split the 'features' and 'income' data into training and testing setsX_train, X_test, y_train, y_test = train_test_split(features_final, income, test_size = 0.2, random_state = 0)# Show the results of the splitprint(\"Training set has &#123;&#125; samples.\".format(X_train.shape[0]))print(\"Testing set has &#123;&#125; samples.\".format(X_test.shape[0])) Training set has 36177 samples. Testing set has 9045 samples. Evaluating Model PerformanceIn this section, we will investigate four different algorithms, and determine which is best at modeling the data. Three of these algorithms will be supervised learners of your choice, and the fourth algorithm is known as a naive predictor. Metrics and the Naive PredictorCharityML, equipped with their research, knows individuals that make more than $50,000 are most likely to donate to their charity. Because of this, CharityML is particularly interested in predicting who makes more than $50,000 accurately. It would seem that using accuracy as a metric for evaluating a particular model’s performace would be appropriate. Additionally, identifying someone that does not make more than $50,000 as someone who does would be detrimental to CharityML, since they are looking to find individuals willing to donate. Therefore, a model’s ability to precisely predict those that make more than $50,000 is more important than the model’s ability to recall those individuals. We can use F-beta score as a metric that considers both precision and recall: $$ F_{\\beta} = (1 + \\beta^2) \\cdot \\frac{precision \\cdot recall}{\\left( \\beta^2 \\cdot precision \\right) + recall} $$ In particular, when $\\beta = 0.5$, more emphasis is placed on precision. This is called the F$_{0.5}$ score (or F-score for simplicity). Looking at the distribution of classes (those who make at most $50,000, and those who make more), it’s clear most individuals do not make more than $50,000. This can greatly affect accuracy, since we could simply say *”this person does not make more than $50,000”* and generally be right, without ever looking at the data! Making such a statement would be called naive, since we have not considered any information to substantiate the claim. It is always important to consider the naive prediction for your data, to help establish a benchmark for whether a model is performing well. That been said, using that prediction would be pointless: If we predicted all people made less than $50,000, CharityML would identify no one as donors. Note: Recap of accuracy, precision, recall** Accuracy ** measures how often the classifier makes the correct prediction. It’s the ratio of the number of correct predictions to the total number of predictions (the number of test data points). ** Precision ** tells us what proportion of messages we classified as spam, actually were spam.It is a ratio of true positives(words classified as spam, and which are actually spam) to all positives(all words classified as spam, irrespective of whether that was the correct classificatio), in other words it is the ratio of [True Positives/(True Positives + False Positives)] ** Recall(sensitivity)** tells us what proportion of messages that actually were spam were classified by us as spam.It is a ratio of true positives(words classified as spam, and which are actually spam) to all the words that were actually spam, in other words it is the ratio of [True Positives/(True Positives + False Negatives)] For classification problems that are skewed in their classification distributions like in our case, for example if we had a 100 text messages and only 2 were spam and the rest 98 weren’t, accuracy by itself is not a very good metric. We could classify 90 messages as not spam(including the 2 that were spam but we classify them as not spam, hence they would be false negatives) and 10 as spam(all 10 false positives) and still get a reasonably good accuracy score. For such cases, precision and recall come in very handy. These two metrics can be combined to get the F1 score, which is weighted average(harmonic mean) of the precision and recall scores. This score can range from 0 to 1, with 1 being the best possible F1 score(we take the harmonic mean as we are dealing with ratios). Question 1 - Naive Predictor Performace If we chose a model that always predicted an individual made more than $50,000, what would that model’s accuracy and F-score be on this dataset? You must use the code cell below and assign your results to &#39;accuracy&#39; and &#39;fscore&#39; to be used later. ** Please note ** that the the purpose of generating a naive predictor is simply to show what a base model without any intelligence would look like. In the real world, ideally your base model would be either the results of a previous model or could be based on a research paper upon which you are looking to improve. When there is no benchmark model set, getting a result better than random choice is a place you could start from. ** HINT: ** When we have a model that always predicts ‘1’ (i.e. the individual makes more than 50k) then our model will have no True Negatives(TN) or False Negatives(FN) as we are not making any negative(‘0’ value) predictions. Therefore our Accuracy in this case becomes the same as our Precision(True Positives/(True Positives + False Positives)) as every prediction that we have made with value ‘1’ that should have ‘0’ becomes a False Positive; therefore our denominator in this case is the total number of records we have in total. Our Recall score(True Positives/(True Positives + False Negatives)) in this setting becomes 1 as we have no False Negatives. 1234567891011121314151617TP = np.sum(income)# Counting the ones as this is the naive case. Note that 'income' is the 'income_raw' data # encoded to numerical values done in the data preprocessing step.FP = income.count() - TP # Specific to the naive caseTN = 0 # No predicted negatives in the naive caseFN = 0 # No predicted negatives in the naive case# TODO: Calculate accuracy, precision and recallaccuracy = TP/(TP+FP+FN+TN)recall = TP/(TP+FN)precision = TP/(TP+FP)# TODO: Calculate F-score using the formula above for beta = 0.5 and correct values for precision and recall.fscore = (1+0.5*0.5)*(precision[0]*recall[0])/(precision[0]*0.5*0.5+recall[0])# Print the results print(\"Naive Predictor: [Accuracy score: &#123;:.4f&#125;, F-score: &#123;:.4f&#125;]\".format(accuracy[0],fscore)) Naive Predictor: [Accuracy score: 0.2478, F-score: 0.2917]Supervised Learning ModelsThe following are some of the supervised learning models that are currently available in scikit-learn that you may choose from: Gaussian Naive Bayes (GaussianNB) Decision Trees Ensemble Methods (Bagging, AdaBoost, Random Forest, Gradient Boosting) K-Nearest Neighbors (KNeighbors) Stochastic Gradient Descent Classifier (SGDC) Support Vector Machines (SVM) Logistic Regression Question 2 - Model ApplicationList three of the supervised learning models above that are appropriate for this problem that you will test on the census data. For each model chosen Describe one real-world application in industry where the model can be applied. What are the strengths of the model; when does it perform well? What are the weaknesses of the model; when does it perform poorly? What makes this model a good candidate for the problem, given what you know about the data? ** HINT: ** Structure your answer in the same format as above^, with 4 parts for each of the three models you pick. Please include references with your answer. *Answer: * 1. Logistic Regression1) It can be used in banking system to determine whether a customer will default or not. 2) When the targeted is a dummy variable this model can perform well. It’s highly interpretable and very efficient. 3) It is not suitable for non-linear problems and it is relatively perform worse than other complex methods. 4) In this problem we want to estimate the dummy which are people who have salary over or below 50k. This model is exactly suitable for this situation. 2. Ensemble Methods (Random Forest)1) It can be used to determine span e-mails or classify user’s profile. 2) It performs better than many other simple models and not likely to be overfitting. It suits non-linear problems. 3) It is not suitable for linear problems, it is hard to interpret, and it requires high computational power. 4) In this problem we have a classification problem and ensemble methods can give us a good model. 3.Support Vector Machines (SVM)1) It can also be used for classification problems like whether a customer will default or not. 2) SVM is effective in high dimensional spaces and fast. 3) Not suitable for large dataset. 4) In our problem, we have many dimensions, SVM might perform good. Implementation - Creating a Training and Predicting PipelineTo properly evaluate the performance of each model you’ve chosen, it’s important that you create a training and predicting pipeline that allows you to quickly and effectively train models using various sizes of training data and perform predictions on the testing data. Your implementation here will be used in the following section.In the code block below, you will need to implement the following: Import fbeta_score and accuracy_score from sklearn.metrics. Fit the learner to the sampled training data and record the training time. Perform predictions on the test data X_test, and also on the first 300 training points X_train[:300]. Record the total prediction time. Calculate the accuracy score for both the training subset and testing set. Calculate the F-score for both the training subset and testing set. Make sure that you set the beta parameter! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# TODO: Import two metrics from sklearn - fbeta_score and accuracy_scorefrom sklearn.metrics import fbeta_scorefrom sklearn.metrics import accuracy_scoredef train_predict(learner, sample_size, X_train, y_train, X_test, y_test): ''' inputs: - learner: the learning algorithm to be trained and predicted on - sample_size: the size of samples (number) to be drawn from training set - X_train: features training set - y_train: income training set - X_test: features testing set - y_test: income testing set ''' results = &#123;&#125; # TODO: Fit the learner to the training data using slicing with 'sample_size' using .fit(training_features[:], training_labels[:]) start = time() # Get start time learner = learner.fit(X_train[:sample_size:], y_train[:sample_size].values.ravel()) end = time() # Get end time # TODO: Calculate the training time results['train_time'] = end - start # TODO: Get the predictions on the test set(X_test), # then get predictions on the first 300 training samples(X_train) using .predict() start = time() # Get start time predictions_test = learner.predict(X_test) predictions_train = learner.predict(X_train[:300]) end = time() # Get end time # TODO: Calculate the total prediction time results['pred_time'] = end - start # TODO: Compute accuracy on the first 300 training samples which is y_train[:300] results['acc_train'] = accuracy_score(y_train[:300], predictions_train) # TODO: Compute accuracy on test set using accuracy_score() results['acc_test'] = accuracy_score(y_test, predictions_test) # TODO: Compute F-score on the the first 300 training samples using fbeta_score() results['f_train'] = fbeta_score(y_train[:300], predictions_train, beta = 0.5) # TODO: Compute F-score on the test set which is y_test results['f_test'] = fbeta_score(y_test, predictions_test, beta = 0.5) # Success print(\"&#123;&#125; trained on &#123;&#125; samples.\".format(learner.__class__.__name__, sample_size)) # Return the results return results Implementation: Initial Model EvaluationIn the code cell, you will need to implement the following: Import the three supervised learning models you’ve discussed in the previous section. Initialize the three models and store them in &#39;clf_A&#39;, &#39;clf_B&#39;, and &#39;clf_C&#39;. Use a &#39;random_state&#39; for each model you use, if provided. Note: Use the default settings for each model — you will tune one specific model in a later section. Calculate the number of records equal to 1%, 10%, and 100% of the training data. Store those values in &#39;samples_1&#39;, &#39;samples_10&#39;, and &#39;samples_100&#39; respectively. Note: Depending on which algorithms you chose, the following implementation may take some time to run! 123456789101112131415161718192021222324252627282930# TODO: Import the three supervised learning models from sklearnfrom sklearn.linear_model import LogisticRegressionfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.svm import SVCimport randomrandom.seed(42)# TODO: Initialize the three modelsclf_A = LogisticRegression(solver = 'liblinear') # set the default value manually in order to get rid of warningsclf_B = RandomForestClassifier(n_estimators = 100) # set the default value manually in order to get rid of warningsclf_C = SVC(gamma = 'scale') # set the default value manually in order to get rid of warnings# TODO: Calculate the number of samples for 1%, 10%, and 100% of the training data# HINT: samples_100 is the entire training set i.e. len(y_train)# HINT: samples_10 is 10% of samples_100 (ensure to set the count of the values to be `int` and not `float`)# HINT: samples_1 is 1% of samples_100 (ensure to set the count of the values to be `int` and not `float`)samples_100 = len(y_train)samples_10 = int(len(y_train)*0.1)samples_1 = int(len(y_train)*0.01)# Collect results on the learnersresults = &#123;&#125;for clf in [clf_A, clf_B, clf_C]: clf_name = clf.__class__.__name__ results[clf_name] = &#123;&#125; for i, samples in enumerate([samples_1, samples_10, samples_100]): results[clf_name][i] = \\ train_predict(clf, samples, X_train, y_train, X_test, y_test)# Run metrics visualization for the three supervised learning models chosenvs.evaluate(results, accuracy[0], fscore) LogisticRegression trained on 361 samples. LogisticRegression trained on 3617 samples. LogisticRegression trained on 36177 samples. RandomForestClassifier trained on 361 samples. RandomForestClassifier trained on 3617 samples. RandomForestClassifier trained on 36177 samples. SVC trained on 361 samples. SVC trained on 3617 samples. SVC trained on 36177 samples. Improving ResultsIn this final section, you will choose from the three supervised learning models the best model to use on the student data. You will then perform a grid search optimization for the model over the entire training set (X_train and y_train) by tuning at least one parameter to improve upon the untuned model’s F-score. Question 3 - Choosing the Best Model Based on the evaluation you performed earlier, in one to two paragraphs, explain to CharityML which of the three models you believe to be most appropriate for the task of identifying individuals that make more than $50,000. ** HINT: **Look at the graph at the bottom left from the cell above(the visualization created by vs.evaluate(results, accuracy, fscore)) and check the F score for the testing set when 100% of the training set is used. Which model has the highest score? Your answer should include discussion of the: metrics - F score on the testing when 100% of the training data is used, prediction/training time the algorithm’s suitability for the data. *Answer: * The Logistic Regression model is the best model in this situation. When 100% of the training data is used, the Logistic Regression model has the second highest F-score on testing set with only very slightly difference compared with the best model (SVM). However, it has the lowest training and prediction times, which is faster than the third(best) model quite a lot. Therefore it is wise to choose Logistic Regression model. Actually, Logistic Regression model is very suitable for this data because the targeted variable is a dummy. Question 4 - Describing the Model in Layman’s Terms In one to two paragraphs, explain to CharityML, in layman’s terms, how the final model chosen is supposed to work. Be sure that you are describing the major qualities of the model, such as how the model is trained and how the model makes a prediction. Avoid using advanced mathematical jargon, such as describing equations. ** HINT: ** When explaining your model, if using external resources please include all citations. *Answer: * The logistic regression model will create a linear boundary cutting the data points, which can classify whether people have high income or not. It estimates the probability of a person belongs to high income group or low income group based on the change of explaining variables. Logistic regression uses the natural logarithm function to find the relationship between the variables and uses test data to find the coefficients. The function can then predict the future results using these coefficients in the logistic equation.[1] Therefore, this model can split our dataset successfully. It can be seen in th graph, different from linear model, logistic model is a non-linear function with probability between 0 to 1. [1] Wikipedia. (2020). Logistic Regression. [online] Available at: https://simple.wikipedia.org/wiki/Logistic_Regression [Accessed 13 Jan. 2020]. Implementation: Model TuningFine tune the chosen model. Use grid search (GridSearchCV) with at least one important parameter tuned with at least 3 different values. You will need to use the entire training set for this. In the code cell below, you will need to implement the following: Import sklearn.grid_search.GridSearchCV and sklearn.metrics.make_scorer. Initialize the classifier you’ve chosen and store it in clf. Set a random_state if one is available to the same state you set before. Create a dictionary of parameters you wish to tune for the chosen model. Example: parameters = {&#39;parameter&#39; : [list of values]}. Note: Avoid tuning the max_features parameter of your learner if that parameter is available! Use make_scorer to create an fbeta_score scoring object (with $\\beta = 0.5$). Perform grid search on the classifier clf using the &#39;scorer&#39;, and store it in grid_obj. Fit the grid search object to the training data (X_train, y_train), and store it in grid_fit. Note: Depending on the algorithm chosen and the parameter list, the following implementation may take some time to run! 12345678910111213141516171819202122232425262728293031323334# TODO: Import 'GridSearchCV', 'make_scorer', and any other necessary librariesfrom sklearn.model_selection import GridSearchCVfrom sklearn.metrics import make_scorerrandom.seed(42)# TODO: Initialize the classifierclf = LogisticRegression(solver = 'liblinear')# TODO: Create the parameters list you wish to tune, using a dictionary if needed.# HINT: parameters = &#123;'parameter_1': [value1, value2], 'parameter_2': [value1, value2]&#125;parameters = &#123;'solver':['lbfgs', 'newton-cg', 'sag', 'saga'], 'max_iter':[700, 1000, 1200]&#125;# TODO: Make an fbeta_score scoring object using make_scorer()scorer = make_scorer(fbeta_score, beta = 0.5)# TODO: Perform grid search on the classifier using 'scorer' as the scoring method using GridSearchCV()grid_obj = GridSearchCV(clf, parameters, scoring=scorer, cv = 10)# TODO: Fit the grid search object to the training data and find the optimal parameters using fit()grid_fit = grid_obj.fit(X_train, y_train.values.ravel())# Get the estimatorbest_clf = grid_fit.best_estimator_# Make predictions using the unoptimized and modelpredictions = (clf.fit(X_train, y_train.values.ravel())).predict(X_test)best_predictions = best_clf.predict(X_test)# Report the before-and-afterscoresprint(\"Unoptimized model\\n------\")print(\"Accuracy score on testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, predictions)))print(\"F-score on testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, predictions, beta = 0.5)))print(\"\\nOptimized Model\\n------\")print(\"Final accuracy score on the testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, best_predictions)))print(\"Final F-score on the testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, best_predictions, beta = 0.5))) Unoptimized model ------ Accuracy score on testing data: 0.8419 F-score on testing data: 0.6832 Optimized Model ------ Final accuracy score on the testing data: 0.8418 Final F-score on the testing data: 0.6829Question 5 - Final Model Evaluation What is your optimized model’s accuracy and F-score on the testing data? Are these scores better or worse than the unoptimized model? How do the results from your optimized model compare to the naive predictor benchmarks you found earlier in Question 1?_ Note: Fill in the table below with your results, and then provide discussion in the Answer box. Results: Metric Unoptimized Model Optimized Model Accuracy Score 0.8419 0.8418 F-score 0.6832 0.6829 *Answer: * The scores for the optimized model is worse than the unoptimized model. The scores for the optimized model improves a lot compared with the naive model. Feature ImportanceAn important task when performing supervised learning on a dataset like the census data we study here is determining which features provide the most predictive power. By focusing on the relationship between only a few crucial features and the target label we simplify our understanding of the phenomenon, which is most always a useful thing to do. In the case of this project, that means we wish to identify a small number of features that most strongly predict whether an individual makes at most or more than $50,000. Choose a scikit-learn classifier (e.g., adaboost, random forests) that has a feature_importance_ attribute, which is a function that ranks the importance of features according to the chosen classifier. In the next python cell fit this classifier to training set and use this attribute to determine the top 5 most important features for the census dataset. Question 6 - Feature Relevance ObservationWhen Exploring the Data, it was shown there are thirteen available features for each individual on record in the census data. Of these thirteen records, which five features do you believe to be most important for prediction, and in what order would you rank them and why? Answer: education_num: more education might get better jobs hours-per-week: more working hours more money age: higher age implies more experience thus more income marital status: married people might have more incentive to earn more money sex: it might exists sex discrimination. Implementation - Extracting Feature ImportanceChoose a scikit-learn supervised learning algorithm that has a feature_importance_ attribute availble for it. This attribute is a function that ranks the importance of each feature when making predictions based on the chosen algorithm. In the code cell below, you will need to implement the following: Import a supervised learning model from sklearn if it is different from the three used earlier. Train the supervised model on the entire training set. Extract the feature importances using &#39;.feature_importances_&#39;. 123456789101112131415161718# TODO: Import a supervised learning model that has 'feature_importances_'from sklearn.model_selection import RandomizedSearchCV# TODO: Train the supervised model on the training set using .fit(X_train, y_train)param_dist = &#123;\"max_depth\": [3, None], \"n_estimators\": list(range(10, 200)), \"max_features\": list(range(1, X_test.shape[1]+1)), \"min_samples_split\": list(range(2, 11)), \"min_samples_leaf\": list(range(1, 11)), \"bootstrap\": [True, False], \"criterion\": [\"gini\", \"entropy\"]&#125;model = RandomizedSearchCV(clf_B, param_distributions=param_dist)model.fit(X_train, y_train.values.ravel())# TODO: Extract the feature importances using .feature_importances_ importances = model.best_estimator_.feature_importances_# Plotvs.feature_plot(importances, X_train, y_train) /home/jason/anaconda3/lib/python3.7/site-packages/sklearn/model_selection/_split.py:2053: FutureWarning: You should specify a value for &apos;cv&apos; instead of relying on the default value. The default value will change from 3 to 5 in version 0.22. warnings.warn(CV_WARNING, FutureWarning) Question 7 - Extracting Feature ImportanceObserve the visualization created above which displays the five most relevant features for predicting if an individual makes at most or above $50,000. How do these five features compare to the five features you discussed in Question 6? If you were close to the same answer, how does this visualization confirm your thoughts? If you were not close, why do you think these features are more relevant? Answer: Compared with what I thought before, the importance of marital status, ages and years of education are comfirmed by the graph because their weights are high. However, capital-gain and relationship_Husband is not what I predicted. For capital-gain it might be only whealthy people can have more gain in capital since they have more free money to invest. For relationship, it is kind of overlap with the marital status so the reason is similar as what I explained before that married people are more likely try to earn more money to support the family especially for males. Feature SelectionHow does a model perform if we only use a subset of all the available features in the data? With less features required to train, the expectation is that training and prediction time is much lower — at the cost of performance metrics. From the visualization above, we see that the top five most important features contribute more than half of the importance of all features present in the data. This hints that we can attempt to reduce the feature space and simplify the information required for the model to learn. The code cell below will use the same optimized model you found earlier, and train it on the same training set with only the top five important features. 1234567891011121314151617181920# Import functionality for cloning a modelfrom sklearn.base import clone# Reduce the feature spaceX_train_reduced = X_train[X_train.columns.values[(np.argsort(importances)[::-1])[:5]]]X_test_reduced = X_test[X_test.columns.values[(np.argsort(importances)[::-1])[:5]]]# Train on the \"best\" model found from grid search earlierclf = (clone(best_clf)).fit(X_train_reduced, y_train)# Make new predictionsreduced_predictions = clf.predict(X_test_reduced)# Report scores from the final model using both versions of dataprint(\"Final Model trained on full data\\n------\")print(\"Accuracy on testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, best_predictions)))print(\"F-score on testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, best_predictions, beta = 0.5)))print(\"\\nFinal Model trained on reduced data\\n------\")print(\"Accuracy on testing data: &#123;:.4f&#125;\".format(accuracy_score(y_test, reduced_predictions)))print(\"F-score on testing data: &#123;:.4f&#125;\".format(fbeta_score(y_test, reduced_predictions, beta = 0.5))) Final Model trained on full data ------ Accuracy on testing data: 0.8418 F-score on testing data: 0.6829 Final Model trained on reduced data ------ Accuracy on testing data: 0.8258 F-score on testing data: 0.6462 /home/jason/anaconda3/lib/python3.7/site-packages/sklearn/utils/validation.py:761: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True)Question 8 - Effects of Feature Selection How does the final model’s F-score and accuracy score on the reduced data using only five features compare to those same scores when all features are used? If training time was a factor, would you consider using the reduced data as your training set? Answer: It is actually very close to the full features with slightly lower scores. However since I am using Logistic Regression model, I will not use the reduced data. Because the training time is alreay very short with the full features. The algorithm is very efficient so the room for improvement is quite limited. Therefore it is not wise to sacrifice the model accuracy to save only a few seconds. Note: Once you have completed all of the code implementations and successfully answered each question above, you may finalize your work by exporting the iPython Notebook as an HTML document. You can do this by using the menu above and navigating toFile -&gt; Download as -&gt; HTML (.html). Include the finished document along with this notebook as your submission.","comments":true,"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"R速查表","date":"2020-01-22T11:40:35.000Z","path":"2020/01/22/R速查表/","text":"R 各种速查表, Cheat Sheet。不支持手机浏览... 1. R 基础R basic R advanced Regular expressions R Markdown Use Python in R 2. 数据处理Data import dplyr Data transformation Strings Factors Dates and times with lubridate Apply functions with purrr Data Science in Spark with sparklyr 3. 数据可视化ggplot2 Thematic maps with cartography 4. 机器学习R 自带 caret(Classification And REgression Training) Deep Learning with Keras Time series 来源以及最后 https://rstudio.com/resources/cheatsheets/ 大家有好的Cheat sheet欢迎留言补充","comments":true,"tags":[{"name":"速查表","slug":"速查表","permalink":"http://yoursite.com/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"}]},{"title":"Python速查表","date":"2020-01-22T10:13:35.000Z","path":"2020/01/22/Python速查表/","text":"Python 各种速查表,Cheat Sheet。不支持手机浏览... 1. Python 基础Python basic Python classes Python dictionaries Python lists Python functions Python if and while Python regular expressions Python read files 2. Python 各种包1. Numpy 2. Pandas 3. Matplotlib 4. Seaborn 5. Scikit-learn 6. Pytorch官方文档: https://pytorch.org/tutorials/beginner/ptcheat.html 来源以及最后 https://ehmatthes.github.io/pcc_2e/cheat_sheets/cheat_sheets/ https://www.datacamp.com/community/data-science-cheatsheets https://www.dataquest.io/blog/regex-cheatsheet/ 一个很好的python基础速查表: https://github.com/crazyguitar/pysheeet 大家有好的Cheat sheet欢迎留言补充","comments":true,"tags":[{"name":"速查表","slug":"速查表","permalink":"http://yoursite.com/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"}]},{"title":"基于python的基金定投分析","date":"2020-01-21T18:50:35.000Z","path":"2020/01/21/基于python的基金定投分析/","text":"使用python可视化分析基金定投和普通投资之间的区别和优缺点。探讨基金定投的降低风险作用。 1234567import requestsfrom bs4 import BeautifulSoupimport reimport pandas as pdimport numpy as npimport randomimport matplotlib.pyplot as plt 爬取东方财富网关于基金的数据并处理数据123456789101112131415161718192021222324252627282930313233343536373839404142link=\"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&amp;code=000311&amp;page=1&amp;sdate=2018-01-02&amp;edate=2020-01-10&amp;per=20\"headers=&#123; 'user-agent': \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\",&#125;r=requests.get(link,headers=headers)s1 = requests.get(link)s1.encoding = 'utf-8'soup1=BeautifulSoup(s1.text,'lxml')fund_detail=soup1.find_all('tr')###获取总页数pattern=re.compile(r'pages:(.*),')html=r.textresult=re.search(pattern,html).group(1)pages=int(result)pagesdata_list=[]for i in range(1, pages+1): link='http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&amp;code=000311&amp;page='+str(i)+'&amp;sdate=2018-01-02&amp;edate=2020-01-10&amp;per=20' r=requests.get(link,headers=headers) s1 = requests.get(link) s1.encoding = 'utf-8' soup1=BeautifulSoup(s1.text,'lxml') fund_detail=soup1.find_all('tr') for each in fund_detail: if each.td is None: continue else: date=each.td.text.strip()##only first td unit_value=each.find('td',class_='tor bold').text.strip()##first tor bold cum_value=each.find('td',class_='tor bold').next_sibling.text.strip()##second td percent=each.find('td').next_sibling.next_sibling.next_sibling.text.strip() purchase_condition=each.find('td').next_sibling.next_sibling.next_sibling.next_sibling.text.strip() sale_condition=each.find('td').next_sibling.next_sibling.next_sibling.next_sibling.next_sibling.text.strip() dividend=each.find('td',class_='red unbold').text.strip() code= '000311' name= '景顺长城沪深300增强' data_list.append([code, name, date,unit_value, cum_value, percent,purchase_condition, sale_condition, dividend]) 1len(data_list) 49712fund_000311 = pd.DataFrame(data_list)# 设置列名fund_000311.columns=['代码','名字','时间','单位净值','累计净值','涨跌幅','申购','赎回','分红'] 1fund_000311.to_csv(\"data0003111\") 1fund_000311.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 代码 名字 时间 单位净值 累计净值 涨跌幅 申购 赎回 分红 0 000311 景顺长城沪深300增强 2020-01-10 2.2260 2.5660 0.32% 开放申购 开放赎回 1 000311 景顺长城沪深300增强 2020-01-09 2.2190 2.5590 1.46% 开放申购 开放赎回 2 000311 景顺长城沪深300增强 2020-01-08 2.1870 2.5270 -1.44% 开放申购 开放赎回 3 000311 景顺长城沪深300增强 2020-01-07 2.2190 2.5590 0.91% 开放申购 开放赎回 4 000311 景顺长城沪深300增强 2020-01-06 2.1990 2.5390 -0.36% 开放申购 开放赎回 12345678910111213##画出走势图(累计净值),共1328个交易日,累计净值=单位净值+累计分红cum_price=fund_000311[['单位净值']]cum_price=np.array(cum_price)cum_price=cum_price.tolist()cum_value=list()t = np.arange(0.0, 497.0, 1)for each in reversed(cum_price):##倒序 从头开始 cum_price=float(*each) cum_value.append(cum_price)plt.plot(t,cum_value,'r-')plt.ylabel('value')plt.xlabel('time') plt.title('Fund 000311 HuSheng 300 ') Text(0.5, 1.0, &apos;Fund 000311 HuSheng 300 &apos;) 123456789101112131415161718##涨跌情况percent=fund_000311[['涨跌幅']]percent=np.array(percent)percent=percent.tolist()while [''] in percent: percent.remove([''])#去除三个空白值percent_val=[]t = np.arange(0.0, 494.0, 1)i=1for each in reversed(percent):##倒序 从头开始 each=float(str(*each).strip('%')) percent_val.append(each) i=i+1 plt.plot(t,percent_val,'r-',linewidth=0.5)plt.ylabel('ratio(%)')plt.xlabel('time') plt.title('Fund 000311 HuSheng 300 ')##可以看到在第二百到第三百个交易日波动率明显变大,400到500明显波动率小。 Text(0.5, 1.0, &apos;Fund 000311 HuSheng 300 &apos;) 基金定投研究123unit_price=fund_000311[['单位净值']]unit_price=np.array(unit_price)unit_price=unit_price.tolist() 123# 查出分红情况dividend=fund_000311.loc[fund_000311['分红'] != '']dividend # 期间无分红 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 代码 名字 时间 单位净值 累计净值 涨跌幅 申购 赎回 分红 1. 简单情况一次买入1234567891011121314# 计算年化收益total_yearly_once = []unit_price_new = unit_price[50:494] # 避免投资时间太短不考虑近50个交易日dayday = 497 # 投资时长for i in reversed(unit_price_new): i=float(*i) pie=1000/i ##份额 temp = pie*2.226 # 2.226 20年1月10日 total_return = (temp-1000)/1000 yearly_return = total_return/dayday*250 # 250个交易日 total_yearly_once.append(yearly_return) dayday = dayday - 1total_yearly_once_df=pd.DataFrame(total_yearly_once) 1234567# 画图t = np.arange(0.0, 444.0, 1)plt.plot(t,total_yearly_once_df,'r-')plt.ylabel('ratio(%)')plt.xlabel('time') plt.title('Fund 000311 normal investment ') Text(0.5, 1.0, &apos;Fund 000311 normal investment &apos;) 可以看到收益率的波动率在这段期间非常的大,大致从0到将近60%,并且存在负收益率。 1plt.hist(total_yearly_once, bins=5,facecolor=\"red\", edgecolor=\"black\", alpha=0.7) (array([101., 110., 124., 78., 31.]), array([-0.02019805, 0.09804444, 0.21628694, 0.33452944, 0.45277193, 0.57101443]), &lt;a list of 5 Patch objects&gt;) 定投简单情况(不考虑时间价值)automatic investment plan 1234567891011121314151617# 计算年化收益total_yearly_auto = []times= np.arange(494, 50, -1)dayday = 497 # 投资时长for i in times: unit_price_new = unit_price[50:i+1] # 避免投资时间太短不考虑近50个交易日 each_pie=[] each_amount=1000/(len(unit_price_new)) # 每笔投资多少 for each in (unit_price_new): each=float(*each) pie=each_amount/each each_pie.append(pie) total_return=(sum(each_pie)*2.226-1000)/1000 yearly_return = total_return/dayday*250 total_yearly_auto.append(yearly_return) dayday = dayday - 1total_yearly_auto_df=pd.DataFrame(total_yearly_auto) 1234567t = np.arange(0.0, 444.0, 1)plt.plot(t,total_yearly_auto_df,'b-', label='auto')plt.plot(t,total_yearly_once_df,'r-', label='normal')plt.legend(loc='upper right')plt.ylabel('ratio(%)')plt.xlabel('time') plt.title('Fund 000311 auto investment') Text(0.5, 1.0, &apos;Fund 000311 auto investment&apos;) 12plt.hist(total_yearly_once, bins=10,facecolor=\"red\", edgecolor=\"black\", alpha=0.7)plt.hist(total_yearly_auto, bins=10,facecolor=\"blue\", edgecolor=\"black\", alpha=0.7) (array([ 52., 107., 148., 108., 6., 12., 2., 5., 2., 2.]), array([0.07401984, 0.09161269, 0.10920555, 0.1267984 , 0.14439126, 0.16198411, 0.17957697, 0.19716982, 0.21476267, 0.23235553, 0.24994838]), &lt;a list of 10 Patch objects&gt;) 通过画图可以看出,定投具有更小的收益率波动性,因此也具有更小的风险。收益率大致在10%到15%之间,没有负收益率。 总结可以看出定投具有所谓的“削峰填谷”的作用, 可以达到随时买入而年化收益波动不大的效果。而普通投资的收益率不稳定,可能一下子“暴富”也可能“白忙活”,需要投资者掌握投资时机。定投对于想要稳定增值资产的投资者是一个相对比较好的选择。 最后项目在GitHub上网址:https://github.com/JasonVictor17/Stock-market-analysis","comments":true,"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"金融股市","slug":"金融股市","permalink":"http://yoursite.com/tags/%E9%87%91%E8%9E%8D%E8%82%A1%E5%B8%82/"}]},{"title":"个人博客建设6-主题的配置Next","date":"2020-01-21T16:00:35.000Z","path":"2020/01/21/个人博客建设6-主题的配置Next/","text":"个人博客建设第六步:本篇介绍如何配置Next主题,使其更加个性化,其他主题的配置其实也大同小异可以参考,这篇也是本教程的最后一篇,以后可能会更新更多关于博客建设的内容。 首先我们找到主题文件夹Next里的配置文件,对,就是那个和站点配置文件一样名字的_config.yml。 打开会发现里面有几百行。。。不过没关系我会介绍最主要的几个配置。其他就留给大家自行探索了。 1. 菜单栏看我的博客可以看见有很多标签和分类,但是初始状态是没有的,我们需要配置。首先我们找到menu 栏,把tags(标签),Categories(分类)或者其他需要的标签前的#号删除,表面我们使用这行代码 保存后我们在博客主目录下输入: 1hexo new page tags 我们就会在source文件夹内发现生成了一个tags的文件夹,打开里面的index.md文件按照如下设置 然后保存就行了,其他的标签也是类似操作就不赘述了。之后我们在写文章时候按照如下格式写开头: 就可以自动生成标签和分类了。每一次有新的标签和分类都会自动在网页生成,方便快捷~(自动保存在public文件夹内) 2.语言 在站点配置文件中填写: language: ‘zh-CN’就可以设置中文了,其他语言参考如下: 3. 添加搜索功能首先在博客根目录安装插件: 1npm install hexo-generator-searchdb --save 在站点配置文件最后加上: 12345search: path: search.xml field: post format: html limit: 10000 最后在主题配置文件中:找到 local_search 改为true(在vs code中可以使用搜索找到该参数)这样部署一下博客内搜索功能就上线了。 4.设置作者昵称和站点介绍等打开站点配置文件,第一项里进行编辑,title,author和description等 5. 修改favicon图标也就是网页的图标,我的博客是一只手工画的小老鼠。使用工具将需要的图片裁剪成1616和3232大小,然后打开next文件夹下的source文件夹,再打开images文件夹将图片保存其中。打开主题配置文件找到favicon,如下输入自己文件名字: 123favicon: small: &#x2F;images&#x2F;mouse16.ico medium: &#x2F;images&#x2F;mouse32.ico 再部署就可以看见图标已经更改。图片剪裁工具:比特虫 6. 开通评论功能注册来必力,填写网站后可以得到一串代码,我们只需要其中一部分。 复制这一串数字后我们打开主题配置文件,找到LiveRe comments system,去掉#注释,在livere_uid后粘贴上就完成了。 7.赞赏 找到主题配置文件下的reward,把自己的微信收款或者支付宝收款二维码放上去就行了。 结语到这里一个自己的博客基本上就搭好了,接下来就是自我探索折腾的过程了,网上资源很多可以慢慢折腾自己的博客,我也会不定期的更新我所获得的搭博客小技巧。 在属于自己的一片小天地尽情发挥吧! 上一步: 个人博客建设5-Markdown语法目录: 用GitHub搭建个人博客(目录)","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"个人博客建设5-Markdown语法","date":"2020-01-21T15:29:35.000Z","path":"2020/01/21/个人博客建设5-Markdown语法/","text":"个人博客建设第五步:用基本的Markdown语法来写博客... 为什么markdown首先我们写的每一篇博客都是基于md也就是markdown文件的,其次Markdown 是一种轻量级标记语言,它允许人们使用易读易写的纯文本格式编写文档,非常适合写博客。 编辑器的选择可以使用VS code, MarkdownPad或者BookPad(注意这个收费14块)具体的选择结合自身喜好,没有什么大的区别,都具有实时预览功能我觉得就够了。 简单的几个语法1. 标题12# hello## hello 上面两个分别是主标题和次级标题的区别,井号越多字体就越小,标题也越次级。 2. 字体和颜色123&lt;font face&#x3D;&quot;黑体&quot;&gt;&lt;font color&#x3D;red size&#x3D;4&gt;&lt;font color&#x3D;red size&#x3D;4 face&#x3D;&quot;黑体&quot;&gt; 使用如上方式在之后加上文字的效果分别如下:我是好人我是好人我是好人 :kissing: 想要打出如上表情我们只需要输入 1:kissing: 具体可以参考GitHub上: https://github.com/guodongxiaren/README/blob/master/emoji.md 3. 图片的插入当我们使用Hexo建立博客的时候免不了要插入图片,我们可以在source下创建一个image文件夹然后通过: 1![](&#x2F;image&#x2F;image.png) 来访问。但是这里我推荐以下一种用法虽然略有点麻烦,但是以后处理图片会很方便。首先在博客的目录blog下用命令行运行如下代码安装一个小插件, 参考:https://github.com/xcodebuild/hexo-asset-image 1npm install hexo-asset-image --save 然后我们在站点配置文件_congif.yml中设置: 1post_asset_folder: true 之后我们我们只要在撰写博客的目录下,也就是source目录下的_posts文件夹内创建一个和这篇博客名字一样的文件夹,把图片放入其中,就可以按照如下来插入图片了: 1![图片命名](logo.jpg) 不需要指定图片的路径,另外如果是在命令行使用 hexo new 命令来创立新的md文件时会自动生成同名文件夹不需要手动另外创建。 4. 网站链接比起直接复制链接更好的方式是: 1[VS code](https:&#x2F;&#x2F;code.visualstudio.com&#x2F;) 前面写在文章中呈现的名字,后面写链接,这样直接点文字就可以进入链接。 5.强调使用如下命令就可以达到对某些文字强调的作用 1234*single asterisks*_single underscores_ **double asterisks**__double underscores__ single asteriskssingle underscoresdouble asterisksdouble underscores 总结学会这几个基本命令就差不多可以开始写博客了,至于其他更多的命令请参考Markdown中文版说明。希望大家写博客愉快! 上一步: 个人博客建设4-选择博客主题下一步: 个人博客建设6-主题的配置Next目录: 用GitHub搭建个人博客(目录)","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"个人博客建设4-选择博客主题","date":"2020-01-21T14:50:35.000Z","path":"2020/01/21/个人博客建设4-选择博客主题/","text":"个人博客建设第四步:选择一个自己喜欢的主题模板... 为什么使用模板因为简单快速,自己开发的话。。。就要系统学习了。总之关于模板的选择我们可以参考知乎的之一篇回答:有哪些好看的 Hexo 主题, 以及官网https://hexo.io/themes/。我选用的是我个人觉得还蛮好的Next主题,大致样子可以参照我现在的博客。 部署模板找到我们喜欢的模板后,在终端窗口下,定位到 Hexo 站点目录下,也就是blog文件夹内。使用 Git checkout 代码: 1$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next 等待下载完成后我们可以在站点目录下的themes看到多出来一个next文件夹,这就是我们的主题所在位置了。接着我们需要在站点配置文件里修改我们的主题(注意在我们的主题,也就是next文件夹里面也有一个同样名字的配置文件,那是主题配置文件,不要搞错了。) 把主题如图修改完成后,我们输入: 123hexo cleanhexo ghexo d 就可以部署我们新的主题上线了,当然也可以使用hexo server在本地查看主题的变化,不推送上线。我们可以下载不止一个模板来查看他们是否适合我们,只需要重复如上步骤下载主题到themes文件夹内,然后修改站点配置文件就行了。希望大家可以找到自己心仪的网站主题!!! 上一步: 个人博客建设3-申请并绑定域名下一步: 个人博客建设5-Markdown语法目录: 用GitHub搭建个人博客(目录)","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"个人博客建设3-申请并绑定域名","date":"2020-01-21T14:30:35.000Z","path":"2020/01/21/个人博客建设3-申请并绑定域名/","text":"个人博客建设第三步:申请并绑定域名... 阿里云申请域名为什么要申请一个域名?因为酷炫啊!这里可以在任何地方申请域名,现在大多数平台都有云解析服务所以无所谓。这里以阿里云举例子。 输入想要的域名然后搜索,可以选择还未被注册的域名。.com是国际域名.cn是国内域名,二者没有实质区别,当然也有些特别的选项… 买好域名后我们就要进行解析,登录阿里云后我们就可以开始解析了。 点进我们的域名后来到解析设置,添加两条A记录和一条CNAME记录(红圈),A记录的记录值是固定的192.30.252.153和190.30.252.154,为GitHub地址,CNAME记录为: 用户名.github.io 的形式。 这里A记录可实现将域名指向 IP 地址,当需要将域名指向另一个域名,再由另一个域名提供 IP 地址,就需要添加 CNAME 记录。 添加完记录后打开GitHub进入我们之前设置博客的仓库,点击settings(设置),我们拉到页面偏下方。 输入你申请的域名然后保存。 终于最后一步了,完成这步之后你的博客就可以通过域名访问了。冷静一下,我们打开本地保存博客的文件夹,进入source文件夹创建一个空白记事本在里面输入你申请的域名,然后把它保存为所有文件格式并且命名为CNAME。 然后常规操作g+d就可以使用自己的域名登录网站啦。 上一步: 个人博客建设2-安装并配置Node.js以及Hexo下一步: 个人博客建设4-选择博客主题目录: 用GitHub搭建个人博客(目录)","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"个人博客建设2:安装并配置Node.js以及Hexo","date":"2020-01-20T17:13:35.000Z","path":"2020/01/20/个人博客建设2-安装并配置Node.js以及Hexo/","text":"个人博客建设第二步:安装并配置所需框架和环境... 安装 Node.jsNode.js允许通过JavaScript和一系列模块来编写服务器端应用和网络相关的r应用。 我们通过官网https://nodejs.org/en/download/来选择合适的版本进行下载,并且安装。安装完成后再window命令行或者windows自带的powershell输入: 1node -v 出现对应版本号说明安装成功,npm会随着安装包自动安装,输入: 1npm -v 同样出现对应版本号说明安装成功。到这里就完成来了环境安装。 安装HexoHexo是一个快速、简洁且高效的博客框架。 Hexo使用Markdown解析文章,在几秒内,即可利用靓丽的主题生成静态网页。 第二步就是安装这个博客的框架,同样打开命令行输入: 1npm install -g hexo-cli 我们就开始安装Hexo了,等待他安装完后我们使用命令行移动到我们希望保存我们博客所有内容的文件夹内。 1cd &lt;当前目录下文件夹名字&gt; 使用如上命令就可以移动至我们希望博客项目保存的地方。 1hexo init blog 接着使用如上命令就可以初始化我们的博客项目了。至此我们就可以在本地看我们的网站雏形了。 123hexo new stest_my_sitehexo g hexo s 按照顺序输入如上命令,就会弹出提示,此时我们在浏览器访问localhost:4000就可以看见我们博客的雏形了。hexo s = hexo server 启动服务预览hexo g = hexo generate 生成其他hexo命令:hexo n “博客名称” =&gt; hexo new “博客名称” #这两个都是创建新文章,前者是简写模式hexo clean #清除缓存,网页正常情况下可以忽略此条命令hexo d =&gt; hexo deploy #部署网站上线 (推送到GitHub) 这时候我们可以看到blog文件夹内大致是图中的样子,这时候我们打开站点配置文件,可以使用Visual Studio Code来编辑。 我们翻到如图中的部署选项下,把之前在GitHub创建的库完整连接复制粘贴上并在结尾加上.git。(xxx.github.io.git )然后在命令行输入如下命令来安装部署模块, 1npm install hexo-deployer-git --save 然后常规操作g+s,就可以在浏览器通过访问xxx.github.io来进入个人主页了。但是这个似乎有点傻,这时候我们需要一个帅气的域名!于是下一篇就是:申请并绑定域名 上一步: 个人博客建设1-在GitHub创建一个仓库并配置Git 下一步: 个人博客建设3-申请并绑定域名 目录: 用GitHub搭建个人博客(目录)","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Git的几个基本指令","date":"2020-01-20T16:13:35.000Z","path":"2020/01/20/Git的几个基本指令/","text":"Git以及Git的几个最常用的指令,初步了解版本管理。 什么是Git以及为何使用Git?Git 是目前使用人数最多的版本管理工具。为什么会有Git呢?因为要版本控制。 举一个例子,小德要写论文那么他就可能要修改好几次,这时候比起在一个文件里修改小德可能会复制一个新的论文文件在新文件里修改。这时候就可能会有好几个版本的论文。其实平时使用的快捷键ctrl+z的撤回就是最简单的版本管理。 情况再复杂些,小德可能做的是一个小组作业,大家都有各自要做的部分,那么好玩的情况就是大家做完一部分后就要在微信或者邮箱里传来传去,而有了Git 一个团队就可以轻松合作。想要更加深入了解什么是Git 的可以访问 Ghosty Core 的博客。 Git 官网: https://git-scm.com/ Git 的基本操作1. 命令行基本操作(和Linux一样)123cd blog # 切换到当前目录下叫blog的文件夹cd .. # 退回上一级目录ls # 查看当前目录下所有文件和文件夹 12345678cd # 返回home目录~ls -ah # 查看当前目录下所有文件,文件夹以及隐藏文件pwd # 查看当前路径touch balabala.py # 在当前目录创建一个名字叫做balabala的python文件mkdir blog # 在当前目录创建一个叫blog的文件夹rm balabala.py # 删除该文件rm -r blog # 删除该文件夹mv &#123;src&#125; &#123;dest&#125; # 移动文件,如果 dest 是目录,则移动,是文件名则覆盖 要使用git掌握前三个可以把目录移到工作目录init就行了… 下面的作为补充, 万一哪天没有图形化界面只有个命令行呢。 2. 创建一个仓库,初始化1git init 在一个工作目录下输入后,就完成了初始化,可以看到隐藏文件有git文件夹。我们就有了一个仓库。 3. 查看目前状态1git status 会提示你当前库的状态,追踪的文件,未追踪的文件,做过修改未commit(注释)的文件。 4. 提交修改12git add &lt;file&gt; # 指定一个文件提交git add . # 提交所有当前目录下文件 修改文件完首先要把文件推送到staging index,选择要推送的文件或全部 5. commit(注释)123git commit -m &quot;descriptions&quot; # 直接注释git commit 打开编辑器进行注释git commit --amend 对最近一次的提交做内容修改 推送到staging index后需要添加注释,可以直接注释也可以选择自己喜欢的文本编辑器进行注释,Linux下的话可以是vim和nano等,Windows下可以是Notepad++等。注释完后文件就从staging index 推送到 repo仓库了。 6. 克隆GitHub远程仓库1git clone &lt;remote address&gt; 可以下载远程Github的仓库到本地,例如 1git clone https:&#x2F;&#x2F;github.com&#x2F;JasonVictor17&#x2F;Housing.git 就可以复制我的一个repo到本地了。 7. 关联并推送到Github远程仓库1234git remote add origin &lt;remote address&gt; 在本地工作区目录下按照 GitHub 提示进行关联git remote rm origin 解除错误关联git push -u origin master 第一次将本地仓库推送至远程仓库(每次在本地提交后进行操作)git push origin master 以后每次将本地仓库推送至远程仓库(每次在本地提交后进行操作) 第一步要把本地库关联到一个GitHub库,在GitHub创建新库时会有提示如何操作。第二步就是推送本地库到远程库,第一次操作有所不同以后都一样。 8.流程图至此,一个大致的结构就可以形成了。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"个人博客建设1:在GitHub创建一个仓库并配置Git","date":"2020-01-20T14:13:35.000Z","path":"2020/01/20/个人博客建设1-在GitHub创建一个仓库并配置Git/","text":"个人博客建设第一步:配置GitHub,安装Git Bash并配置Git... 首先什么是GitHub,以下是维基百科的定义:GitHub是通过Git进行版本控制的软件源代码托管服务平台。 那什么是Git?Git是一个分布式版本控制软件,最初由林纳斯·托瓦兹创作,于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。 看不懂没关系,只要会使用一样可以搭建个人博客。首先我们要创建一个GitHub的账号,网址:https://github.com/创建完后我们就需要创建一个新的库,具体如图: 点击Repositories 再点击 New,然后进入到下个界面: Repositories name 按照固定的格式写 username.github.io这里的username就是你注册时候的用户名,像我就是JasonVictor17 到这里Github就配置好了,我们接着下一个Git Bash到Windows系统以便使用Git,网址:https://git-scm.com/download/win 会自动下载 安装成功后需要配置Git Bash,打开Git bash我们看到命令行,输入: 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 然后生成一个SSH密钥 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 默认回车,然后系统会自动生成一个文件,然后在C盘user中找到.ssh文件夹(路径如图), 并复制其中id_rsa.pub的内容。然后打开 Github上的ssh key设置。 点击new ssh key后输入名称和复制的内容确认就可以了。 (如果找不到SSH密匙文件有两个办法:1. 下载GitHub桌面版就可以无需密匙 2. 下载一个小程序: everything 输入文件名字就可以查找)接着输入如图就成功配置完成了。 1ssh git@github.com 绑定SSH Key的目的是为了之后每次pull和push的时候不需要输入密码和账号,怪麻烦的。同时也避免一些可能产生的错误。 关于Git的基本使用请参考: Git的几个基本指令 下一步: 个人博客建设2-安装并配置Node.js以及Hexo目录: 用GitHub搭建个人博客(目录)","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Image Classifier with Deep learning","date":"2020-01-19T21:25:00.000Z","path":"2020/01/19/Image Classifier with Deep learning/","text":"Image Classifier with Deep learningGoing forward, AI algorithms will be incorporated into more and more everyday applications. For example, you might want to include an image classifier in a smart phone app. To do this, you’d use a deep learning model trained on hundreds of thousands of images as part of the overall application architecture. A large part of software development in the future will be using these types of models as common parts of applications. In this project, you’ll train an image classifier to recognize different species of flowers. You can imagine using something like this in a phone app that tells you the name of the flower your camera is looking at. In practice you’d train this classifier, then export it for use in your application. We’ll be using this dataset of 102 flower categories, you can see a few examples below. The project is broken down into multiple steps: Load and preprocess the image dataset Train the image classifier on your dataset Use the trained classifier to predict image content We’ll lead you through each part which you’ll implement in Python. When you’ve completed this project, you’ll have an application that can be trained on any set of labeled images. Here your network will be learning about flowers and end up as a command line application. But, what you do with your new skills depends on your imagination and effort in building a dataset. For example, imagine an app where you take a picture of a car, it tells you what the make and model is, then looks up information about it. Go build your own dataset and make something new. First up is importing the packages you’ll need. It’s good practice to keep all the imports at the beginning of your code. As you work through this notebook and find you need to import a package, make sure to add the import up here. 12345678910111213# Imports hereimport matplotlib.pyplot as pltimport torchfrom torchvision import datasets, transforms, modelsimport helperfrom collections import OrderedDictimport jsonimport numpy as npimport timefrom torch import nnfrom torch import optimimport seaborn as snsfrom PIL import Image Load the dataHere you’ll use torchvision to load the data (documentation). The data should be included alongside this notebook, otherwise you can download it here. The dataset is split into three parts, training, validation, and testing. For the training, you’ll want to apply transformations such as random scaling, cropping, and flipping. This will help the network generalize leading to better performance. You’ll also need to make sure the input data is resized to 224x224 pixels as required by the pre-trained networks. The validation and testing sets are used to measure the model’s performance on data it hasn’t seen yet. For this you don’t want any scaling or rotation transformations, but you’ll need to resize then crop the images to the appropriate size. The pre-trained networks you’ll use were trained on the ImageNet dataset where each color channel was normalized separately. For all three sets you’ll need to normalize the means and standard deviations of the images to what the network expects. For the means, it’s [0.485, 0.456, 0.406] and for the standard deviations [0.229, 0.224, 0.225], calculated from the ImageNet images. These values will shift each color channel to be centered at 0 and range from -1 to 1. 1234data_dir = 'flowers'train_dir = data_dir + '/train'valid_dir = data_dir + '/valid'test_dir = data_dir + '/test' 1234567891011121314151617181920212223242526272829303132# TODO: Define your transforms for the training, validation, and testing setstrain_transforms = transforms.Compose([transforms.RandomRotation(30), transforms.RandomResizedCrop(224), transforms.RandomHorizontalFlip(), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])]) valid_transforms = transforms.Compose([transforms.Resize(255), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])test_transforms = transforms.Compose([transforms.Resize(255), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])# TODO: Load the datasets with ImageFoldertrain_data = datasets.ImageFolder(train_dir, transform=train_transforms)valid_data = datasets.ImageFolder(valid_dir, transform=valid_transforms)test_data = datasets.ImageFolder(test_dir, transform=test_transforms)# TODO: Using the image datasets and the trainforms, define the dataloaderstrainloader = torch.utils.data.DataLoader(train_data, batch_size=64, shuffle=True)validloader = torch.utils.data.DataLoader(valid_data, batch_size=64)testloader = torch.utils.data.DataLoader(test_data, batch_size=64)image_datasets = [train_data, valid_data, test_data]dataloaders = [trainloader, validloader, testloader] Label mappingYou’ll also need to load in a mapping from category label to category name. You can find this in the file cat_to_name.json. It’s a JSON object which you can read in with the json module. This will give you a dictionary mapping the integer encoded categories to the actual names of the flowers. 1234with open('cat_to_name.json', 'r') as f: cat_to_name = json.load(f) Building and training the classifierNow that the data is ready, it’s time to build and train the classifier. As usual, you should use one of the pretrained models from torchvision.models to get the image features. Build and train a new feed-forward classifier using those features. We’re going to leave this part up to you. Refer to the rubric for guidance on successfully completing this section. Things you’ll need to do: Load a pre-trained network (If you need a starting point, the VGG networks work great and are straightforward to use) Define a new, untrained feed-forward network as a classifier, using ReLU activations and dropout Train the classifier layers using backpropagation using the pre-trained network to get the features Track the loss and accuracy on the validation set to determine the best hyperparameters We’ve left a cell open for you below, but use as many as you need. Our advice is to break the problem up into smaller parts you can run separately. Check that each part is doing what you expect, then move on to the next. You’ll likely find that as you work through each part, you’ll need to go back and modify your previous code. This is totally normal! When training make sure you’re updating only the weights of the feed-forward network. You should be able to get the validation accuracy above 70% if you build everything right. Make sure to try different hyperparameters (learning rate, units in the classifier, epochs, etc) to find the best model. Save those hyperparameters to use as default values in the next part of the project. One last important tip if you’re using the workspace to run your code: To avoid having your workspace disconnect during the long-running tasks in this notebook, please read in the earlier page in this lesson called Intro toGPU Workspaces about Keeping Your Session Active. You’ll want to include code from the workspace_utils.py module. Note for Workspace users: If your network is over 1 GB when saved as a checkpoint, there might be issues with saving backups in your workspace. Typically this happens with wide dense layers after the convolutional layers. If your saved checkpoint is larger than 1 GB (you can open a terminal and check with ls -lh), you should reduce the size of your hidden layers and train again. 1234567891011121314151617181920device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")# TODO: Build and train your networkmodel = models.vgg19(pretrained=True)# Freeze parameters so we don't backprop through themfor param in model.parameters(): param.requires_grad = False model.classifier = nn.Sequential(nn.Linear(25088, 2048), nn.ReLU(), nn.Dropout(0.25), nn.Linear(2048, 102), nn.LogSoftmax(dim=1))criterion = nn.NLLLoss()# Only train the classifier parameters, feature parameters are frozenoptimizer = optim.Adam(model.classifier.parameters(), lr=0.001)model VGG( (features): Sequential( (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU(inplace=True) (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (3): ReLU(inplace=True) (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (6): ReLU(inplace=True) (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (8): ReLU(inplace=True) (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (11): ReLU(inplace=True) (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (13): ReLU(inplace=True) (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (15): ReLU(inplace=True) (16): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (17): ReLU(inplace=True) (18): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (19): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (20): ReLU(inplace=True) (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (22): ReLU(inplace=True) (23): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (24): ReLU(inplace=True) (25): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (26): ReLU(inplace=True) (27): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (29): ReLU(inplace=True) (30): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (31): ReLU(inplace=True) (32): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (33): ReLU(inplace=True) (34): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (35): ReLU(inplace=True) (36): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) ) (avgpool): AdaptiveAvgPool2d(output_size=(7, 7)) (classifier): Sequential( (0): Linear(in_features=25088, out_features=2048, bias=True) (1): ReLU() (2): Dropout(p=0.25, inplace=False) (3): Linear(in_features=2048, out_features=102, bias=True) (4): LogSoftmax() ) )1model.to(device) 123456789101112131415161718192021222324252627282930313233343536373839404142434445epochs = 8steps = 0running_loss = 0print_every = 50start = time.time()for e in range(epochs): for inputs, labels in trainloader: steps += 1 inputs, labels = inputs.to(device), labels.to(device) optimizer.zero_grad() logps = model.forward(inputs) loss = criterion(logps, labels) loss.backward() optimizer.step() running_loss += loss.item() if steps % print_every == 0: test_loss = 0 accuracy = 0 model.eval() with torch.no_grad(): for inputs, labels in validloader: inputs, labels = inputs.to(device), labels.to(device) logps = model.forward(inputs) batch_loss = criterion(logps, labels) test_loss += batch_loss.item() # Calculate accuracy ps = torch.exp(logps) top_p, top_class = ps.topk(1, dim=1) equals = top_class == labels.view(*top_class.shape) accuracy += torch.mean(equals.type(torch.FloatTensor)).item() print(\"Epoch: &#123;&#125;/&#123;&#125;.. \".format(e+1, epochs), f\"Train loss: &#123;running_loss/print_every:.3f&#125;.. \" f\"Valid loss: &#123;test_loss/len(validloader):.3f&#125;.. \" f\"Valid accuracy: &#123;accuracy/len(validloader):.3f&#125;\") running_loss = 0 model.train()time_end = time.time() - startprint(\"\\nTotal time: &#123;:.0f&#125;m &#123;:.0f&#125;s\".format(time_end//60, time_end % 60)) Epoch: 1/8.. Train loss: 3.569.. Valid loss: 1.455.. Valid accuracy: 0.612 Epoch: 1/8.. Train loss: 1.689.. Valid loss: 0.859.. Valid accuracy: 0.768 Epoch: 2/8.. Train loss: 1.296.. Valid loss: 0.759.. Valid accuracy: 0.784 Epoch: 2/8.. Train loss: 1.181.. Valid loss: 0.720.. Valid accuracy: 0.800 Epoch: 3/8.. Train loss: 1.054.. Valid loss: 0.655.. Valid accuracy: 0.809 Epoch: 3/8.. Train loss: 1.020.. Valid loss: 0.517.. Valid accuracy: 0.839 Epoch: 4/8.. Train loss: 0.988.. Valid loss: 0.487.. Valid accuracy: 0.850 Epoch: 4/8.. Train loss: 0.932.. Valid loss: 0.596.. Valid accuracy: 0.832 Epoch: 5/8.. Train loss: 0.893.. Valid loss: 0.517.. Valid accuracy: 0.857 Epoch: 5/8.. Train loss: 0.854.. Valid loss: 0.493.. Valid accuracy: 0.870 Epoch: 6/8.. Train loss: 0.790.. Valid loss: 0.508.. Valid accuracy: 0.861 Epoch: 6/8.. Train loss: 0.806.. Valid loss: 0.491.. Valid accuracy: 0.873 Epoch: 7/8.. Train loss: 0.806.. Valid loss: 0.565.. Valid accuracy: 0.861 Epoch: 7/8.. Train loss: 0.825.. Valid loss: 0.449.. Valid accuracy: 0.887 Epoch: 8/8.. Train loss: 0.734.. Valid loss: 0.453.. Valid accuracy: 0.882 Epoch: 8/8.. Train loss: 0.773.. Valid loss: 0.539.. Valid accuracy: 0.860 Total time: 14m 39s12 Testing your networkIt’s good practice to test your trained network on test data, images the network has never seen either in training or validation. This will give you a good estimate for the model’s performance on completely new images. Run the test images through the network and measure the accuracy, the same way you did validation. You should be able to reach around 70% accuracy on the test set if the model has been trained well. 1234567891011121314151617# TODO: Do validation on the test setmodel.eval()accuracy = 0with torch.no_grad(): for inputs, labels in testloader: inputs, labels = inputs.to(device), labels.to(device) logps = model.forward(inputs) batch_loss = criterion(logps, labels) test_loss += batch_loss.item() # Calculate accuracy ps = torch.exp(logps) top_p, top_class = ps.topk(1, dim=1) equals = top_class == labels.view(*top_class.shape) accuracy += torch.mean(equals.type(torch.FloatTensor)).item()print(f\"Valid accuracy: &#123;accuracy/len(testloader):.3f&#125;\") Valid accuracy: 0.854Save the checkpointNow that your network is trained, save the model so you can load it later for making predictions. You probably want to save other things such as the mapping of classes to indices which you get from one of the image datasets: image_datasets[&#39;train&#39;].class_to_idx. You can attach this to the model as an attribute which makes inference easier later on. 123456789101112131415161718192021Remember that you&#39;ll want to completely rebuild the model later so you can use it for inference. Make sure to include any information you need in the checkpoint. If you want to load the model and keep training, you&#39;ll want to save the number of epochs as well as the optimizer state, &#96;optimizer.state_dict&#96;. You&#39;ll likely want to use this trained model in the next part of the project, so best to save it now.&#96;&#96;&#96;python# TODO: Save the checkpoint classifier &#x3D; nn.Sequential(nn.Linear(25088, 2048), nn.ReLU(), nn.Dropout(0.25), nn.Linear(2048, 102), nn.LogSoftmax(dim&#x3D;1))model.class_to_idx &#x3D; image_datasets[0].class_to_idxcheckpoint &#x3D; &#123;&#39;input_size&#39;: 25088, &#39;output_size&#39;: 102, &#39;classifier&#39; : classifier, &#39;arch&#39;: &#39;vgg19&#39;, &#39;optimizer&#39;: optimizer.state_dict(), &#39;state_dict&#39;: model.state_dict(), &#39;class_to_idx&#39;: model.class_to_idx&#125;torch.save(checkpoint, &#39;checkpoint.pth&#39;) Loading the checkpointAt this point it’s good to write a function that can load a checkpoint and rebuild the model. That way you can come back to this project and keep working on it without having to retrain the network. 123456789101112# TODO: Write a function that loads a checkpoint and rebuilds the modeldef load_checkpoint(filepath): checkpoints = torch.load(filepath) model = models.vgg19(pretrained=True) model.class_to_idx = checkpoints['class_to_idx'] model.classifier = checkpoints['classifier'] model.load_state_dict(checkpoints['state_dict']) optimizer.load_state_dict(checkpoints['optimizer']) return model 12model = load_checkpoint('checkpoint.pth')print(model) VGG( (features): Sequential( (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): ReLU(inplace=True) (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (3): ReLU(inplace=True) (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (6): ReLU(inplace=True) (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (8): ReLU(inplace=True) (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (11): ReLU(inplace=True) (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (13): ReLU(inplace=True) (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (15): ReLU(inplace=True) (16): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (17): ReLU(inplace=True) (18): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (19): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (20): ReLU(inplace=True) (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (22): ReLU(inplace=True) (23): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (24): ReLU(inplace=True) (25): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (26): ReLU(inplace=True) (27): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (29): ReLU(inplace=True) (30): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (31): ReLU(inplace=True) (32): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (33): ReLU(inplace=True) (34): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (35): ReLU(inplace=True) (36): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) ) (avgpool): AdaptiveAvgPool2d(output_size=(7, 7)) (classifier): Sequential( (0): Linear(in_features=25088, out_features=2048, bias=True) (1): ReLU() (2): Dropout(p=0.25, inplace=False) (3): Linear(in_features=2048, out_features=102, bias=True) (4): LogSoftmax() ) )12 Inference for classificationNow you’ll write a function to use a trained network for inference. That is, you’ll pass an image into the network and predict the class of the flower in the image. Write a function called predict that takes an image and a model, then returns the top $K$ most likely classes along with the probabilities. It should look like 12345probs, classes = predict(image_path, model)print(probs)print(classes)&gt; [ 0.01558163 0.01541934 0.01452626 0.01443549 0.01407339]&gt; ['70', '3', '45', '62', '55'] First you’ll need to handle processing the input image such that it can be used in your network. Image PreprocessingYou’ll want to use PIL to load the image (documentation). It’s best to write a function that preprocesses the image so it can be used as input for the model. This function should process the images in the same manner used for training. First, resize the images where the shortest side is 256 pixels, keeping the aspect ratio. This can be done with the thumbnail or resize methods. Then you’ll need to crop out the center 224x224 portion of the image. Color channels of images are typically encoded as integers 0-255, but the model expected floats 0-1. You’ll need to convert the values. It’s easiest with a Numpy array, which you can get from a PIL image like so np_image = np.array(pil_image). As before, the network expects the images to be normalized in a specific way. For the means, it’s [0.485, 0.456, 0.406] and for the standard deviations [0.229, 0.224, 0.225]. You’ll want to subtract the means from each color channel, then divide by the standard deviation. And finally, PyTorch expects the color channel to be the first dimension but it’s the third dimension in the PIL image and Numpy array. You can reorder dimensions using ndarray.transpose. The color channel needs to be first and retain the order of the other two dimensions. 12345678910111213# TODO: Process a PIL image for use in a PyTorch modeldef process_image(image): ''' Scales, crops, and normalizes a PIL image for a PyTorch model, returns an Numpy array ''' im = Image.open(image) im = im.resize((256,256)) transform = transforms.Compose([transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])]) im = transform(im) return im To check your work, the function below converts a PyTorch tensor and displays it in the notebook. If your process_image function works, running the output through this function should return the original image (except for the cropped out portions). 1234567891011121314151617181920def imshow(image, ax=None, title=None): \"\"\"Imshow for Tensor.\"\"\" if ax is None: fig, ax = plt.subplots() # PyTorch tensors assume the color channel is the first dimension # but matplotlib assumes is the third dimension image = image.numpy().transpose((1, 2, 0)) # Undo preprocessing mean = np.array([0.485, 0.456, 0.406]) std = np.array([0.229, 0.224, 0.225]) image = std * image + mean # Image needs to be clipped between 0 and 1 or it looks like noise when displayed image = np.clip(image, 0, 1) ax.imshow(image) return ax 1234# Show original picsimage_path = test_dir + '/17/image_03911.jpg'pic = Image.open(image_path)pic 123# Show processed picspic_process = process_image(image_path)imshow(pic_process) &lt;matplotlib.axes._subplots.AxesSubplot at 0x2ae83fbbf08&gt; Class PredictionOnce you can get images in the correct format, it’s time to write a function for making predictions with your model. A common practice is to predict the top 5 or so (usually called top-$K$) most probable classes. You’ll want to calculate the class probabilities then find the $K$ largest values. To get the top $K$ largest values in a tensor use x.topk(k). This method returns both the highest k probabilities and the indices of those probabilities corresponding to the classes. You need to convert from these indices to the actual class labels using class_to_idx which hopefully you added to the model or from an ImageFolder you used to load the data (see here). Make sure to invert the dictionary so you get a mapping from index to class as well. Again, this method should take a path to an image and a model checkpoint, then return the probabilities and classes. 12345probs, classes = predict(image_path, model)print(probs)print(classes)&gt; [ 0.01558163 0.01541934 0.01452626 0.01443549 0.01407339]&gt; ['70', '3', '45', '62', '55'] 123456789101112131415161718def predict(image_path, model, topk=5): ''' Predict the class (or classes) of an image using a trained deep learning model. ''' processed_image = process_image(image_path) processed_image.unsqueeze_(0) probs = torch.exp(model.forward(processed_image)) top_probs, top_index = probs.topk(topk) top_index = top_index[0].numpy() index = [] for i in range(len(model.class_to_idx.items())): index.append(list(model.class_to_idx.items())[i][0]) label = [] for i in range(5): label.append(index[top_index[i]]) return top_probs, label 12img_path = test_dir + '/17/image_03911.jpg'predict(img_path, model, topk=5) (tensor([[9.8274e-01, 1.6505e-02, 3.9908e-04, 1.0707e-04, 9.1983e-05]], grad_fn=&lt;TopkBackward&gt;), [&apos;17&apos;, &apos;100&apos;, &apos;18&apos;, &apos;34&apos;, &apos;92&apos;])Sanity CheckingNow that you can use a trained model for predictions, check to make sure it makes sense. Even if the testing accuracy is high, it’s always good to check that there aren’t obvious bugs. Use matplotlib to plot the probabilities for the top 5 classes as a bar graph, along with the input image. It should look like this: You can convert from the class integer encoding to actual flower names with the cat_to_name.json file (should have been loaded earlier in the notebook). To show a PyTorch tensor as an image, use the imshow function defined above. 123456# TODO: Display an image along with the top 5 classesprob, classes = predict(img_path, model)prob = prob[0].detach().numpy()labels = []for each in classes: labels.append(cat_to_name[each]) 12345678910plt.figure(figsize = (8,8))ax = plt.subplot(2,1,1)flower_num = img_path.split('/')[2] # find the index of the flowertitle= cat_to_name[flower_num] img = process_image(img_path)plt.title(title)imshow(img, ax)plt.subplot(2,1,2)sns.barplot(prob, y=labels)plt.show() 123456789101112131415# test a flower pic outside the datasetimg_path = 'C:\\\\Users\\\\jasonguo\\\\Desktop\\\\flowers_zwy\\\\11.JPG'prob, classes = predict(img_path, model)prob = prob[0].detach().numpy()labels = []for each in classes: labels.append(cat_to_name[each])plt.figure(figsize = (8,8))ax = plt.subplot(2,1,1)img = process_image(img_path)imshow(img, ax)plt.subplot(2,1,2)sns.barplot(prob, y=labels)plt.show()# wihch is exactly true","comments":true,"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"用GitHub搭建个人博客(目录)","date":"2020-01-19T17:13:35.000Z","path":"2020/01/19/用GitHub搭建个人博客/","text":"快速上手使用GitHub+Hexo建立博客,适合新手。 系统环境:Windows 本文是目录篇,包含了所有关于使用GitHub+Hexo建立博客的相关教程。会逐渐更新。。。 首先为什么使用GitHub+Hexo建立博客1. 优点 不需要服务器省钱省时间呀(主要原因) 适合新手以及对建站不熟悉的小白(本人) 有很多现成精美模板 无流量限制 2. 缺点 个性化空间小 静态页面(虽然博客以及足矣) 没有数据库,不适合大型网站,运行一次就要遍历所有网站内容 总之就是非常适合做个人博客就对了。 完成这个博客项目你需要: 非常基础的Git知识,熟悉命令行(参照文末辅助资料) 喜欢折腾 耐心 目录 个人博客建设1-在GitHub创建一个仓库并配置Git 个人博客建设2-安装并配置Node.js以及Hexo 个人博客建设3-申请并绑定域名 个人博客建设4-选择博客主题 个人博客建设5-Markdown语法 个人博客建设6-主题的配置Next 其他辅助资料 Git的几个基本指令 Hexo 如何优雅的加入Rmarkdown生成的html/pdf文件","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}]