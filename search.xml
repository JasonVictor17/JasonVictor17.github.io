<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一个python package -- actupac</title>
    <url>/2020/02/20/actupac_package/</url>
    <content><![CDATA[<font size="3">
一个自己做的精算python包,实现内推和外推利率,并且画出利率曲线。该篇是使用说明和例子。

<a id="more"></a>
<hr>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>actupac 是一个精算的python包,目前的功能是内推和外推利率,并且画出利率曲线。</p>
<h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install actupac</span><br></pre></td></tr></table></figure>

<pre><code>Collecting actupac
  Downloading https://files.pythonhosted.org/packages/78/6d/100b147d64d2b2653f93818af3da6013f23b53120bdc66e1092133500ff3/actupac-0.1.tar.gz
Building wheels for collected packages: actupac
  Building wheel for actupac (setup.py): started
  Building wheel for actupac (setup.py): finished with status &apos;done&apos;
  Created wheel for actupac: filename=actupac-0.1-cp37-none-any.whl size=5979 sha256=7eb4984f5edbdd2af0de32a2fb795215bc159ce70f39eb398dead35d5f97950f
  Stored in directory: C:\Users\jasonguo\AppData\Local\pip\Cache\wheels\83\19\8e\472924dcac472b470f64c7e2fdd5553ea1af6857d213253170
Successfully built actupac
Installing collected packages: actupac
Successfully installed actupac-0.1
Note: you may need to restart the kernel to use updated packages.</code></pre><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> actupac <span class="keyword">import</span> Interpolation</span><br><span class="line"><span class="keyword">from</span> actupac <span class="keyword">import</span> Extrapolation</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-内推"><a href="#1-内推" class="headerlink" title="1. 内推"></a>1. 内推</h3><p>目前有三种方法:piecewise linear, piecewise constant, 以及 cubic spline。 其中 cubic spline 使用两端二次导为零的方法,所以是natural spline。</p>
<p>数据需要存储在csv格式文件中,第一列为年份,第二列为利率即可,不需要列名等。</p>
<p>可以改变的参数是内推点的个数,以下以9个点为例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read the dataset</span></span><br><span class="line">sample = Interpolation()</span><br><span class="line">df = sample.read_data(<span class="string">'interest.csv'</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Years</th>
      <th>Yields</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1.129</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
      <td>1.224</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>1.364</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>1.540</td>
    </tr>
    <tr>
      <td>4</td>
      <td>5</td>
      <td>1.707</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate means and standard deviation and discount rates</span></span><br><span class="line">print(sample.mean)</span><br><span class="line">print(sample.stdev)</span><br><span class="line">discount = sample.discount_rate()</span><br><span class="line">discount[<span class="number">0</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<pre><code>2.3666
0.492





[0.9887734928804884,
 0.9758172050673466,
 0.9599059193497299,
 0.9402589151464628,
 0.9181908613542313]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plot the distribution of the dataset</span></span><br><span class="line">sample.plot_histogram()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/20/actupac_package/output_11_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interpolate with piecewise linear model with 9 interpolated points between each known year</span></span><br><span class="line">linear = sample.piecewise_linear(<span class="number">9</span>)</span><br><span class="line">print(linear.head())</span><br><span class="line">sample.piecewise_linear_plot()</span><br></pre></td></tr></table></figure>

<pre><code>   Years  Yields        Pt        Ft
0    1.0  1.1290  0.988773  1.234261
1    1.1  1.1385  0.987555  1.253285
2    1.2  1.1480  0.986318  1.272309
3    1.3  1.1575  0.985065  1.291333
4    1.4  1.1670  0.983795  1.310358</code></pre><p><img src="/2020/02/20/actupac_package/output_12_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interpolate with piecewise constant model with 9 interpolated points between each known year</span></span><br><span class="line">constant = sample.piecewise_constant(<span class="number">9</span>)</span><br><span class="line">print(constant.head())</span><br><span class="line">sample.piecewise_constant_plot()</span><br></pre></td></tr></table></figure>

<pre><code>   Years    Yields        Pt       Ft
0    1.0  1.129000  0.988773  1.31987
1    1.1  1.146273  0.987470  1.31987
2    1.2  1.160667  0.986169  1.31987
3    1.3  1.172846  0.984869  1.31987
4    1.4  1.183286  0.983570  1.31987</code></pre><p><img src="/2020/02/20/actupac_package/output_13_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interpolate with cubic spline (natural spline) model with 9 interpolated points between each known year</span></span><br><span class="line">cubic = sample.cubic(<span class="number">9</span>)</span><br><span class="line">print(cubic.head())</span><br><span class="line">sample.cubic_plot()</span><br></pre></td></tr></table></figure>

<pre><code>   Years    Yields        Pt        Ft
0    1.0  1.129000  0.988773  1.224226
1    1.1  1.137589  0.987564  1.242089
2    1.2  1.146233  0.986339  1.260836
3    1.3  1.154987  0.985097  1.280690
4    1.4  1.163908  0.983837  1.301870</code></pre><p><img src="/2020/02/20/actupac_package/output_14_1.png" alt="png"></p>
<h3 id="2-外推"><a href="#2-外推" class="headerlink" title="2.  外推"></a>2.  外推</h3><p>目前只有 Smith Wilson 方法进行同时外推和内推, 需要手动输入已知数据创建为列表形式即可。 可变参数有三个,n是步长,0.1代表0.1年为一个步长;max_year是外推的最大年份, UFR 是 Ultimate forward rate 可以根据需要改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = list([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span>])</span><br><span class="line">b = list([<span class="number">3.2870</span>,<span class="number">3.1280</span>,<span class="number">3.2240</span>,<span class="number">3.3680</span>,<span class="number">3.4710</span>,<span class="number">3.9860</span>,<span class="number">4.2070</span>,<span class="number">4.0540</span>,<span class="number">3.4320</span>,<span class="number">2.9310</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read the data and creat a dataframe</span></span><br><span class="line">sample2 = Extrapolation(a,b)</span><br><span class="line">sample2.dataframe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Years</th>
      <th>Yields</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1.0</td>
      <td>3.287</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2.0</td>
      <td>3.128</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3.0</td>
      <td>3.224</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4.0</td>
      <td>3.368</td>
    </tr>
    <tr>
      <td>4</td>
      <td>5.0</td>
      <td>3.471</td>
    </tr>
    <tr>
      <td>5</td>
      <td>10.0</td>
      <td>3.986</td>
    </tr>
    <tr>
      <td>6</td>
      <td>15.0</td>
      <td>4.207</td>
    </tr>
    <tr>
      <td>7</td>
      <td>20.0</td>
      <td>4.054</td>
    </tr>
    <tr>
      <td>8</td>
      <td>30.0</td>
      <td>3.432</td>
    </tr>
    <tr>
      <td>9</td>
      <td>50.0</td>
      <td>2.931</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># results </span></span><br><span class="line">sample2.Smith_Wilson(n=<span class="number">0.1</span>,max_year=<span class="number">70</span>,UFR=<span class="number">4.2</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Years</th>
      <th>Yields</th>
      <th>Discount rates</th>
      <th>Forward rates</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>1.000000</td>
      <td>3.401529</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0.1</td>
      <td>3.395757</td>
      <td>0.996610</td>
      <td>3.395344</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0.2</td>
      <td>3.392675</td>
      <td>0.993238</td>
      <td>3.382345</td>
    </tr>
    <tr>
      <td>3</td>
      <td>0.3</td>
      <td>3.387329</td>
      <td>0.989889</td>
      <td>3.362554</td>
    </tr>
    <tr>
      <td>4</td>
      <td>0.4</td>
      <td>3.379725</td>
      <td>0.986572</td>
      <td>3.335994</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>696</td>
      <td>69.6</td>
      <td>3.151262</td>
      <td>0.111550</td>
      <td>4.059759</td>
    </tr>
    <tr>
      <td>697</td>
      <td>69.7</td>
      <td>3.152554</td>
      <td>0.111099</td>
      <td>4.061264</td>
    </tr>
    <tr>
      <td>698</td>
      <td>69.8</td>
      <td>3.153844</td>
      <td>0.110650</td>
      <td>4.062754</td>
    </tr>
    <tr>
      <td>699</td>
      <td>69.9</td>
      <td>3.155132</td>
      <td>0.110202</td>
      <td>4.064228</td>
    </tr>
    <tr>
      <td>700</td>
      <td>70.0</td>
      <td>3.156419</td>
      <td>0.109756</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>701 rows × 4 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plots</span></span><br><span class="line">sample2.Smith_Wilson_plot()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/20/actupac_package/output_20_0.png" alt="png"></p>
</font>]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>精算</tag>
      </tags>
  </entry>
  <entry>
    <title>Identify Customer Segments</title>
    <url>/2020/02/05/Identify_Customer_Segments/</url>
    <content><![CDATA[<font size="3">
Identify segments of the population that form the core customer base for a mail-order sales company in Germany. These segments can then be used to direct marketing campaigns towards audiences that will have the highest expected rate of returns.

<a id="more"></a>
<hr>
<h1 id="Project-Identify-Customer-Segments"><a href="#Project-Identify-Customer-Segments" class="headerlink" title="Project: Identify Customer Segments"></a>Project: Identify Customer Segments</h1><p>In this project, you will apply unsupervised learning techniques to identify segments of the population that form the core customer base for a mail-order sales company in Germany. These segments can then be used to direct marketing campaigns towards audiences that will have the highest expected rate of returns. The data that you will use has been provided by our partners at Bertelsmann Arvato Analytics, and represents a real-life data science task.</p>
<p>This notebook will help you complete this task by providing a framework within which you will perform your analysis steps. In each step of the project, you will see some text describing the subtask that you will perform, followed by one or more code cells for you to complete your work. <strong>Feel free to add additional code and markdown cells as you go along so that you can explore everything in precise chunks.</strong> The code cells provided in the base template will outline only the major tasks, and will usually not be enough to cover all of the minor tasks that comprise it.</p>
<p>It should be noted that while there will be precise guidelines on how you should handle certain tasks in the project, there will also be places where an exact specification is not provided. <strong>There will be times in the project where you will need to make and justify your own decisions on how to treat the data.</strong> These are places where there may not be only one way to handle the data. In real-life tasks, there may be many valid ways to approach an analysis task. One of the most important things you can do is clearly document your approach so that other scientists can understand the decisions you’ve made.</p>
<p>At the end of most sections, there will be a Markdown cell labeled <strong>Discussion</strong>. In these cells, you will report your findings for the completed section, as well as document the decisions that you made in your approach to each subtask. <strong>Your project will be evaluated not just on the code used to complete the tasks outlined, but also your communication about your observations and conclusions at each stage.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import libraries here; add more as necessary</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="comment"># magic word for producing visualizations in notebook</span></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>

<h3 id="Step-0-Load-the-Data"><a href="#Step-0-Load-the-Data" class="headerlink" title="Step 0: Load the Data"></a>Step 0: Load the Data</h3><p>There are four files associated with this project (not including this one):</p>
<ul>
<li><code>Udacity_AZDIAS_Subset.csv</code>: Demographics data for the general population of Germany; 891211 persons (rows) x 85 features (columns).</li>
<li><code>Udacity_CUSTOMERS_Subset.csv</code>: Demographics data for customers of a mail-order company; 191652 persons (rows) x 85 features (columns).</li>
<li><code>Data_Dictionary.md</code>: Detailed information file about the features in the provided datasets.</li>
<li><code>AZDIAS_Feature_Summary.csv</code>: Summary of feature attributes for demographics data; 85 features (rows) x 4 columns</li>
</ul>
<p>Each row of the demographics files represents a single person, but also includes information outside of individuals, including information about their household, building, and neighborhood. You will use this information to cluster the general population into groups with similar demographic properties. Then, you will see how the people in the customers dataset fit into those created clusters. The hope here is that certain clusters are over-represented in the customers data, as compared to the general population; those over-represented clusters will be assumed to be part of the core userbase. This information can then be used for further applications, such as targeting for a marketing campaign.</p>
<p>To start off with, load in the demographics data for the general population into a pandas DataFrame, and do the same for the feature attributes summary. Note for all of the <code>.csv</code> data files in this project: they’re semicolon (<code>;</code>) delimited, so you’ll need an additional argument in your <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html" target="_blank" rel="noopener"><code>read_csv()</code></a> call to read in the data properly. Also, considering the size of the main dataset, it may take some time for it to load completely.</p>
<p>Once the dataset is loaded, it’s recommended that you take a little bit of time just browsing the general structure of the dataset and feature summary file. You’ll be getting deep into the innards of the cleaning in the first major step of the project, so gaining some general familiarity can help you get your bearings.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load in the general demographics data.</span></span><br><span class="line">azdias = pd.read_csv(<span class="string">'Udacity_AZDIAS_Subset.csv'</span>,sep=<span class="string">';'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load in the feature summary file.</span></span><br><span class="line">feat_info = pd.read_csv(<span class="string">'AZDIAS_Feature_Summary.csv'</span>,sep=<span class="string">';'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Check the structure of the data after it's loaded (e.g. print the number of</span></span><br><span class="line"><span class="comment"># rows and columns, print the first few rows).</span></span><br><span class="line"><span class="comment"># Info for general demographics data.</span></span><br><span class="line">print(<span class="string">"Total number of rows: &#123;&#125;"</span>.format(azdias.shape[<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"Total number of columns: &#123;&#125;"</span>.format(azdias.shape[<span class="number">1</span>]))</span><br><span class="line">azdias.head()</span><br></pre></td></tr></table></figure>

<pre><code>Total number of rows: 891221
Total number of columns: 85</code></pre><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AGER_TYP</th>
      <th>ALTERSKATEGORIE_GROB</th>
      <th>ANREDE_KZ</th>
      <th>CJT_GESAMTTYP</th>
      <th>FINANZ_MINIMALIST</th>
      <th>FINANZ_SPARER</th>
      <th>FINANZ_VORSORGER</th>
      <th>FINANZ_ANLEGER</th>
      <th>FINANZ_UNAUFFAELLIGER</th>
      <th>FINANZ_HAUSBAUER</th>
      <th>...</th>
      <th>PLZ8_ANTG1</th>
      <th>PLZ8_ANTG2</th>
      <th>PLZ8_ANTG3</th>
      <th>PLZ8_ANTG4</th>
      <th>PLZ8_BAUMAX</th>
      <th>PLZ8_HHZ</th>
      <th>PLZ8_GBZ</th>
      <th>ARBEIT</th>
      <th>ORTSGR_KLS9</th>
      <th>RELAT_AB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>-1</td>
      <td>2</td>
      <td>1</td>
      <td>2.0</td>
      <td>3</td>
      <td>4</td>
      <td>3</td>
      <td>5</td>
      <td>5</td>
      <td>3</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <td>1</td>
      <td>-1</td>
      <td>1</td>
      <td>2</td>
      <td>5.0</td>
      <td>1</td>
      <td>5</td>
      <td>2</td>
      <td>5</td>
      <td>4</td>
      <td>5</td>
      <td>...</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>2.0</td>
      <td>1.0</td>
      <td>1.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <td>2</td>
      <td>-1</td>
      <td>3</td>
      <td>2</td>
      <td>3.0</td>
      <td>1</td>
      <td>4</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>5</td>
      <td>...</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
      <td>4</td>
      <td>2</td>
      <td>2.0</td>
      <td>4</td>
      <td>2</td>
      <td>5</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
      <td>...</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>0.0</td>
      <td>1.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td>4</td>
      <td>-1</td>
      <td>3</td>
      <td>1</td>
      <td>5.0</td>
      <td>4</td>
      <td>3</td>
      <td>4</td>
      <td>1</td>
      <td>3</td>
      <td>2</td>
      <td>...</td>
      <td>2.0</td>
      <td>4.0</td>
      <td>2.0</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>6.0</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 85 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># info for the feature summary file</span></span><br><span class="line">print(<span class="string">"Total number of rows: &#123;&#125;"</span>.format(feat_info.shape[<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"Total number of columns: &#123;&#125;"</span>.format(feat_info.shape[<span class="number">1</span>]))</span><br><span class="line">feat_info.head()</span><br></pre></td></tr></table></figure>

<pre><code>Total number of rows: 85
Total number of columns: 4</code></pre><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>attribute</th>
      <th>information_level</th>
      <th>type</th>
      <th>missing_or_unknown</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>AGER_TYP</td>
      <td>person</td>
      <td>categorical</td>
      <td>[-1,0]</td>
    </tr>
    <tr>
      <td>1</td>
      <td>ALTERSKATEGORIE_GROB</td>
      <td>person</td>
      <td>ordinal</td>
      <td>[-1,0,9]</td>
    </tr>
    <tr>
      <td>2</td>
      <td>ANREDE_KZ</td>
      <td>person</td>
      <td>categorical</td>
      <td>[-1,0]</td>
    </tr>
    <tr>
      <td>3</td>
      <td>CJT_GESAMTTYP</td>
      <td>person</td>
      <td>categorical</td>
      <td>[0]</td>
    </tr>
    <tr>
      <td>4</td>
      <td>FINANZ_MINIMALIST</td>
      <td>person</td>
      <td>ordinal</td>
      <td>[-1]</td>
    </tr>
  </tbody>
</table>
</div>



<blockquote>
<p><strong>Tip</strong>: Add additional cells to keep everything in reasonably-sized chunks! Keyboard shortcut <code>esc --&gt; a</code> (press escape to enter command mode, then press the ‘A’ key) adds a new cell before the active cell, and <code>esc --&gt; b</code> adds a new cell after the active cell. If you need to convert an active cell to a markdown cell, use <code>esc --&gt; m</code> and to convert to a code cell, use <code>esc --&gt; y</code>. </p>
</blockquote>
<h2 id="Step-1-Preprocessing"><a href="#Step-1-Preprocessing" class="headerlink" title="Step 1: Preprocessing"></a>Step 1: Preprocessing</h2><h3 id="Step-1-1-Assess-Missing-Data"><a href="#Step-1-1-Assess-Missing-Data" class="headerlink" title="Step 1.1: Assess Missing Data"></a>Step 1.1: Assess Missing Data</h3><p>The feature summary file contains a summary of properties for each demographics data column. You will use this file to help you make cleaning decisions during this stage of the project. First of all, you should assess the demographics data in terms of missing data. Pay attention to the following points as you perform your analysis, and take notes on what you observe. Make sure that you fill in the <strong>Discussion</strong> cell with your findings and decisions at the end of each step that has one!</p>
<h4 id="Step-1-1-1-Convert-Missing-Value-Codes-to-NaNs"><a href="#Step-1-1-1-Convert-Missing-Value-Codes-to-NaNs" class="headerlink" title="Step 1.1.1: Convert Missing Value Codes to NaNs"></a>Step 1.1.1: Convert Missing Value Codes to NaNs</h4><p>The fourth column of the feature attributes summary (loaded in above as <code>feat_info</code>) documents the codes from the data dictionary that indicate missing or unknown data. While the file encodes this as a list (e.g. <code>[-1,0]</code>), this will get read in as a string object. You’ll need to do a little bit of parsing to make use of it to identify and clean the data. Convert data that matches a ‘missing’ or ‘unknown’ value code into a numpy NaN value. You might want to see how much data takes on a ‘missing’ or ‘unknown’ code, and how much data is naturally missing, as a point of interest.</p>
<p><strong>As one more reminder, you are encouraged to add additional cells to break up your analysis into manageable chunks.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># How much data is naturally missing in the dataset for each column.</span></span><br><span class="line">nature_missing = azdias.isna().sum()</span><br><span class="line">nature_missing[nature_missing != <span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>CJT_GESAMTTYP            4854
GFK_URLAUBERTYP          4854
LP_LEBENSPHASE_FEIN      4854
LP_LEBENSPHASE_GROB      4854
LP_FAMILIE_FEIN          4854
LP_FAMILIE_GROB          4854
LP_STATUS_FEIN           4854
LP_STATUS_GROB           4854
RETOURTYP_BK_S           4854
SOHO_KZ                 73499
TITEL_KZ                73499
ALTER_HH                73499
ANZ_PERSONEN            73499
ANZ_TITEL               73499
HH_EINKOMMEN_SCORE      18348
KK_KUNDENTYP           584612
W_KEIT_KIND_HH         107602
WOHNDAUER_2008          73499
ANZ_HAUSHALTE_AKTIV     93148
ANZ_HH_TITEL            97008
GEBAEUDETYP             93148
KONSUMNAEHE             73969
MIN_GEBAEUDEJAHR        93148
OST_WEST_KZ             93148
WOHNLAGE                93148
CAMEO_DEUG_2015         98979
CAMEO_DEU_2015          98979
CAMEO_INTL_2015         98979
KBA05_ANTG1            133324
KBA05_ANTG2            133324
KBA05_ANTG3            133324
KBA05_ANTG4            133324
KBA05_BAUMAX           133324
KBA05_GBZ              133324
BALLRAUM                93740
EWDICHTE                93740
INNENSTADT              93740
GEBAEUDETYP_RASTER      93155
KKK                    121196
MOBI_REGIO             133324
ONLINE_AFFINITAET        4854
REGIOTYP               121196
KBA13_ANZAHL_PKW       105800
PLZ8_ANTG1             116515
PLZ8_ANTG2             116515
PLZ8_ANTG3             116515
PLZ8_ANTG4             116515
PLZ8_BAUMAX            116515
PLZ8_HHZ               116515
PLZ8_GBZ               116515
ARBEIT                  97216
ORTSGR_KLS9             97216
RELAT_AB                97216
dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Identify missing or unknown data values and convert them to NaNs.</span></span><br><span class="line">pattern = re.compile(<span class="string">r'\-\d+|\d+'</span>) <span class="comment"># find all numbers</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (len(feat_info)):</span><br><span class="line">    index = pattern.findall(feat_info[<span class="string">'missing_or_unknown'</span>][i])</span><br><span class="line">    index = list(map(int, index))</span><br><span class="line">    azdias.iloc[:,i] = azdias.iloc[:,i].replace(index,np.nan)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'[A-Z]+'</span>) <span class="comment"># find all XX</span></span><br><span class="line">i = np.arange(<span class="number">57</span>,<span class="number">60</span>)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> i:</span><br><span class="line">    index = pattern.findall(feat_info[<span class="string">'missing_or_unknown'</span>][each])[<span class="number">0</span>]</span><br><span class="line">    azdias.iloc[:,each] = azdias.iloc[:,each].replace(index,np.nan)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># How mcuh data takes on a 'missing' or 'unknown' code</span></span><br><span class="line">indicated_miss = azdias.isna().sum()-nature_missing</span><br><span class="line">indicated_miss[indicated_miss != <span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>AGER_TYP                 685843
ALTERSKATEGORIE_GROB       2881
GEBURTSJAHR              392318
HEALTH_TYP               111196
LP_LEBENSPHASE_FEIN       92778
LP_LEBENSPHASE_GROB       89718
LP_FAMILIE_FEIN           72938
LP_FAMILIE_GROB           72938
NATIONALITAET_KZ         108315
PRAEGENDE_JUGENDJAHRE    108164
SHOPPER_TYP              111196
TITEL_KZ                 815562
VERS_TYP                 111196
ALTER_HH                 236768
W_KEIT_KIND_HH            40386
ANZ_HAUSHALTE_AKTIV        6463
CAMEO_DEUG_2015             373
CAMEO_DEU_2015              373
CAMEO_INTL_2015             373
KBA05_BAUMAX             343200
KKK                       36868
REGIOTYP                  36868
ARBEIT                      159
ORTSGR_KLS9                  58
RELAT_AB                    159
dtype: int64</code></pre><h4 id="Step-1-1-2-Assess-Missing-Data-in-Each-Column"><a href="#Step-1-1-2-Assess-Missing-Data-in-Each-Column" class="headerlink" title="Step 1.1.2: Assess Missing Data in Each Column"></a>Step 1.1.2: Assess Missing Data in Each Column</h4><p>How much missing data is present in each column? There are a few columns that are outliers in terms of the proportion of values that are missing. You will want to use matplotlib’s <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html" target="_blank" rel="noopener"><code>hist()</code></a> function to visualize the distribution of missing value counts to find these columns. Identify and document these columns. While some of these columns might have justifications for keeping or re-encoding the data, for this project you should just remove them from the dataframe. (Feel free to make remarks about these outlier columns in the discussion, however!)</p>
<p>For the remaining features, are there any patterns in which columns have, or share, missing data?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Perform an assessment of how much missing data there is in each column of the dataset.</span></span><br><span class="line"></span><br><span class="line">count_nan = azdias.isna().sum().sort_values(ascending = <span class="literal">False</span>)</span><br><span class="line">count_nan = count_nan[count_nan != <span class="number">0</span>] <span class="comment"># sort the counts</span></span><br><span class="line">plt.hist(count_nan,bins=<span class="number">30</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_12_0.png" alt="png"></p>
<p>Based on the graph we can notice most counts of missing values are centered around 150,000, and some are actually have a lot of missing values.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count_nan = (count_nan/<span class="number">891221</span>)[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">names = list(count_nan.index)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.bar(np.arange(len(names)),count_nan,  alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.xticks(np.arange(len(names)),names,rotation = <span class="number">60</span>,fontsize=<span class="number">10</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Percentage'</span>)</span><br><span class="line">plt.title(<span class="string">'Percentage of missing values'</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_14_0.png" alt="png"></p>
<p>From the graph above we can see top six variables have over 30% values are missing, those should be removed.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Remove the outlier columns from the dataset. (You'll perform other data</span></span><br><span class="line"><span class="comment"># engineering tasks such as re-encoding and imputation later.)</span></span><br><span class="line">remove_names = list(count_nan[<span class="number">0</span>:<span class="number">6</span>].index)</span><br><span class="line">deleted_var = azdias[remove_names] <span class="comment"># save deleted variables</span></span><br><span class="line">azdias.drop(remove_names,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"Total number of columns: &#123;&#125;"</span>.format(azdias.shape[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>Total number of columns: 79</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Investigate patterns in the amount of missing data in each column.</span></span><br><span class="line">count_nan = azdias.isna().sum().sort_values(ascending = <span class="literal">False</span>)</span><br><span class="line">count_nan = count_nan[count_nan != <span class="number">0</span>] </span><br><span class="line">count_nan</span><br></pre></td></tr></table></figure>




<pre><code>KKK                      158064
REGIOTYP                 158064
W_KEIT_KIND_HH           147988
MOBI_REGIO               133324
KBA05_ANTG4              133324
KBA05_ANTG3              133324
KBA05_ANTG2              133324
KBA05_ANTG1              133324
KBA05_GBZ                133324
PLZ8_ANTG2               116515
PLZ8_ANTG1               116515
PLZ8_ANTG3               116515
PLZ8_ANTG4               116515
PLZ8_BAUMAX              116515
PLZ8_HHZ                 116515
PLZ8_GBZ                 116515
HEALTH_TYP               111196
SHOPPER_TYP              111196
VERS_TYP                 111196
NATIONALITAET_KZ         108315
PRAEGENDE_JUGENDJAHRE    108164
KBA13_ANZAHL_PKW         105800
ANZ_HAUSHALTE_AKTIV       99611
CAMEO_INTL_2015           99352
CAMEO_DEU_2015            99352
CAMEO_DEUG_2015           99352
LP_LEBENSPHASE_FEIN       97632
RELAT_AB                  97375
ARBEIT                    97375
ORTSGR_KLS9               97274
ANZ_HH_TITEL              97008
LP_LEBENSPHASE_GROB       94572
INNENSTADT                93740
BALLRAUM                  93740
EWDICHTE                  93740
GEBAEUDETYP_RASTER        93155
OST_WEST_KZ               93148
MIN_GEBAEUDEJAHR          93148
WOHNLAGE                  93148
GEBAEUDETYP               93148
LP_FAMILIE_FEIN           77792
LP_FAMILIE_GROB           77792
KONSUMNAEHE               73969
ANZ_PERSONEN              73499
ANZ_TITEL                 73499
WOHNDAUER_2008            73499
SOHO_KZ                   73499
HH_EINKOMMEN_SCORE        18348
CJT_GESAMTTYP              4854
GFK_URLAUBERTYP            4854
RETOURTYP_BK_S             4854
ONLINE_AFFINITAET          4854
LP_STATUS_FEIN             4854
LP_STATUS_GROB             4854
ALTERSKATEGORIE_GROB       2881
dtype: int64</code></pre><h4 id="Discussion-1-1-2-Assess-Missing-Data-in-Each-Column"><a href="#Discussion-1-1-2-Assess-Missing-Data-in-Each-Column" class="headerlink" title="Discussion 1.1.2: Assess Missing Data in Each Column"></a>Discussion 1.1.2: Assess Missing Data in Each Column</h4><p>Some columns have exactly the same amount of missing values, which means they might also share those missing values. The variables which have more than 30% missing values are deleted. The deleted variables are TITEL_KZ, AGER_TYP, KK_KUNDENTYP, KBA05_BAUMAX, GEBURTSJAHR, ALTER_HH.</p>
<h4 id="Step-1-1-3-Assess-Missing-Data-in-Each-Row"><a href="#Step-1-1-3-Assess-Missing-Data-in-Each-Row" class="headerlink" title="Step 1.1.3: Assess Missing Data in Each Row"></a>Step 1.1.3: Assess Missing Data in Each Row</h4><p>Now, you’ll perform a similar assessment for the rows of the dataset. How much data is missing in each row? As with the columns, you should see some groups of points that have a very different numbers of missing values. Divide the data into two subsets: one for data points that are above some threshold for missing values, and a second subset for points below that threshold.</p>
<p>In order to know what to do with the outlier rows, we should see if the distribution of data values on columns that are not missing data (or are missing very little data) are similar or different between the two groups. Select at least five of these columns and compare the distribution of values.</p>
<ul>
<li>You can use seaborn’s <a href="https://seaborn.pydata.org/generated/seaborn.countplot.html" target="_blank" rel="noopener"><code>countplot()</code></a> function to create a bar chart of code frequencies and matplotlib’s <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.subplot.html" target="_blank" rel="noopener"><code>subplot()</code></a> function to put bar charts for the two subplots side by side.</li>
<li>To reduce repeated code, you might want to write a function that can perform this comparison, taking as one of its arguments a column to be compared.</li>
</ul>
<p>Depending on what you observe in your comparison, this will have implications on how you approach your conclusions later in the analysis. If the distributions of non-missing features look similar between the data with many missing values and the data with few or no missing values, then we could argue that simply dropping those points from the analysis won’t present a major issue. On the other hand, if the data with many missing values looks very different from the data with few or no missing values, then we should make a note on those data as special. We’ll revisit these data later on. <strong>Either way, you should continue your analysis for now using just the subset of the data with few or no missing values.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># How much data is missing in each row of the dataset?</span></span><br><span class="line">row_miss = azdias.isna().sum(axis = <span class="number">1</span>)</span><br><span class="line">sns.countplot(row_miss)</span><br><span class="line">plt.xticks(rotation = <span class="number">90</span>,fontsize=<span class="number">10</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_21_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write code to divide the data into two subsets based on the number of missing</span></span><br><span class="line"><span class="comment"># values in each row.</span></span><br><span class="line">azdias_no_miss = azdias[azdias.isna().sum(axis = <span class="number">1</span>) == <span class="number">0</span>]</span><br><span class="line">azdias_with_miss = azdias[azdias.isna().sum(axis = <span class="number">1</span>) &gt;= <span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Compare the distribution of values for at least five columns where there are</span></span><br><span class="line"><span class="comment"># no missing values, between the two subsets.</span></span><br><span class="line"></span><br><span class="line">list(azdias.isna().sum().sort_values().head(<span class="number">20</span>).index) <span class="comment"># choose columns with no missing values</span></span><br></pre></td></tr></table></figure>




<pre><code>[&apos;ZABEOTYP&apos;,
 &apos;SEMIO_REL&apos;,
 &apos;SEMIO_MAT&apos;,
 &apos;SEMIO_VERT&apos;,
 &apos;SEMIO_LUST&apos;,
 &apos;SEMIO_ERL&apos;,
 &apos;SEMIO_KULT&apos;,
 &apos;SEMIO_RAT&apos;,
 &apos;SEMIO_KRIT&apos;,
 &apos;SEMIO_DOM&apos;,
 &apos;SEMIO_KAEM&apos;,
 &apos;GREEN_AVANTGARDE&apos;,
 &apos;SEMIO_PFLICHT&apos;,
 &apos;FINANZTYP&apos;,
 &apos;FINANZ_HAUSBAUER&apos;,
 &apos;FINANZ_UNAUFFAELLIGER&apos;,
 &apos;FINANZ_ANLEGER&apos;,
 &apos;FINANZ_VORSORGER&apos;,
 &apos;FINANZ_SPARER&apos;,
 &apos;FINANZ_MINIMALIST&apos;]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># define a function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare_dist</span><span class="params">(name)</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">    ax = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    plt.hist(azdias_no_miss[name],bins = <span class="number">30</span>)</span><br><span class="line">    ax2 = plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    plt.hist(azdias_with_miss[name],bins = <span class="number">30</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 'ZABEOTYP'</span></span><br><span class="line">compare_dist(<span class="string">'ZABEOTYP'</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_25_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 'SEMIO_LUST'</span></span><br><span class="line">compare_dist(<span class="string">'SEMIO_LUST'</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_26_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 'GREEN_AVANTGARDE'</span></span><br><span class="line">compare_dist(<span class="string">'GREEN_AVANTGARDE'</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_27_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 'FINANZ_HAUSBAUER'</span></span><br><span class="line">compare_dist(<span class="string">'FINANZ_HAUSBAUER'</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_28_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 'SEMIO_RAT'</span></span><br><span class="line">compare_dist(<span class="string">'SEMIO_RAT'</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_29_0.png" alt="png"></p>
<h4 id="Discussion-1-1-3-Assess-Missing-Data-in-Each-Row"><a href="#Discussion-1-1-3-Assess-Missing-Data-in-Each-Row" class="headerlink" title="Discussion 1.1.3: Assess Missing Data in Each Row"></a>Discussion 1.1.3: Assess Missing Data in Each Row</h4><p>I divide the dataset in two subsets, one without missing values and the other with missing values. I did this because rows without missing values takes the big amount.</p>
<p>The data with missing values is not qualitatively different from the data with no missing values, based on five bar charts above.</p>
<h3 id="Step-1-2-Select-and-Re-Encode-Features"><a href="#Step-1-2-Select-and-Re-Encode-Features" class="headerlink" title="Step 1.2: Select and Re-Encode Features"></a>Step 1.2: Select and Re-Encode Features</h3><p>Checking for missing data isn’t the only way in which you can prepare a dataset for analysis. Since the unsupervised learning techniques to be used will only work on data that is encoded numerically, you need to make a few encoding changes or additional assumptions to be able to make progress. In addition, while almost all of the values in the dataset are encoded using numbers, not all of them represent numeric values. Check the third column of the feature summary (<code>feat_info</code>) for a summary of types of measurement.</p>
<ul>
<li>For numeric and interval data, these features can be kept without changes.</li>
<li>Most of the variables in the dataset are ordinal in nature. While ordinal values may technically be non-linear in spacing, make the simplifying assumption that the ordinal variables can be treated as being interval in nature (that is, kept without any changes).</li>
<li>Special handling may be necessary for the remaining two variable types: categorical, and ‘mixed’.</li>
</ul>
<p>In the first two parts of this sub-step, you will perform an investigation of the categorical and mixed-type features and make a decision on each of them, whether you will keep, drop, or re-encode each. Then, in the last part, you will create a new data frame with only the selected and engineered columns.</p>
<p>Data wrangling is often the trickiest part of the data analysis process, and there’s a lot of it to be done here. But stick with it: once you’re done with this step, you’ll be ready to get to the machine learning parts of the project!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># How many features are there of each data type?</span></span><br><span class="line"><span class="comment"># azdias_less_miss # use dataset with less missing values</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> remove_names:</span><br><span class="line">    feat_info = feat_info[feat_info[<span class="string">'attribute'</span>] != each]</span><br><span class="line">    </span><br><span class="line">categorical_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'categorical'</span>]</span><br><span class="line">ordinal_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'ordinal'</span>]</span><br><span class="line">numeric_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'numeric'</span>]</span><br><span class="line">mixed_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'mixed'</span>]</span><br><span class="line">interval_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'interval'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Total number of numeric variables: &#123;&#125;"</span>.format(len(numeric_v)))</span><br><span class="line">print(<span class="string">"Total number of interval variables: &#123;&#125;"</span>.format(len(interval_v)))</span><br><span class="line">print(<span class="string">"Total number of ordinal variables: &#123;&#125;"</span>.format(len(ordinal_v)))</span><br><span class="line">print(<span class="string">"Total number of categorical variables: &#123;&#125;"</span>.format(len(categorical_v)))</span><br><span class="line">print(<span class="string">"Total number of mixed variables: &#123;&#125;"</span>.format(len(mixed_v)))</span><br></pre></td></tr></table></figure>

<pre><code>Total number of numeric variables: 6
Total number of interval variables: 0
Total number of ordinal variables: 49
Total number of categorical variables: 18
Total number of mixed variables: 6</code></pre><h4 id="Step-1-2-1-Re-Encode-Categorical-Features"><a href="#Step-1-2-1-Re-Encode-Categorical-Features" class="headerlink" title="Step 1.2.1: Re-Encode Categorical Features"></a>Step 1.2.1: Re-Encode Categorical Features</h4><p>For categorical data, you would ordinarily need to encode the levels as dummy variables. Depending on the number of categories, perform one of the following:</p>
<ul>
<li>For binary (two-level) categoricals that take numeric values, you can keep them without needing to do anything.</li>
<li>There is one binary variable that takes on non-numeric values. For this one, you need to re-encode the values as numbers or create a dummy variable.</li>
<li>For multi-level categoricals (three or more values), you can choose to encode the values using multiple dummy variables (e.g. via <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" target="_blank" rel="noopener">OneHotEncoder</a>), or (to keep things straightforward) just drop them from the analysis. As always, document your choices in the Discussion section.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Assess categorical variables: which are binary, which are multi-level, and</span></span><br><span class="line"><span class="comment"># which one needs to be re-encoded?</span></span><br><span class="line">binary_v = [<span class="string">'ANREDE_KZ'</span>, <span class="string">'GREEN_AVANTGARDE'</span>,<span class="string">'SOHO_KZ'</span>,<span class="string">'VERS_TYP'</span>,<span class="string">'OST_WEST_KZ'</span>] <span class="comment"># all binary variables and 'OST_WEST_KZ' should be re-encoded</span></span><br><span class="line">multi_level_v=categorical_v</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> binary_v:</span><br><span class="line">    multi_level_v = multi_level_v[multi_level_v[<span class="string">'attribute'</span>] != each]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Re-encode categorical variable(s) to be kept in the analysis.</span></span><br><span class="line"><span class="comment"># re-encode the binary variable</span></span><br><span class="line">azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>] = azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>].replace(<span class="string">'O'</span>,<span class="number">0</span>)</span><br><span class="line">azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>] = azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>].replace(<span class="string">'W'</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># re-encode the multi-level variables</span></span><br><span class="line">multi_level_row = azdias_no_miss[multi_level_v[<span class="string">'attribute'</span>]]</span><br><span class="line">multi_level_full = pd.get_dummies(multi_level_row.astype(str))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Change the original dataset</span></span><br><span class="line">names = list(multi_level_v[<span class="string">'attribute'</span>])</span><br><span class="line">azdias_no_miss.drop(names,axis=<span class="number">1</span>,inplace = <span class="literal">True</span>)</span><br><span class="line">azdias_no_miss = pd.concat([azdias_no_miss, multi_level_full],axis=<span class="number">1</span> )</span><br><span class="line">encoded = list(azdias_no_miss.columns)</span><br><span class="line">print(<span class="string">"&#123;&#125; total features after one-hot encoding."</span>.format(len(encoded)))</span><br></pre></td></tr></table></figure>

<pre><code>191 total features after one-hot encoding.</code></pre><h4 id="Discussion-1-2-1-Re-Encode-Categorical-Features"><a href="#Discussion-1-2-1-Re-Encode-Categorical-Features" class="headerlink" title="Discussion 1.2.1: Re-Encode Categorical Features"></a>Discussion 1.2.1: Re-Encode Categorical Features</h4><p>For binary variable ‘OST_WEST_KZ’ I transform it to numeric values, For multi-level variables I transform all of them into dummy variables.</p>
<h4 id="Step-1-2-2-Engineer-Mixed-Type-Features"><a href="#Step-1-2-2-Engineer-Mixed-Type-Features" class="headerlink" title="Step 1.2.2: Engineer Mixed-Type Features"></a>Step 1.2.2: Engineer Mixed-Type Features</h4><p>There are a handful of features that are marked as “mixed” in the feature summary that require special treatment in order to be included in the analysis. There are two in particular that deserve attention; the handling of the rest are up to your own choices:</p>
<ul>
<li>“PRAEGENDE_JUGENDJAHRE” combines information on three dimensions: generation by decade, movement (mainstream vs. avantgarde), and nation (east vs. west). While there aren’t enough levels to disentangle east from west, you should create two new variables to capture the other two dimensions: an interval-type variable for decade, and a binary variable for movement.</li>
<li>“CAMEO_INTL_2015” combines information on two axes: wealth and life stage. Break up the two-digit codes by their ‘tens’-place and ‘ones’-place digits into two new ordinal variables (which, for the purposes of this project, is equivalent to just treating them as their raw numeric values).</li>
<li>If you decide to keep or engineer new features around the other mixed-type features, make sure you note your steps in the Discussion section.</li>
</ul>
<p>Be sure to check <code>Data_Dictionary.md</code> for the details needed to finish these tasks.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Investigate "PRAEGENDE_JUGENDJAHRE" and engineer two new variables.</span></span><br><span class="line"><span class="comment"># movement: 1 for Mainstream, 0 for Avantgarde</span></span><br><span class="line">movement = azdias_no_miss[<span class="string">'PRAEGENDE_JUGENDJAHRE'</span>] == <span class="number">1</span> | <span class="number">3</span> | <span class="number">5</span> | <span class="number">8</span> | <span class="number">10</span> | <span class="number">12</span> | <span class="number">14</span></span><br><span class="line">movement = movement.astype(int)</span><br><span class="line">decade = []</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">temp = azdias_no_miss[<span class="string">'PRAEGENDE_JUGENDJAHRE'</span>]</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> temp:</span><br><span class="line">    <span class="keyword">if</span> each == <span class="number">1</span> <span class="keyword">or</span> each == <span class="number">2</span>:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> each == <span class="number">3</span> <span class="keyword">or</span> each == <span class="number">4</span>:</span><br><span class="line">        i = <span class="number">2</span> </span><br><span class="line">    <span class="keyword">elif</span> each == <span class="number">5</span> <span class="keyword">or</span> each == <span class="number">6</span> <span class="keyword">or</span> each == <span class="number">7</span>:</span><br><span class="line">        i = <span class="number">3</span></span><br><span class="line">    <span class="keyword">elif</span> each == <span class="number">8</span> <span class="keyword">or</span> each ==<span class="number">9</span>:</span><br><span class="line">        i = <span class="number">4</span></span><br><span class="line">    <span class="keyword">elif</span> each == <span class="number">10</span> <span class="keyword">or</span> each ==<span class="number">11</span> <span class="keyword">or</span> each ==<span class="number">12</span> <span class="keyword">or</span> each ==<span class="number">13</span>:</span><br><span class="line">        i = <span class="number">5</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i = <span class="number">6</span></span><br><span class="line">    decade.append(i)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Investigate "CAMEO_INTL_2015" and engineer two new variables.</span></span><br><span class="line">wealth = azdias_no_miss[<span class="string">'CAMEO_INTL_2015'</span>].astype(int)/<span class="number">10</span></span><br><span class="line">wealth = wealth.astype(int)</span><br><span class="line">life_stage = azdias_no_miss[<span class="string">'CAMEO_INTL_2015'</span>].astype(int) % <span class="number">10</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Drop original columns and add the new columns</span></span><br><span class="line">names = list(mixed_v[<span class="string">'attribute'</span>])</span><br><span class="line">azdias_no_miss.drop(names,axis=<span class="number">1</span>,inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">azdias_no_miss[<span class="string">'movement'</span>] = movement</span><br><span class="line">azdias_no_miss[<span class="string">'decade'</span>] = decade</span><br><span class="line">azdias_no_miss[<span class="string">'wealth'</span>] = wealth</span><br><span class="line">azdias_no_miss[<span class="string">'life_stage'</span>] = life_stage</span><br></pre></td></tr></table></figure>

<h4 id="Discussion-1-2-2-Engineer-Mixed-Type-Features"><a href="#Discussion-1-2-2-Engineer-Mixed-Type-Features" class="headerlink" title="Discussion 1.2.2: Engineer Mixed-Type Features"></a>Discussion 1.2.2: Engineer Mixed-Type Features</h4><p>I transformed “PRAEGENDE_JUGENDJAHRE”  and “CAMEO_INTL_2015” . For other variables I just dropped them since some are overlapped with existed variables, for example, “LP_LEBENSPHASE_GROB”.</p>
<h4 id="Step-1-2-3-Complete-Feature-Selection"><a href="#Step-1-2-3-Complete-Feature-Selection" class="headerlink" title="Step 1.2.3: Complete Feature Selection"></a>Step 1.2.3: Complete Feature Selection</h4><p>In order to finish this step up, you need to make sure that your data frame now only has the columns that you want to keep. To summarize, the dataframe should consist of the following:</p>
<ul>
<li>All numeric, interval, and ordinal type columns from the original dataset.</li>
<li>Binary categorical features (all numerically-encoded).</li>
<li>Engineered features from other multi-level categorical features and mixed features.</li>
</ul>
<p>Make sure that for any new columns that you have engineered, that you’ve excluded the original columns from the final dataset. Otherwise, their values will interfere with the analysis later on the project. For example, you should not keep “PRAEGENDE_JUGENDJAHRE”, since its values won’t be useful for the algorithm: only the values derived from it in the engineered features you created should be retained. As a reminder, your data should only be from <strong>the subset with few or no missing values</strong>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If there are other re-engineering tasks you need to perform, make sure you</span></span><br><span class="line"><span class="comment"># take care of them here. (Dealing with missing data will come in step 2.1.)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Do whatever you need to in order to ensure that the dataframe only contains</span></span><br><span class="line"><span class="comment"># the columns that should be passed to the algorithm functions.</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-1-3-Create-a-Cleaning-Function"><a href="#Step-1-3-Create-a-Cleaning-Function" class="headerlink" title="Step 1.3: Create a Cleaning Function"></a>Step 1.3: Create a Cleaning Function</h3><p>Even though you’ve finished cleaning up the general population demographics data, it’s important to look ahead to the future and realize that you’ll need to perform the same cleaning steps on the customer demographics data. In this substep, complete the function below to execute the main feature selection, encoding, and re-engineering steps you performed above. Then, when it comes to looking at the customer data in Step 3, you can just run this function on that DataFrame to get the trimmed dataset in a single step.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_data</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Perform feature trimming, re-encoding, and engineering for demographics</span></span><br><span class="line"><span class="string">    data</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    INPUT: Demographics DataFrame</span></span><br><span class="line"><span class="string">    OUTPUT: Trimmed and cleaned demographics DataFrame</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    feat_info = pd.read_csv(<span class="string">'AZDIAS_Feature_Summary.csv'</span>,sep=<span class="string">';'</span>)</span><br><span class="line">    <span class="comment"># Put in code here to execute all main cleaning steps:</span></span><br><span class="line">    <span class="comment"># convert missing value codes into NaNs, ...</span></span><br><span class="line">    <span class="comment"># Identify missing or unknown data values and convert them to NaNs.</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'\-\d+|\d+'</span>) <span class="comment"># find all numbers</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(feat_info)):</span><br><span class="line">        index = pattern.findall(feat_info[<span class="string">'missing_or_unknown'</span>][i])</span><br><span class="line">        index = list(map(int, index))</span><br><span class="line">        df.iloc[:,i] = df.iloc[:,i].replace(index,np.nan)</span><br><span class="line">    pattern = re.compile(<span class="string">r'[A-Z]+'</span>) <span class="comment"># find all XX</span></span><br><span class="line">    i = np.arange(<span class="number">57</span>,<span class="number">60</span>)</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> i:</span><br><span class="line">        index = pattern.findall(feat_info[<span class="string">'missing_or_unknown'</span>][each])[<span class="number">0</span>]</span><br><span class="line">        df.iloc[:,each] = df.iloc[:,each].replace(index,np.nan)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># remove selected columns and rows, ...</span></span><br><span class="line">    count_nan = df.isna().sum().sort_values(ascending = <span class="literal">False</span>)</span><br><span class="line">    count_nan = count_nan[count_nan != <span class="number">0</span>] <span class="comment"># sort the counts</span></span><br><span class="line">    remove_names = [<span class="string">'TITEL_KZ'</span>,<span class="string">'AGER_TYP'</span>,<span class="string">'KK_KUNDENTYP'</span>,<span class="string">'KBA05_BAUMAX'</span>,<span class="string">'GEBURTSJAHR'</span>,<span class="string">'ALTER_HH'</span>]<span class="comment"># save deleted variables</span></span><br><span class="line">    df.drop(remove_names,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    azdias_no_miss = df[df.isna().sum(axis = <span class="number">1</span>) == <span class="number">0</span>]</span><br><span class="line">    azdias_with_miss = df[df.isna().sum(axis = <span class="number">1</span>) &gt;= <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># select, re-encode, and engineer column values.</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> remove_names:</span><br><span class="line">        feat_info = feat_info[feat_info[<span class="string">'attribute'</span>] != each]</span><br><span class="line">    </span><br><span class="line">    categorical_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'categorical'</span>]</span><br><span class="line">    ordinal_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'ordinal'</span>]</span><br><span class="line">    numeric_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'numeric'</span>]</span><br><span class="line">    mixed_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'mixed'</span>]</span><br><span class="line">    interval_v = feat_info[feat_info[<span class="string">'type'</span>] == <span class="string">'interval'</span>]</span><br><span class="line">    </span><br><span class="line">    binary_v = [<span class="string">'ANREDE_KZ'</span>, <span class="string">'GREEN_AVANTGARDE'</span>,<span class="string">'SOHO_KZ'</span>,<span class="string">'VERS_TYP'</span>,<span class="string">'OST_WEST_KZ'</span>] <span class="comment"># all binary variables and 'OST_WEST_KZ' should be re-encoded</span></span><br><span class="line">    multi_level_v=categorical_v</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> binary_v:</span><br><span class="line">        multi_level_v = multi_level_v[multi_level_v[<span class="string">'attribute'</span>] != each]</span><br><span class="line">    azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>] = azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>].replace(<span class="string">'O'</span>,<span class="number">0</span>)</span><br><span class="line">    azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>] = azdias_no_miss.loc[:, <span class="string">'OST_WEST_KZ'</span>].replace(<span class="string">'W'</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># re-encode the multi-level variables</span></span><br><span class="line">    multi_level_row = azdias_no_miss[multi_level_v[<span class="string">'attribute'</span>]]</span><br><span class="line">    multi_level_full = pd.get_dummies(multi_level_row.astype(str))</span><br><span class="line">    <span class="comment"># Change the original dataset</span></span><br><span class="line">    names = list(multi_level_v[<span class="string">'attribute'</span>])</span><br><span class="line">    azdias_no_miss.drop(names,axis=<span class="number">1</span>,inplace = <span class="literal">True</span>)</span><br><span class="line">    azdias_no_miss = pd.concat([azdias_no_miss, multi_level_full],axis=<span class="number">1</span> )</span><br><span class="line">    </span><br><span class="line">    movement = azdias_no_miss[<span class="string">'PRAEGENDE_JUGENDJAHRE'</span>] == <span class="number">1</span> | <span class="number">3</span> | <span class="number">5</span> | <span class="number">8</span> | <span class="number">10</span> | <span class="number">12</span> | <span class="number">14</span></span><br><span class="line">    movement = movement.astype(int)</span><br><span class="line">    decade = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    temp = azdias_no_miss[<span class="string">'PRAEGENDE_JUGENDJAHRE'</span>]</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> temp:</span><br><span class="line">        <span class="keyword">if</span> each == <span class="number">1</span> <span class="keyword">or</span> each == <span class="number">2</span>:</span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> each == <span class="number">3</span> <span class="keyword">or</span> each == <span class="number">4</span>:</span><br><span class="line">            i = <span class="number">2</span> </span><br><span class="line">        <span class="keyword">elif</span> each == <span class="number">5</span> <span class="keyword">or</span> each == <span class="number">6</span> <span class="keyword">or</span> each == <span class="number">7</span>:</span><br><span class="line">            i = <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> each == <span class="number">8</span> <span class="keyword">or</span> each ==<span class="number">9</span>:</span><br><span class="line">            i = <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> each == <span class="number">10</span> <span class="keyword">or</span> each ==<span class="number">11</span> <span class="keyword">or</span> each ==<span class="number">12</span> <span class="keyword">or</span> each ==<span class="number">13</span>:</span><br><span class="line">            i = <span class="number">5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = <span class="number">6</span></span><br><span class="line">        decade.append(i)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Investigate "CAMEO_INTL_2015" and engineer two new variables.</span></span><br><span class="line">    wealth = azdias_no_miss[<span class="string">'CAMEO_INTL_2015'</span>].astype(int)/<span class="number">10</span></span><br><span class="line">    wealth = wealth.astype(int)</span><br><span class="line">    life_stage = azdias_no_miss[<span class="string">'CAMEO_INTL_2015'</span>].astype(int) % <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Drop original columns and add the new columns</span></span><br><span class="line">    names = list(mixed_v[<span class="string">'attribute'</span>])</span><br><span class="line">    azdias_no_miss.drop(names,axis=<span class="number">1</span>,inplace = <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    azdias_no_miss[<span class="string">'movement'</span>] = movement</span><br><span class="line">    azdias_no_miss[<span class="string">'decade'</span>] = decade</span><br><span class="line">    azdias_no_miss[<span class="string">'wealth'</span>] = wealth</span><br><span class="line">    azdias_no_miss[<span class="string">'life_stage'</span>] = life_stage</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the cleaned dataframe.</span></span><br><span class="line">    <span class="keyword">return</span> azdias_no_miss</span><br></pre></td></tr></table></figure>

<h2 id="Step-2-Feature-Transformation"><a href="#Step-2-Feature-Transformation" class="headerlink" title="Step 2: Feature Transformation"></a>Step 2: Feature Transformation</h2><h3 id="Step-2-1-Apply-Feature-Scaling"><a href="#Step-2-1-Apply-Feature-Scaling" class="headerlink" title="Step 2.1: Apply Feature Scaling"></a>Step 2.1: Apply Feature Scaling</h3><p>Before we apply dimensionality reduction techniques to the data, we need to perform feature scaling so that the principal component vectors are not influenced by the natural differences in scale for features. Starting from this part of the project, you’ll want to keep an eye on the <a href="http://scikit-learn.org/stable/modules/classes.html" target="_blank" rel="noopener">API reference page for sklearn</a> to help you navigate to all of the classes and functions that you’ll need. In this substep, you’ll need to check the following:</p>
<ul>
<li>sklearn requires that data not have missing values in order for its estimators to work properly. So, before applying the scaler to your data, make sure that you’ve cleaned the DataFrame of the remaining missing values. This can be as simple as just removing all data points with missing data, or applying an <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Imputer.html" target="_blank" rel="noopener">Imputer</a> to replace all missing values. You might also try a more complicated procedure where you temporarily remove missing values in order to compute the scaling parameters before re-introducing those missing values and applying imputation. Think about how much missing data you have and what possible effects each approach might have on your analysis, and justify your decision in the discussion section below.</li>
<li>For the actual scaling function, a <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" target="_blank" rel="noopener">StandardScaler</a> instance is suggested, scaling each feature to mean 0 and standard deviation 1.</li>
<li>For these classes, you can make use of the <code>.fit_transform()</code> method to both fit a procedure to the data as well as apply the transformation to the data at the same time. Don’t forget to keep the fit sklearn objects handy, since you’ll be applying them to the customer demographics data towards the end of the project.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you've not yet cleaned the dataset of all NaN values, then investigate and</span></span><br><span class="line"><span class="comment"># do that now.</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Apply feature scaling to the general population demographics data.</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">azdias_trans = pd.DataFrame(scaler.fit_transform(azdias_no_miss))</span><br><span class="line">azdias_trans.columns = azdias_no_miss.columns</span><br></pre></td></tr></table></figure>

<h3 id="Discussion-2-1-Apply-Feature-Scaling"><a href="#Discussion-2-1-Apply-Feature-Scaling" class="headerlink" title="Discussion 2.1: Apply Feature Scaling"></a>Discussion 2.1: Apply Feature Scaling</h3><p>I removed all missing values brfore, and I transformed all features with StandardScaler.</p>
<h3 id="Step-2-2-Perform-Dimensionality-Reduction"><a href="#Step-2-2-Perform-Dimensionality-Reduction" class="headerlink" title="Step 2.2: Perform Dimensionality Reduction"></a>Step 2.2: Perform Dimensionality Reduction</h3><p>On your scaled data, you are now ready to apply dimensionality reduction techniques.</p>
<ul>
<li>Use sklearn’s <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" target="_blank" rel="noopener">PCA</a> class to apply principal component analysis on the data, thus finding the vectors of maximal variance in the data. To start, you should not set any parameters (so all components are computed) or set a number of components that is at least half the number of features (so there’s enough features to see the general trend in variability).</li>
<li>Check out the ratio of variance explained by each principal component as well as the cumulative variance explained. Try plotting the cumulative or sequential values using matplotlib’s <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html" target="_blank" rel="noopener"><code>plot()</code></a> function. Based on what you find, select a value for the number of transformed features you’ll retain for the clustering part of the project.</li>
<li>Once you’ve made a choice for the number of components to keep, make sure you re-fit a PCA instance to perform the decided-on transformation.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Apply PCA to the data.</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">pca = PCA()</span><br><span class="line">azdias_pca = pca.fit_transform(azdias_trans)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Investigate the variance accounted for by each principal component.</span></span><br><span class="line">var_ratio = pca.explained_variance_ratio_</span><br><span class="line">plt.plot(var_ratio)</span><br></pre></td></tr></table></figure>




<pre><code>[&lt;matplotlib.lines.Line2D at 0x1f0a9327e08&gt;]</code></pre><p><img src="/2020/02/05/Identify_Customer_Segments/output_56_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(np.cumsum(var_ratio))</span><br></pre></td></tr></table></figure>




<pre><code>[&lt;matplotlib.lines.Line2D at 0x1f0a8f7dc08&gt;]</code></pre><p><img src="/2020/02/05/Identify_Customer_Segments/output_57_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Re-apply PCA to the data while selecting for number of components to retain.</span></span><br><span class="line">pca = PCA(n_components=<span class="number">100</span>)</span><br><span class="line">azdias_pca = pca.fit_transform(azdias_trans)</span><br></pre></td></tr></table></figure>

<h3 id="Discussion-2-2-Perform-Dimensionality-Reduction"><a href="#Discussion-2-2-Perform-Dimensionality-Reduction" class="headerlink" title="Discussion 2.2: Perform Dimensionality Reduction"></a>Discussion 2.2: Perform Dimensionality Reduction</h3><p>With 100 components, over 80% variance can be explained. Thus I choose 100 components.</p>
<h3 id="Step-2-3-Interpret-Principal-Components"><a href="#Step-2-3-Interpret-Principal-Components" class="headerlink" title="Step 2.3: Interpret Principal Components"></a>Step 2.3: Interpret Principal Components</h3><p>Now that we have our transformed principal components, it’s a nice idea to check out the weight of each variable on the first few components to see if they can be interpreted in some fashion.</p>
<p>As a reminder, each principal component is a unit vector that points in the direction of highest variance (after accounting for the variance captured by earlier principal components). The further a weight is from zero, the more the principal component is in the direction of the corresponding feature. If two features have large weights of the same sign (both positive or both negative), then increases in one tend expect to be associated with increases in the other. To contrast, features with different signs can be expected to show a negative correlation: increases in one variable should result in a decrease in the other.</p>
<ul>
<li>To investigate the features, you should map each weight to their corresponding feature name, then sort the features according to weight. The most interesting features for each principal component, then, will be those at the beginning and end of the sorted list. Use the data dictionary document to help you understand these most prominent features, their relationships, and what a positive or negative value on the principal component might indicate.</li>
<li>You should investigate and interpret feature associations from the first three principal components in this substep. To help facilitate this, you should write a function that you can call at any time to print the sorted list of feature weights, for the <em>i</em>-th principal component. This might come in handy in the next step of the project, when you interpret the tendencies of the discovered clusters.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Map weights for the first principal component to corresponding feature names</span></span><br><span class="line"><span class="comment"># and then print the linked values, sorted by weight.</span></span><br><span class="line"><span class="comment"># HINT: Try defining a function here or in a new cell that you can reuse in the</span></span><br><span class="line"><span class="comment"># other cells.</span></span><br><span class="line">feature_select = pd.DataFrame(pca.components_,columns=azdias_trans.columns).T</span><br><span class="line">feature_select[<span class="number">0</span>].sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>MOBI_REGIO           -0.202737
FINANZ_MINIMALIST    -0.195380
KBA05_ANTG1          -0.190736
PLZ8_ANTG1           -0.180144
KBA05_GBZ            -0.179441
                        ...   
PLZ8_ANTG4            0.172431
PLZ8_ANTG3            0.178166
HH_EINKOMMEN_SCORE    0.178693
wealth                0.180169
LP_STATUS_GROB_1.0    0.192540
Name: 0, Length: 189, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Map weights for the second principal component to corresponding feature names</span></span><br><span class="line"><span class="comment"># and then print the linked values, sorted by weight.</span></span><br><span class="line"></span><br><span class="line">feature_select[<span class="number">1</span>].sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>decade                  -0.228497
SEMIO_REL               -0.213832
FINANZ_SPARER           -0.212535
FINANZ_UNAUFFAELLIGER   -0.207468
SEMIO_PFLICHT           -0.205000
                           ...   
RETOURTYP_BK_S           0.156204
SEMIO_ERL                0.181138
ZABEOTYP_3               0.197800
FINANZ_VORSORGER         0.205081
ALTERSKATEGORIE_GROB     0.225616
Name: 1, Length: 189, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Map weights for the third principal component to corresponding feature names</span></span><br><span class="line"><span class="comment"># and then print the linked values, sorted by weight.</span></span><br><span class="line">feature_select[<span class="number">2</span>].sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>ANREDE_KZ     -0.346752
SEMIO_KAEM    -0.319185
SEMIO_DOM     -0.286983
SEMIO_KRIT    -0.262582
SEMIO_ERL     -0.199994
                 ...   
FINANZTYP_5    0.135987
SEMIO_KULT     0.246536
SEMIO_SOZ      0.257146
SEMIO_FAM      0.260536
SEMIO_VERT     0.324047
Name: 2, Length: 189, dtype: float64</code></pre><h3 id="Discussion-2-3-Interpret-Principal-Components"><a href="#Discussion-2-3-Interpret-Principal-Components" class="headerlink" title="Discussion 2.3: Interpret Principal Components"></a>Discussion 2.3: Interpret Principal Components</h3><p>Component 1: Movement patterns and social status are negatively correlated, which means higher movement higher income. Also wealth and social status are positively correlated. Therefore, the first component is correalted with people’s wealth.</p>
<p>Component 2: Estimated age based on given name analysis is negatively correlated with variable decade, since they are negatively correlated by nature. Thus this one is correlated with ages.</p>
<p>Component 3: People who is not likely to be dreamful is more likely to be a male. This Component is related to the gender.</p>
<h2 id="Step-3-Clustering"><a href="#Step-3-Clustering" class="headerlink" title="Step 3: Clustering"></a>Step 3: Clustering</h2><h3 id="Step-3-1-Apply-Clustering-to-General-Population"><a href="#Step-3-1-Apply-Clustering-to-General-Population" class="headerlink" title="Step 3.1: Apply Clustering to General Population"></a>Step 3.1: Apply Clustering to General Population</h3><p>You’ve assessed and cleaned the demographics data, then scaled and transformed them. Now, it’s time to see how the data clusters in the principal components space. In this substep, you will apply k-means clustering to the dataset and use the average within-cluster distances from each point to their assigned cluster’s centroid to decide on a number of clusters to keep.</p>
<ul>
<li>Use sklearn’s <a href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" target="_blank" rel="noopener">KMeans</a> class to perform k-means clustering on the PCA-transformed data.</li>
<li>Then, compute the average difference from each point to its assigned cluster’s center. <strong>Hint</strong>: The KMeans object’s <code>.score()</code> method might be useful here, but note that in sklearn, scores tend to be defined so that larger is better. Try applying it to a small, toy dataset, or use an internet search to help your understanding.</li>
<li>Perform the above two steps for a number of different cluster counts. You can then see how the average distance decreases with an increasing number of clusters. However, each additional cluster provides a smaller net benefit. Use this fact to select a final number of clusters in which to group the data. <strong>Warning</strong>: because of the large size of the dataset, it can take a long time for the algorithm to resolve. The more clusters to fit, the longer the algorithm will take. You should test for cluster counts through at least 10 clusters to get the full picture, but you shouldn’t need to test for a number of clusters above about 30.</li>
<li>Once you’ve selected a final number of clusters to use, re-fit a KMeans instance to perform the clustering operation. Make sure that you also obtain the cluster assignments for the general demographics data, since you’ll be using them in the final Step 3.3.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Function to calculate K-Means score for a centroid</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_kmeans_score</span><span class="params">(data, center)</span>:</span></span><br><span class="line">    </span><br><span class="line">    kmeans = KMeans(n_clusters = center, random_state=<span class="number">2020</span>)</span><br><span class="line">    model = kmeans.fit(data)</span><br><span class="line">    score = np.abs(model.score(data))</span><br><span class="line">    <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = []</span><br><span class="line">centroids = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">23</span>,<span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> centroids:</span><br><span class="line">    score.append(get_kmeans_score(azdias_pca,each))</span><br><span class="line">    print(<span class="string">'Finished for:'</span>,each)</span><br></pre></td></tr></table></figure>

<pre><code>Finished for: 2
Finished for: 5
Finished for: 10
Finished for: 11
Finished for: 12
Finished for: 13
Finished for: 14
Finished for: 16
Finished for: 20
Finished for: 23
Finished for: 25</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Investigate the change in within-cluster distance across number of clusters.</span></span><br><span class="line"><span class="comment"># HINT: Use matplotlib's plot function to visualize this relationship.</span></span><br><span class="line"></span><br><span class="line">plt.plot(centroids,score,color=<span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&lt;matplotlib.lines.Line2D at 0x1f0a955a4c8&gt;]</code></pre><p><img src="/2020/02/05/Identify_Customer_Segments/output_68_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Re-fit the k-means model with the selected number of clusters and obtain</span></span><br><span class="line"><span class="comment"># cluster predictions for the general population demographics data.</span></span><br><span class="line">kmeans = KMeans(n_clusters = <span class="number">11</span>, random_state=<span class="number">2020</span>)</span><br><span class="line">result = kmeans.fit_predict(azdias_pca)</span><br></pre></td></tr></table></figure>

<h3 id="Discussion-3-1-Apply-Clustering-to-General-Population"><a href="#Discussion-3-1-Apply-Clustering-to-General-Population" class="headerlink" title="Discussion 3.1: Apply Clustering to General Population"></a>Discussion 3.1: Apply Clustering to General Population</h3><p>The first elbow occurs at ‘n_clusters = 5’, the second elbow occurs at 11, therefore I choose 11 centroids. </p>
<h3 id="Step-3-2-Apply-All-Steps-to-the-Customer-Data"><a href="#Step-3-2-Apply-All-Steps-to-the-Customer-Data" class="headerlink" title="Step 3.2: Apply All Steps to the Customer Data"></a>Step 3.2: Apply All Steps to the Customer Data</h3><p>Now that you have clusters and cluster centers for the general population, it’s time to see how the customer data maps on to those clusters. Take care to not confuse this for re-fitting all of the models to the customer data. Instead, you’re going to use the fits from the general population to clean, transform, and cluster the customer data. In the last step of the project, you will interpret how the general population fits apply to the customer data.</p>
<ul>
<li>Don’t forget when loading in the customers data, that it is semicolon (<code>;</code>) delimited.</li>
<li>Apply the same feature wrangling, selection, and engineering steps to the customer demographics using the <code>clean_data()</code> function you created earlier. (You can assume that the customer demographics data has similar meaning behind missing data patterns as the general demographics data.)</li>
<li>Use the sklearn objects from the general demographics data, and apply their transformations to the customers data. That is, you should not be using a <code>.fit()</code> or <code>.fit_transform()</code> method to re-fit the old objects, nor should you be creating new sklearn objects! Carry the data through the feature scaling, PCA, and clustering steps, obtaining cluster assignments for all of the data in the customer demographics data.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load in the customer demographics data.</span></span><br><span class="line">customers = pd.read_csv(<span class="string">'Udacity_CUSTOMERS_Subset.csv'</span>,sep=<span class="string">';'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Apply preprocessing, feature transformation, and clustering from the general</span></span><br><span class="line"><span class="comment"># demographics onto the customer data, obtaining cluster predictions for the</span></span><br><span class="line"><span class="comment"># customer demographics data.</span></span><br><span class="line">customers.shape</span><br></pre></td></tr></table></figure>




<pre><code>(191652, 85)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">customers_clean = clean_data(customers)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">customers_clean.shape</span><br></pre></td></tr></table></figure>




<pre><code>(115643, 188)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># feature transformation</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">customers_clean_trans = pd.DataFrame(scaler.fit_transform(customers_clean))</span><br><span class="line">customers_clean_trans.columns = customers_clean.columns</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pca</span></span><br><span class="line">pca = PCA(n_components=<span class="number">100</span>)</span><br><span class="line">customers_pca = pca.fit_transform(customers_clean_trans)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cluster predictions for the customer data.</span></span><br><span class="line">kmeans = KMeans(n_clusters = <span class="number">11</span>, random_state=<span class="number">2020</span>)</span><br><span class="line">result_customer = kmeans.fit_predict(customers_pca)</span><br></pre></td></tr></table></figure>

<h3 id="Step-3-3-Compare-Customer-Data-to-Demographics-Data"><a href="#Step-3-3-Compare-Customer-Data-to-Demographics-Data" class="headerlink" title="Step 3.3: Compare Customer Data to Demographics Data"></a>Step 3.3: Compare Customer Data to Demographics Data</h3><p>At this point, you have clustered data based on demographics of the general population of Germany, and seen how the customer data for a mail-order sales company maps onto those demographic clusters. In this final substep, you will compare the two cluster distributions to see where the strongest customer base for the company is.</p>
<p>Consider the proportion of persons in each cluster for the general population, and the proportions for the customers. If we think the company’s customer base to be universal, then the cluster assignment proportions should be fairly similar between the two. If there are only particular segments of the population that are interested in the company’s products, then we should see a mismatch from one to the other. If there is a higher proportion of persons in a cluster for the customer data compared to the general population (e.g. 5% of persons are assigned to a cluster for the general population, but 15% of the customer data is closest to that cluster’s centroid) then that suggests the people in that cluster to be a target audience for the company. On the other hand, the proportion of the data in a cluster being larger in the general population than the customer data (e.g. only 2% of customers closest to a population centroid that captures 6% of the data) suggests that group of persons to be outside of the target demographics.</p>
<p>Take a look at the following points in this step:</p>
<ul>
<li>Compute the proportion of data points in each cluster for the general population and the customer data. Visualizations will be useful here: both for the individual dataset proportions, but also to visualize the ratios in cluster representation between groups. Seaborn’s <a href="https://seaborn.pydata.org/generated/seaborn.countplot.html" target="_blank" rel="noopener"><code>countplot()</code></a> or <a href="https://seaborn.pydata.org/generated/seaborn.barplot.html" target="_blank" rel="noopener"><code>barplot()</code></a> function could be handy.<ul>
<li>Recall the analysis you performed in step 1.1.3 of the project, where you separated out certain data points from the dataset if they had more than a specified threshold of missing values. If you found that this group was qualitatively different from the main bulk of the data, you should treat this as an additional data cluster in this analysis. Make sure that you account for the number of data points in this subset, for both the general population and customer datasets, when making your computations!</li>
</ul>
</li>
<li>Which cluster or clusters are overrepresented in the customer dataset compared to the general population? Select at least one such cluster and infer what kind of people might be represented by that cluster. Use the principal component interpretations from step 2.3 or look at additional components to help you make this inference. Alternatively, you can use the <code>.inverse_transform()</code> method of the PCA and StandardScaler objects to transform centroids back to the original data space and interpret the retrieved values directly.</li>
<li>Perform a similar investigation for the underrepresented clusters. Which cluster or clusters are underrepresented in the customer dataset compared to the general population, and what kinds of people are typified by these clusters?</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Compare the proportion of data in each cluster for the customer data to the</span></span><br><span class="line"><span class="comment"># proportion of data in each cluster for the general population.</span></span><br><span class="line">result_customer = pd.Series(result_customer)</span><br><span class="line">customer_dist = result_customer.value_counts().sort_index()</span><br><span class="line">result = pd.Series(result)</span><br><span class="line">population_dist = result.value_counts().sort_index()</span><br><span class="line">final_df = pd.DataFrame([population_dist,customer_dist]).T</span><br><span class="line">final_df.columns = [<span class="string">'population_count'</span>,<span class="string">'customer_count'</span>]</span><br><span class="line">final_df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>population_count</th>
      <th>customer_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>90763</td>
      <td>4965</td>
    </tr>
    <tr>
      <td>1</td>
      <td>22018</td>
      <td>7866</td>
    </tr>
    <tr>
      <td>2</td>
      <td>42219</td>
      <td>19958</td>
    </tr>
    <tr>
      <td>3</td>
      <td>89706</td>
      <td>12487</td>
    </tr>
    <tr>
      <td>4</td>
      <td>87209</td>
      <td>3989</td>
    </tr>
    <tr>
      <td>5</td>
      <td>53588</td>
      <td>8490</td>
    </tr>
    <tr>
      <td>6</td>
      <td>54843</td>
      <td>13308</td>
    </tr>
    <tr>
      <td>7</td>
      <td>77417</td>
      <td>14154</td>
    </tr>
    <tr>
      <td>8</td>
      <td>69022</td>
      <td>2203</td>
    </tr>
    <tr>
      <td>9</td>
      <td>28866</td>
      <td>10496</td>
    </tr>
    <tr>
      <td>10</td>
      <td>7558</td>
      <td>17727</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sns.barplot(x=final_df.index,y=<span class="string">'population_count'</span>, data = final_df)</span><br><span class="line">plt.title(<span class="string">"Distribution of General Population"</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sns.barplot(x=final_df.index,y=<span class="string">'customer_count'</span>, data = final_df)</span><br><span class="line">plt.title(<span class="string">"Distribution of Customer data"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/02/05/Identify_Customer_Segments/output_81_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp_po = final_df[<span class="string">'population_count'</span>]/final_df[<span class="string">'population_count'</span>].sum()</span><br><span class="line">temp2_cu = final_df[<span class="string">'customer_count'</span>]/final_df[<span class="string">'customer_count'</span>].sum()</span><br><span class="line">final_df_percent = pd.DataFrame([temp_po,temp2_cu]).T</span><br><span class="line">final_df_percent.columns = [<span class="string">'population_percent'</span>,<span class="string">'customer_percent'</span>]</span><br><span class="line">diff = final_df_percent[<span class="string">'population_percent'</span>]-final_df_percent[<span class="string">'customer_percent'</span>]</span><br><span class="line">diff.sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>10   -0.141163
2    -0.104838
9    -0.044444
1    -0.032690
6    -0.027077
7     0.001829
5     0.012572
3     0.035963
8     0.091703
0     0.102704
4     0.105441
dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># What kinds of people are part of a cluster that is overrepresented in the</span></span><br><span class="line"><span class="comment"># customer data compared to the general population? Category 10</span></span><br><span class="line">cc10 = kmeans.cluster_centers_[<span class="number">10</span>]</span><br><span class="line">cc10 = pd.Series(cc10)</span><br><span class="line">cc10.sort_values(ascending=<span class="literal">False</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">cc10.head()</span><br></pre></td></tr></table></figure>




<pre><code>2     1.776055
4     1.090018
3     0.780223
10    0.501790
6     0.247969
dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feature_select[<span class="number">2</span>].sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>ANREDE_KZ     -0.346752
SEMIO_KAEM    -0.319185
SEMIO_DOM     -0.286983
SEMIO_KRIT    -0.262582
SEMIO_ERL     -0.199994
                 ...   
FINANZTYP_5    0.135987
SEMIO_KULT     0.246536
SEMIO_SOZ      0.257146
SEMIO_FAM      0.260536
SEMIO_VERT     0.324047
Name: 2, Length: 189, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feature_select[<span class="number">4</span>].sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>LP_FAMILIE_FEIN_1.0    -0.327135
LP_FAMILIE_GROB_1.0    -0.327135
W_KEIT_KIND_HH         -0.220503
GREEN_AVANTGARDE       -0.140996
LP_STATUS_GROB_2.0     -0.136988
                          ...   
REGIOTYP                0.155014
LP_FAMILIE_FEIN_10.0    0.192443
KKK                     0.204874
LP_FAMILIE_GROB_5.0     0.253148
ANZ_PERSONEN            0.285127
Name: 4, Length: 189, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># What kinds of people are part of a cluster that is underrepresented in the</span></span><br><span class="line"><span class="comment"># customer data compared to the general population? Category 4</span></span><br><span class="line">cc4 = kmeans.cluster_centers_[<span class="number">4</span>]</span><br><span class="line">cc4 = pd.Series(cc4)</span><br><span class="line">cc4.sort_values(ascending=<span class="literal">False</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">cc4.head()</span><br></pre></td></tr></table></figure>




<pre><code>1     6.917713
6     3.135301
3     1.403937
8     1.179948
22    1.159860
dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feature_select[<span class="number">1</span>].sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>decade                  -0.228497
SEMIO_REL               -0.213832
FINANZ_SPARER           -0.212535
FINANZ_UNAUFFAELLIGER   -0.207468
SEMIO_PFLICHT           -0.205000
                           ...   
RETOURTYP_BK_S           0.156204
SEMIO_ERL                0.181138
ZABEOTYP_3               0.197800
FINANZ_VORSORGER         0.205081
ALTERSKATEGORIE_GROB     0.225616
Name: 1, Length: 189, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feature_select[<span class="number">6</span>].sort_values()</span><br></pre></td></tr></table></figure>




<pre><code>GEBAEUDETYP_1.0      -0.236870
GEBAEUDETYP_RASTER   -0.209850
LP_STATUS_GROB_2.0   -0.195907
CAMEO_DEUG_2015_6    -0.169896
KBA05_ANTG3          -0.151434
                        ...   
KBA05_ANTG4           0.139343
LP_STATUS_GROB_4.0    0.145008
LP_STATUS_FEIN_6.0    0.264746
GEBAEUDETYP_3.0       0.290512
LP_STATUS_GROB_3.0    0.295362
Name: 6, Length: 189, dtype: float64</code></pre><h3 id="Discussion-3-3-Compare-Customer-Data-to-Demographics-Data"><a href="#Discussion-3-3-Compare-Customer-Data-to-Demographics-Data" class="headerlink" title="Discussion 3.3: Compare Customer Data to Demographics Data"></a>Discussion 3.3: Compare Customer Data to Demographics Data</h3><p>Overrepresented: The category 10, which represents females who are dreamful and might be single parent with child of full age.<br>Underrepresented: The category 4, which represents elderly independent workers with age greater than 60, financial typology is ‘be prepared’.</p>
<blockquote>
<p>Congratulations on making it this far in the project! Before you finish, make sure to check through the entire notebook from top to bottom to make sure that your analysis follows a logical flow and all of your findings are documented in <strong>Discussion</strong> cells. Once you’ve checked over all of your work, you should export the notebook as an HTML document to submit for evaluation. You can do this from the menu, navigating to <strong>File -&gt; Download as -&gt; HTML (.html)</strong>. You will submit both that document and this notebook for your project submission.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</font>]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>无监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 如何优雅的加入Rmarkdown生成的html/pdf文件</title>
    <url>/2020/01/25/Hexo%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%8A%A0%E5%85%A5Rmarkdown%E7%94%9F%E6%88%90%E7%9A%84html%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<font size="3">

<p>如何加入自己创建的html文件,以及如何忽略在_source文件夹中的.md 或者 .html文件。</p>
<a id="more"></a>
<hr>
<p>在加入Rmarkdown生成的html的时候我发现自身的排版非常难看,也不会自动在博客生成标签和分类,那么有一个解决办法就是插入html文件在博客里。插入的方法是在markdown中使用iframe:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;filename.html&quot; width&#x3D;&quot;700&quot; height&#x3D;&quot;800&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>

<p>同样和插入图片方式大同小异我们创建一个和md文件一模一样名字的文件夹,把要插入的html文件放入其中就行,不需要绝对路径。</p>
<p>但是这时候就有一个问题,hexo会自动扫描所有_source文件夹中的文件,那么html文件就会被扫描到从而被渲染后上传到博客里,我们不希望有重复的内容,那么应该如何让hexo跳过扫描呢?</p>
<p>网上有几种方法,一种是在html文件的开头加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---  </span><br><span class="line">layout: false </span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>但是测试后发现并没有什么用。于是测试第二种方法,在站点配置文件下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render: &quot;filename.html&quot;</span><br></pre></td></tr></table></figure>
<p>同样测试发现行不通,查阅官方文档后发现可能因为版本问题路径不对,应该为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render: &quot;_posts&#x2F;文件夹名&#x2F;文件名.html&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>从_posts开始,如此一来就可以忽略这个文件渲染了,当然还可以忽略其他文件,也可以利用正则表达式来忽略某类命名的文件,目前还用不到。</p>
<p>希望大家少走弯路!</p>
<p>最后附上一个插入pdf的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% pdf .&#x2F;filename.pdf %&#125;</span><br></pre></td></tr></table></figure>
<p>同样把文件放在md同名文件夹下就行了。</p>
<hr>
<p>目录: <a href="https://www.guojingde.cn/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用GitHub搭建个人博客(目录)</a></p>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>银行客户画像分析2-机器学习 with Python</title>
    <url>/2020/01/25/bank_user_profile2/</url>
    <content><![CDATA[<p>分析银行客户画像并预测是否会在该银行存款,本篇基于上一篇,使用Python进行模型建立,模型选择,参数优化,特征选择等。</p>
<a id="more"></a>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import libraries necessary for this project</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display <span class="comment"># Allows the use of display() for DataFrames</span></span><br><span class="line"><span class="comment"># Import train_test_split</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">"processed_data1.csv"</span>)</span><br><span class="line">target = data[<span class="string">'target'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = data.drop(<span class="string">'Unnamed: 0'</span>, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = data.drop(<span class="string">'target'</span>, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="分训练集和测试集"><a href="#分训练集和测试集" class="headerlink" title="分训练集和测试集"></a>分训练集和测试集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Split the 'features' and 'income' data into training and testing sets</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(features, </span><br><span class="line">                                                    target, </span><br><span class="line">                                                    test_size = <span class="number">0.2</span>, </span><br><span class="line">                                                    random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the results of the split</span></span><br><span class="line">print(<span class="string">"Training set has &#123;&#125; samples."</span>.format(X_train.shape[<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"Testing set has &#123;&#125; samples."</span>.format(X_test.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>Training set has 32950 samples.
Testing set has 8238 samples.</code></pre><h3 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> fbeta_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_predict</span><span class="params">(learner, sample_size, X_train, y_train, X_test, y_test)</span>:</span> </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    inputs:</span></span><br><span class="line"><span class="string">       - learner: the learning algorithm to be trained and predicted on</span></span><br><span class="line"><span class="string">       - sample_size: the size of samples (number) to be drawn from training set</span></span><br><span class="line"><span class="string">       - X_train: features training set</span></span><br><span class="line"><span class="string">       - y_train: income training set</span></span><br><span class="line"><span class="string">       - X_test: features testing set</span></span><br><span class="line"><span class="string">       - y_test: income testing set</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Fit the learner to the training data using slicing with 'sample_size' using .fit(training_features[:], training_labels[:])</span></span><br><span class="line">    start = time() <span class="comment"># Get start time</span></span><br><span class="line">    learner = learner.fit(X_train[:sample_size:], y_train[:sample_size].values.ravel())</span><br><span class="line">    end = time() <span class="comment"># Get end time</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate the training time</span></span><br><span class="line">    results[<span class="string">'train_time'</span>] = end - start</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Get the predictions on the test set(X_test),</span></span><br><span class="line">    <span class="comment">#       then get predictions on the first 300 training samples(X_train) using .predict()</span></span><br><span class="line">    start = time() <span class="comment"># Get start time</span></span><br><span class="line">    predictions_test = learner.predict(X_test)</span><br><span class="line">    predictions_train = learner.predict(X_train[:<span class="number">300</span>])</span><br><span class="line">    end = time() <span class="comment"># Get end time</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate the total prediction time</span></span><br><span class="line">    results[<span class="string">'pred_time'</span>] = end - start</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Compute accuracy on the first 300 training samples which is y_train[:300]</span></span><br><span class="line">    results[<span class="string">'acc_train'</span>] = accuracy_score(y_train[:<span class="number">300</span>], predictions_train)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Compute accuracy on test set using accuracy_score()</span></span><br><span class="line">    results[<span class="string">'acc_test'</span>] = accuracy_score(y_test, predictions_test)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute F-score on the the first 300 training samples using fbeta_score()</span></span><br><span class="line">    results[<span class="string">'f_train'</span>] = fbeta_score(y_train[:<span class="number">300</span>], predictions_train, beta = <span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Compute F-score on the test set which is y_test</span></span><br><span class="line">    results[<span class="string">'f_test'</span>] = fbeta_score(y_test, predictions_test, beta = <span class="number">0.5</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># Success</span></span><br><span class="line">    print(<span class="string">"&#123;&#125; trained on &#123;&#125; samples."</span>.format(learner.__class__.__name__, sample_size))</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Return the results</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import the three supervised learning models from sklearn</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">2020</span>)</span><br><span class="line"><span class="comment"># Initialize the three models</span></span><br><span class="line">clf_A = LogisticRegression(solver = <span class="string">'liblinear'</span>) <span class="comment"># set the default value manually in order to get rid of warnings</span></span><br><span class="line">clf_B = RandomForestClassifier(n_estimators = <span class="number">100</span>) <span class="comment"># set the default value manually in order to get rid of warnings</span></span><br><span class="line">clf_C = KNeighborsClassifier() <span class="comment"># set the default value manually in order to get rid of warnings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the number of samples for 1%, 10%, and 100% of the training data</span></span><br><span class="line">samples_100 = len(y_train)</span><br><span class="line">samples_10 = int(len(y_train)*<span class="number">0.1</span>)</span><br><span class="line">samples_1 = int(len(y_train)*<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Collect results on the learners</span></span><br><span class="line">results = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> clf <span class="keyword">in</span> [clf_A, clf_B, clf_C]:</span><br><span class="line">    clf_name = clf.__class__.__name__</span><br><span class="line">    results[clf_name] = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, samples <span class="keyword">in</span> enumerate([samples_1, samples_10, samples_100]):</span><br><span class="line">        results[clf_name][i] = \</span><br><span class="line">        train_predict(clf, samples, X_train, y_train, X_test, y_test)</span><br></pre></td></tr></table></figure>

<pre><code>LogisticRegression trained on 329 samples.
LogisticRegression trained on 3295 samples.
LogisticRegression trained on 32950 samples.
RandomForestClassifier trained on 329 samples.
RandomForestClassifier trained on 3295 samples.
RandomForestClassifier trained on 32950 samples.
KNeighborsClassifier trained on 329 samples.
KNeighborsClassifier trained on 3295 samples.
KNeighborsClassifier trained on 32950 samples.</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">results</span><br></pre></td></tr></table></figure>




<pre><code>{&apos;LogisticRegression&apos;: {0: {&apos;train_time&apos;: 0.0019948482513427734,
   &apos;pred_time&apos;: 0.004987239837646484,
   &apos;acc_train&apos;: 0.8866666666666667,
   &apos;acc_test&apos;: 0.8869871327992231,
   &apos;f_train&apos;: 0.6201550387596898,
   &apos;f_test&apos;: 0.39245863793766833},
  1: {&apos;train_time&apos;: 0.01795196533203125,
   &apos;pred_time&apos;: 0.003989219665527344,
   &apos;acc_train&apos;: 0.86,
   &apos;acc_test&apos;: 0.8990046127700898,
   &apos;f_train&apos;: 0.4744525547445255,
   &apos;f_test&apos;: 0.4798698657991053},
  2: {&apos;train_time&apos;: 0.3007650375366211,
   &apos;pred_time&apos;: 0.003989219665527344,
   &apos;acc_train&apos;: 0.8533333333333334,
   &apos;acc_test&apos;: 0.8980335032774945,
   &apos;f_train&apos;: 0.42635658914728686,
   &apos;f_test&apos;: 0.45267489711934156}},
 &apos;RandomForestClassifier&apos;: {0: {&apos;train_time&apos;: 0.0638282299041748,
   &apos;pred_time&apos;: 0.0827479362487793,
   &apos;acc_train&apos;: 1.0,
   &apos;acc_test&apos;: 0.8874726875455208,
   &apos;f_train&apos;: 1.0,
   &apos;f_test&apos;: 0.35665914221218964},
  1: {&apos;train_time&apos;: 0.2373659610748291,
   &apos;pred_time&apos;: 0.10571742057800293,
   &apos;acc_train&apos;: 0.9966666666666667,
   &apos;acc_test&apos;: 0.8958485069191552,
   &apos;f_train&apos;: 0.9954751131221717,
   &apos;f_test&apos;: 0.4736275565123789},
  2: {&apos;train_time&apos;: 2.7166779041290283,
   &apos;pred_time&apos;: 0.16755199432373047,
   &apos;acc_train&apos;: 0.99,
   &apos;acc_test&apos;: 0.896091284292304,
   &apos;f_train&apos;: 0.9859154929577465,
   &apos;f_test&apos;: 0.47669868374244045}},
 &apos;KNeighborsClassifier&apos;: {0: {&apos;train_time&apos;: 0.0019948482513427734,
   &apos;pred_time&apos;: 0.3361320495605469,
   &apos;acc_train&apos;: 0.8833333333333333,
   &apos;acc_test&apos;: 0.888443797038116,
   &apos;f_train&apos;: 0.5982905982905984,
   &apos;f_test&apos;: 0.3638017280582083},
  1: {&apos;train_time&apos;: 0.007975578308105469,
   &apos;pred_time&apos;: 1.4731249809265137,
   &apos;acc_train&apos;: 0.88,
   &apos;acc_test&apos;: 0.8903860160233066,
   &apos;f_train&apos;: 0.5813953488372093,
   &apos;f_test&apos;: 0.430752453653217},
  2: {&apos;train_time&apos;: 0.4777207374572754,
   &apos;pred_time&apos;: 6.75963830947876,
   &apos;acc_train&apos;: 0.8633333333333333,
   &apos;acc_test&apos;: 0.8956057295460063,
   &apos;f_train&apos;: 0.5202312138728323,
   &apos;f_test&apos;: 0.47895997263085877}}}</code></pre><p>最好的是KNN,在训练所有训练集后,准确率达到89.6%,但是$F_{0.5}$ score 只有0.48,意味着在预测非存款对象的准确度远高于预测存款对象的准确度,这不利于我们找出潜在的存款对象,我们继续利用网格搜索来优化我们的参数和模型。</p>
<h3 id="其他数据集"><a href="#其他数据集" class="headerlink" title="其他数据集"></a>其他数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>]</span><br><span class="line">accuracy_all = []</span><br><span class="line">f_all = []</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> i:</span><br><span class="line">    data = pd.read_csv(<span class="string">"processed_data"</span>+ each +<span class="string">".csv"</span>)</span><br><span class="line">    target = data[<span class="string">'target'</span>]</span><br><span class="line">    data = data.drop(<span class="string">'Unnamed: 0'</span>, axis = <span class="number">1</span>)</span><br><span class="line">    features = data.drop(<span class="string">'target'</span>, axis = <span class="number">1</span>)</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(features, </span><br><span class="line">                                                        target, </span><br><span class="line">                                                        test_size = <span class="number">0.2</span>, </span><br><span class="line">                                                        random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    clf_C = KNeighborsClassifier()</span><br><span class="line">    learner = clf_C.fit(X_train, y_train.values.ravel())</span><br><span class="line">    predictions_test = learner.predict(X_test)</span><br><span class="line">    accuracy_all.append(accuracy_score(y_test, predictions_test))</span><br><span class="line">    f_all.append(fbeta_score(y_test, predictions_test, beta = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(accuracy_all)</span><br><span class="line">print(f_all)</span><br></pre></td></tr></table></figure>

<pre><code>[0.895241563486283, 0.8958485069191552, 0.8969410050983249, 0.8958485069191552]
[0.4761904761904762, 0.481064483111566, 0.48780487804878053, 0.47987616099071206]</code></pre><p>准确性和$F_{0.5}$ score 在不同数据集差不多,说明cart来填补缺失值的方法有一致性。</p>
<h3 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> make_scorer</span><br><span class="line">random.seed(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Initialize the classifier</span></span><br><span class="line">clf = KNeighborsClassifier()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the parameters list you wish to tune, using a dictionary if needed.</span></span><br><span class="line">k_range = list(range(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">parameters = &#123; <span class="string">'algorithm'</span> : [<span class="string">'auto'</span>,<span class="string">'ball_tree'</span>,<span class="string">'kd_tree'</span>,<span class="string">'brute'</span>], <span class="string">'weights'</span> : [<span class="string">'uniform'</span>,<span class="string">'distance'</span>], <span class="string">'n_neighbors'</span> : k_range&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make an fbeta_score scoring object using make_scorer()</span></span><br><span class="line">scorer = make_scorer(fbeta_score, beta = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perform grid search on the classifier using 'scorer' as the scoring method using GridSearchCV()</span></span><br><span class="line">grid_obj = GridSearchCV(clf, parameters, scoring=scorer, cv = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit the grid search object to the training data and find the optimal parameters using fit()</span></span><br><span class="line">grid_fit = grid_obj.fit(X_train, y_train.values.ravel())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the estimator</span></span><br><span class="line">best_clf = grid_fit.best_estimator_</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions using the unoptimized and model</span></span><br><span class="line">predictions = (clf.fit(X_train, y_train.values.ravel())).predict(X_test)</span><br><span class="line">best_predictions = best_clf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report the before-and-afterscores</span></span><br><span class="line">print(<span class="string">"Unoptimized model\n------"</span>)</span><br><span class="line">print(<span class="string">"Accuracy score on testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, predictions)))</span><br><span class="line">print(<span class="string">"F-score on testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, predictions, beta = <span class="number">0.5</span>)))</span><br><span class="line">print(<span class="string">"\nOptimized Model\n------"</span>)</span><br><span class="line">print(<span class="string">"Final accuracy score on the testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, best_predictions)))</span><br><span class="line">print(<span class="string">"Final F-score on the testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, best_predictions, beta = <span class="number">0.5</span>)))</span><br><span class="line">print(<span class="string">'best params are:'</span>,str(grid_obj.best_params_))</span><br></pre></td></tr></table></figure>

<pre><code>Unoptimized model
------
Accuracy score on testing data: 0.8958
F-score on testing data: 0.4799

Optimized Model
------
Final accuracy score on the testing data: 0.8989
Final F-score on the testing data: 0.4920
best params are: {&apos;algorithm&apos;: &apos;brute&apos;, &apos;n_neighbors&apos;: 9, &apos;weights&apos;: &apos;uniform&apos;}</code></pre><h3 id="Cutoff-value"><a href="#Cutoff-value" class="headerlink" title="Cutoff value"></a>Cutoff value</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">"processed_data5.csv"</span>)</span><br><span class="line">target = data[<span class="string">'target'</span>]</span><br><span class="line">data = data.drop(<span class="string">'Unnamed: 0'</span>, axis = <span class="number">1</span>)</span><br><span class="line">features = data.drop(<span class="string">'target'</span>, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># accurate and f score in test set with cutoff = 0.5</span></span><br><span class="line">random.seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(features, </span><br><span class="line">                                                    target, </span><br><span class="line">                                                    test_size = <span class="number">0.1</span>, </span><br><span class="line">                                                    random_state = <span class="number">0</span>)</span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=<span class="number">0.1</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">clf_C = KNeighborsClassifier(algorithm = <span class="string">'brute'</span>,n_neighbors = <span class="number">9</span>, weights = <span class="string">'uniform'</span>)</span><br><span class="line">learner = clf_C.fit(X_train, y_train.values.ravel())</span><br><span class="line">predictions_test = learner.predict(X_test)</span><br><span class="line">print(accuracy_score(y_test, predictions_test))</span><br><span class="line">print(fbeta_score(y_test, predictions_test, beta = <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>

<pre><code>0.8990046127700898
0.4892086330935252</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> recall_score</span><br><span class="line">confusion_matrix(y_test, predictions_test) <span class="comment"># 默认cutoff为p = 0.5</span></span><br></pre></td></tr></table></figure>




<pre><code>array([[3567,   98],
       [ 318,  136]], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predictions_test_p = learner.predict_proba(X_test)</span><br><span class="line">predictions_test_p=pd.DataFrame(predictions_test_p)[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 我们看到选取0.3 cutoff 真的1的预测数明显上升</span></span><br><span class="line">predictions_test_pfinal = predictions_test_p&gt;=<span class="number">0.3</span></span><br><span class="line">predictions_test_pfinal=predictions_test_pfinal.astype(int)</span><br><span class="line">confusion_matrix(y_test, predictions_test_pfinal)</span><br></pre></td></tr></table></figure>




<pre><code>array([[3377,  288],
       [ 230,  224]], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到最佳cutoff</span></span><br><span class="line">i = [<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.5</span>,<span class="number">0.6</span>,<span class="number">0.7</span>,<span class="number">0.8</span>,<span class="number">0.9</span>,<span class="number">1</span>]</span><br><span class="line">accuracy_s = []</span><br><span class="line">f_s = []</span><br><span class="line">precision_s = []</span><br><span class="line">recall_s=[]</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> i:</span><br><span class="line">    predictions_test_pfinal = predictions_test_p&gt;=each</span><br><span class="line">    predictions_test_pfinal=predictions_test_pfinal.astype(int)</span><br><span class="line">    f_s.append(fbeta_score(y_test, predictions_test_pfinal, beta = <span class="number">1</span>))</span><br><span class="line">    accuracy_s.append(accuracy_score(y_test, predictions_test_pfinal))</span><br><span class="line">    precision_s.append(precision_score(y_test, predictions_test_pfinal))</span><br><span class="line">    recall_s.append(recall_score(y_test, predictions_test_pfinal))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(i,precision_s, color=<span class="string">'green'</span>, label=<span class="string">'precision'</span>)</span><br><span class="line">plt.plot(i,recall_s, color=<span class="string">'red'</span>, label=<span class="string">'recall'</span>)</span><br><span class="line">plt.plot(i,accuracy_s, color=<span class="string">'blue'</span>, label=<span class="string">'accuracy'</span>)</span><br><span class="line">plt.plot(i,f_s,color=<span class="string">'black'</span>,label=<span class="string">'F1 score'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">'cutoff value'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'rate'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/01/25/bank_user_profile2/output_24_0.png" alt="png"></p>
<p>根据图表我们可以看出在 cutoff value大致在0.33左右我们大致得到一个比较均衡的预测结果,如果我们要提高precision,也就是保证精准的找到愿意存款的人,那么我们可以选择较高的cutoff value来保持精准定位,但同时也会放弃更多的潜在的客户(节约成本),如果我们要提高recall,也就是希望覆盖更多的潜在客户,那么就要选择较低的cutoff value,这样成本会上升。</p>
<p>最后我们在验证集中验证我们的结论,我们先选择p=0.18</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># validation set</span></span><br><span class="line"></span><br><span class="line">predictions_val_p = learner.predict_proba(X_val)</span><br><span class="line">predictions_val_p=pd.DataFrame(predictions_val_p)[<span class="number">1</span>]</span><br><span class="line">predictions_val_pfinal = predictions_val_p&gt;=<span class="number">0.18</span></span><br><span class="line">predictions_val_pfinal=predictions_val_pfinal.astype(int)</span><br><span class="line">print(confusion_matrix(y_val, predictions_val_pfinal))</span><br><span class="line">print(recall_score(y_val, predictions_val_pfinal))</span><br><span class="line">print(precision_score(y_val, predictions_val_pfinal))</span><br></pre></td></tr></table></figure>

<pre><code>[[2724  542]
 [ 173  268]]
0.6077097505668935
0.3308641975308642</code></pre><p>可以发现在总共441位潜在客户里我们预测到了268位,达到了60.7%。但是我们预测的810位顾客里只有268位是正确的,精准度为33%。当然不使用模型的精准度为11.9%。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># validation set</span></span><br><span class="line">predictions_val_p = learner.predict_proba(X_val)</span><br><span class="line">predictions_val_p=pd.DataFrame(predictions_val_p)[<span class="number">1</span>]</span><br><span class="line">predictions_val_pfinal = predictions_val_p&gt;=<span class="number">0.8</span></span><br><span class="line">predictions_val_pfinal=predictions_val_pfinal.astype(int)</span><br><span class="line">print(confusion_matrix(y_val, predictions_val_pfinal))</span><br><span class="line">print(recall_score(y_val, predictions_val_pfinal))</span><br><span class="line">print(precision_score(y_val, predictions_val_pfinal))</span><br></pre></td></tr></table></figure>

<pre><code>[[3257    9]
 [ 419   22]]
0.049886621315192746
0.7096774193548387</code></pre><p>可以发现调高cutoff value后,我们的预测变得更加谨慎,在预测的31位潜在客户里有22位是真的潜在客户,达到了71%的正确率。但是覆盖面不够广,损失了大多数的潜在客户。</p>
<h3 id="Feature-Selection"><a href="#Feature-Selection" class="headerlink" title="Feature Selection"></a>Feature Selection</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import a supervised learning model that has 'feature_importances_'</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the supervised model on the training set using .fit(X_train, y_train)</span></span><br><span class="line">param_dist = &#123;<span class="string">"max_depth"</span>: [<span class="number">3</span>, <span class="literal">None</span>],</span><br><span class="line">              <span class="string">"n_estimators"</span>: list(range(<span class="number">10</span>, <span class="number">200</span>)),</span><br><span class="line">              <span class="string">"max_features"</span>: list(range(<span class="number">1</span>, X_test.shape[<span class="number">1</span>]+<span class="number">1</span>)),</span><br><span class="line">              <span class="string">"min_samples_split"</span>: list(range(<span class="number">2</span>, <span class="number">11</span>)),</span><br><span class="line">              <span class="string">"min_samples_leaf"</span>: list(range(<span class="number">1</span>, <span class="number">11</span>)),</span><br><span class="line">              <span class="string">"bootstrap"</span>: [<span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">              <span class="string">"criterion"</span>: [<span class="string">"gini"</span>, <span class="string">"entropy"</span>]&#125;</span><br><span class="line">model = RandomizedSearchCV(clf_B, param_distributions=param_dist)</span><br><span class="line">model.fit(X_train, y_train.values.ravel())</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Extract the feature importances using .feature_importances_ </span></span><br><span class="line">importances = model.best_estimator_.feature_importances_</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\jasonguo\Anaconda3\lib\site-packages\sklearn\model_selection\_split.py:1978: FutureWarning: The default value of cv will change from 3 to 5 in version 0.22. Specify it explicitly to silence this warning.
  warnings.warn(CV_WARNING, FutureWarning)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Plot</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pl</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_plot</span><span class="params">(importances, X_train, y_train)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display the five most important features</span></span><br><span class="line">    indices = np.argsort(importances)[::<span class="number">-1</span>]</span><br><span class="line">    columns = X_train.columns.values[indices[:<span class="number">5</span>]]</span><br><span class="line">    values = importances[indices][:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Creat the plot</span></span><br><span class="line">    fig = pl.figure(figsize = (<span class="number">9</span>,<span class="number">5</span>))</span><br><span class="line">    pl.title(<span class="string">"Normalized Weights for First Five Most Predictive Features"</span>, fontsize = <span class="number">16</span>)</span><br><span class="line">    pl.bar(np.arange(<span class="number">5</span>), values, width = <span class="number">0.6</span>, align=<span class="string">"center"</span>, color = <span class="string">'#00A000'</span>, \</span><br><span class="line">          label = <span class="string">"Feature Weight"</span>)</span><br><span class="line">    pl.bar(np.arange(<span class="number">5</span>) - <span class="number">0.3</span>, np.cumsum(values), width = <span class="number">0.2</span>, align = <span class="string">"center"</span>, color = <span class="string">'#00A0A0'</span>, \</span><br><span class="line">          label = <span class="string">"Cumulative Feature Weight"</span>)</span><br><span class="line">    pl.xticks(np.arange(<span class="number">5</span>), columns)</span><br><span class="line">    pl.xlim((<span class="number">-0.5</span>, <span class="number">4.5</span>))</span><br><span class="line">    pl.ylabel(<span class="string">"Weight"</span>, fontsize = <span class="number">12</span>)</span><br><span class="line">    pl.xlabel(<span class="string">"Feature"</span>, fontsize = <span class="number">12</span>)</span><br><span class="line">    </span><br><span class="line">    pl.legend(loc = <span class="string">'upper center'</span>)</span><br><span class="line">    pl.tight_layout()</span><br><span class="line">    pl.show()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feature_plot(importances, X_train, y_train)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/01/25/bank_user_profile2/output_34_0.png" alt="png"></p>
<p>可以看到前五个重要的指标,第一个是雇佣员工数,第二个是欧洲银行间利率,第三个是年龄,第四个和第五个都是受访相关参数。私以为,机器学习和计量经济学的方法不同之处在于机器学习更加注重预测结果的准确性,而忽视了预测结果和参数直接的因果关系,这些因果关系是很难通过机器学习的一些方法被解释的,即使预测结果非常准确,但是一些参数可能和预测目标没有实际的相关性。接下来就使用计量经济学的方法来研究哪些因素可能导致用户存款。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> clone</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce the feature space</span></span><br><span class="line">X_train_reduced = X_train[X_train.columns.values[(np.argsort(importances)[::<span class="number">-1</span>])[:<span class="number">5</span>]]]</span><br><span class="line">X_test_reduced = X_test[X_test.columns.values[(np.argsort(importances)[::<span class="number">-1</span>])[:<span class="number">5</span>]]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train on the "best" model found from grid search earlier</span></span><br><span class="line">clf = (clone(best_clf)).fit(X_train_reduced, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make new predictions</span></span><br><span class="line">reduced_predictions = clf.predict(X_test_reduced)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report scores from the final model using both versions of data</span></span><br><span class="line">print(<span class="string">"Final Model trained on full data\n------"</span>)</span><br><span class="line">print(<span class="string">"Accuracy on testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, best_predictions)))</span><br><span class="line">print(<span class="string">"F-score on testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, best_predictions, beta = <span class="number">0.5</span>)))</span><br><span class="line">print(<span class="string">"\nFinal Model trained on reduced data\n------"</span>)</span><br><span class="line">print(<span class="string">"Accuracy on testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, reduced_predictions)))</span><br><span class="line">print(<span class="string">"F-score on testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, reduced_predictions, beta = <span class="number">0.5</span>)))</span><br></pre></td></tr></table></figure>

<pre><code>Final Model trained on full data
------
Accuracy on testing data: 0.8989
F-score on testing data: 0.4920

Final Model trained on reduced data
------
Accuracy on testing data: 0.8934
F-score on testing data: 0.4420</code></pre><p>可以发现只取排名前五个参数的模型,F score 下降了一些, 意味着预测有存款意向的人的准确度变低了一些,但不是很多。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>银行客户画像分析1-数据预处理 with R</title>
    <url>/2020/01/24/bank_user_profile/</url>
    <content><![CDATA[<p>分析银行客户画像并预测是否会在该银行存款,本篇使用R语言进行数据预处理,使用CART方法填补缺失值,数据标准化以及one-hot encoding。</p>
<a id="more"></a>
<hr>
<iframe src="bank.html" width="700" height="800"></iframe>
















]]></content>
      <categories>
        <category>R学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>监督学习-寻找潜在的捐款者</title>
    <url>/2020/01/22/%E5%AF%BB%E6%89%BE%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%8D%90%E6%AC%BE%E8%80%85/</url>
    <content><![CDATA[<h2 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h2><h2 id="Project-Finding-Donors-for-CharityML"><a href="#Project-Finding-Donors-for-CharityML" class="headerlink" title="Project: Finding Donors for CharityML"></a>Project: Finding Donors for <em>CharityML</em></h2><p>In this project, you will employ several supervised algorithms of your choice to accurately model individuals’ income using data collected from the 1994 U.S. Census. You will then choose the best candidate algorithm from preliminary results and further optimize this algorithm to best model the data. Your goal with this implementation is to construct a model that accurately predicts whether an individual makes more than $50,000. </p>
<a id="more"></a>
<p>This sort of task can arise in a non-profit setting, where organizations survive on donations.  Understanding an individual’s income can help a non-profit better understand how large of a donation to request, or whether or not they should reach out to begin with.  While it can be difficult to determine an individual’s general income bracket directly from public sources, we can (as we will see) infer this value from other publically available features. </p>
<p>The dataset for this project originates from the <a href="https://archive.ics.uci.edu/ml/datasets/Census+Income" target="_blank" rel="noopener">UCI Machine Learning Repository</a>. The datset was donated by Ron Kohavi and Barry Becker, after being published in the article <em>“Scaling Up the Accuracy of Naive-Bayes Classifiers: A Decision-Tree Hybrid”</em>. You can find the article by Ron Kohavi <a href="https://www.aaai.org/Papers/KDD/1996/KDD96-033.pdf" target="_blank" rel="noopener">online</a>. The data we investigate here consists of small changes to the original dataset, such as removing the <code>&#39;fnlwgt&#39;</code> feature and records with missing or ill-formatted entries.</p>
<hr>
<h2 id="Exploring-the-Data"><a href="#Exploring-the-Data" class="headerlink" title="Exploring the Data"></a>Exploring the Data</h2><p>Run the code cell below to load necessary Python libraries and load the census data. Note that the last column from this dataset, <code>&#39;income&#39;</code>, will be our target label (whether an individual makes more than, or at most, $50,000 annually). All other columns are features about each individual in the census database.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import libraries necessary for this project</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display <span class="comment"># Allows the use of display() for DataFrames</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import supplementary visualization code visuals.py</span></span><br><span class="line"><span class="keyword">import</span> visuals <span class="keyword">as</span> vs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pretty display for notebooks</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the Census dataset</span></span><br><span class="line">data = pd.read_csv(<span class="string">"census.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Success - Display the first record</span></span><br><span class="line">display(data.head(n=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>workclass</th>
      <th>education_level</th>
      <th>education-num</th>
      <th>marital-status</th>
      <th>occupation</th>
      <th>relationship</th>
      <th>race</th>
      <th>sex</th>
      <th>capital-gain</th>
      <th>capital-loss</th>
      <th>hours-per-week</th>
      <th>native-country</th>
      <th>income</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>39</td>
      <td>State-gov</td>
      <td>Bachelors</td>
      <td>13.0</td>
      <td>Never-married</td>
      <td>Adm-clerical</td>
      <td>Not-in-family</td>
      <td>White</td>
      <td>Male</td>
      <td>2174.0</td>
      <td>0.0</td>
      <td>40.0</td>
      <td>United-States</td>
      <td>&lt;=50K</td>
    </tr>
  </tbody>
</table>
</div>


<h3 id="Implementation-Data-Exploration"><a href="#Implementation-Data-Exploration" class="headerlink" title="Implementation: Data Exploration"></a>Implementation: Data Exploration</h3><p>A cursory investigation of the dataset will determine how many individuals fit into either group, and will tell us about the percentage of these individuals making more than $50,000. In the code cell below, you will need to compute the following:</p>
<ul>
<li>The total number of records, <code>&#39;n_records&#39;</code></li>
<li>The number of individuals making more than $50,000 annually, <code>&#39;n_greater_50k&#39;</code>.</li>
<li>The number of individuals making at most $50,000 annually, <code>&#39;n_at_most_50k&#39;</code>.</li>
<li>The percentage of individuals making more than $50,000 annually, <code>&#39;greater_percent&#39;</code>.</li>
</ul>
<p>** HINT: ** You may need to look at the table above to understand how the <code>&#39;income&#39;</code> entries are formatted. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Total number of records</span></span><br><span class="line">n_records = len(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Number of records where individual's income is more than $50,000</span></span><br><span class="line">n_greater_50k = len(data.income[data.income == <span class="string">'&gt;50K'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Number of records where individual's income is at most $50,000</span></span><br><span class="line">n_at_most_50k = len(data.income[data.income == <span class="string">'&lt;=50K'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Percentage of individuals whose income is more than $50,000</span></span><br><span class="line">greater_percent = n_greater_50k/n_records*<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the results</span></span><br><span class="line">print(<span class="string">"Total number of records: &#123;&#125;"</span>.format(n_records))</span><br><span class="line">print(<span class="string">"Individuals making more than $50,000: &#123;&#125;"</span>.format(n_greater_50k))</span><br><span class="line">print(<span class="string">"Individuals making at most $50,000: &#123;&#125;"</span>.format(n_at_most_50k))</span><br><span class="line">print(<span class="string">"Percentage of individuals making more than $50,000: &#123;&#125;%"</span>.format(greater_percent))</span><br></pre></td></tr></table></figure>

<pre><code>Total number of records: 45222
Individuals making more than $50,000: 11208
Individuals making at most $50,000: 34014
Percentage of individuals making more than $50,000: 24.78439697492371%</code></pre><p>** Featureset Exploration **</p>
<ul>
<li><strong>age</strong>: continuous. </li>
<li><strong>workclass</strong>: Private, Self-emp-not-inc, Self-emp-inc, Federal-gov, Local-gov, State-gov, Without-pay, Never-worked. </li>
<li><strong>education</strong>: Bachelors, Some-college, 11th, HS-grad, Prof-school, Assoc-acdm, Assoc-voc, 9th, 7th-8th, 12th, Masters, 1st-4th, 10th, Doctorate, 5th-6th, Preschool. </li>
<li><strong>education-num</strong>: continuous. </li>
<li><strong>marital-status</strong>: Married-civ-spouse, Divorced, Never-married, Separated, Widowed, Married-spouse-absent, Married-AF-spouse. </li>
<li><strong>occupation</strong>: Tech-support, Craft-repair, Other-service, Sales, Exec-managerial, Prof-specialty, Handlers-cleaners, Machine-op-inspct, Adm-clerical, Farming-fishing, Transport-moving, Priv-house-serv, Protective-serv, Armed-Forces. </li>
<li><strong>relationship</strong>: Wife, Own-child, Husband, Not-in-family, Other-relative, Unmarried. </li>
<li><strong>race</strong>: Black, White, Asian-Pac-Islander, Amer-Indian-Eskimo, Other. </li>
<li><strong>sex</strong>: Female, Male. </li>
<li><strong>capital-gain</strong>: continuous. </li>
<li><strong>capital-loss</strong>: continuous. </li>
<li><strong>hours-per-week</strong>: continuous. </li>
<li><strong>native-country</strong>: United-States, Cambodia, England, Puerto-Rico, Canada, Germany, Outlying-US(Guam-USVI-etc), India, Japan, Greece, South, China, Cuba, Iran, Honduras, Philippines, Italy, Poland, Jamaica, Vietnam, Mexico, Portugal, Ireland, France, Dominican-Republic, Laos, Ecuador, Taiwan, Haiti, Columbia, Hungary, Guatemala, Nicaragua, Scotland, Thailand, Yugoslavia, El-Salvador, Trinadad&amp;Tobago, Peru, Hong, Holand-Netherlands.</li>
</ul>
<hr>
<h2 id="Preparing-the-Data"><a href="#Preparing-the-Data" class="headerlink" title="Preparing the Data"></a>Preparing the Data</h2><p>Before data can be used as input for machine learning algorithms, it often must be cleaned, formatted, and restructured — this is typically known as <strong>preprocessing</strong>. Fortunately, for this dataset, there are no invalid or missing entries we must deal with, however, there are some qualities about certain features that must be adjusted. This preprocessing can help tremendously with the outcome and predictive power of nearly all learning algorithms.</p>
<h3 id="Transforming-Skewed-Continuous-Features"><a href="#Transforming-Skewed-Continuous-Features" class="headerlink" title="Transforming Skewed Continuous Features"></a>Transforming Skewed Continuous Features</h3><p>A dataset may sometimes contain at least one feature whose values tend to lie near a single number, but will also have a non-trivial number of vastly larger or smaller values than that single number.  Algorithms can be sensitive to such distributions of values and can underperform if the range is not properly normalized. With the census dataset two features fit this description: ‘<code>capital-gain&#39;</code> and <code>&#39;capital-loss&#39;</code>. </p>
<p>Run the code cell below to plot a histogram of these two features. Note the range of the values present and how they are distributed.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Split the data into features and target label</span></span><br><span class="line">income_raw = data[<span class="string">'income'</span>]</span><br><span class="line">features_raw = data.drop(<span class="string">'income'</span>, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize skewed continuous features of original data</span></span><br><span class="line">vs.distribution(data)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/01/22/%E5%AF%BB%E6%89%BE%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%8D%90%E6%AC%BE%E8%80%85/output_10_0.png" alt="png"></p>
<p>For highly-skewed feature distributions such as <code>&#39;capital-gain&#39;</code> and <code>&#39;capital-loss&#39;</code>, it is common practice to apply a <a href="https://en.wikipedia.org/wiki/Data_transformation_(statistics)" target="_blank" rel="noopener">logarithmic transformation</a> on the data so that the very large and very small values do not negatively affect the performance of a learning algorithm. Using a logarithmic transformation significantly reduces the range of values caused by outliers. Care must be taken when applying this transformation however: The logarithm of <code>0</code> is undefined, so we must translate the values by a small amount above <code>0</code> to apply the the logarithm successfully.</p>
<p>Run the code cell below to perform a transformation on the data and visualize the results. Again, note the range of values and how they are distributed. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Log-transform the skewed features</span></span><br><span class="line">skewed = [<span class="string">'capital-gain'</span>, <span class="string">'capital-loss'</span>]</span><br><span class="line">features_log_transformed = pd.DataFrame(data = features_raw)</span><br><span class="line">features_log_transformed[skewed] = features_raw[skewed].apply(<span class="keyword">lambda</span> x: np.log(x + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize the new log distributions</span></span><br><span class="line">vs.distribution(features_log_transformed, transformed = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/2020/01/22/%E5%AF%BB%E6%89%BE%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%8D%90%E6%AC%BE%E8%80%85/output_12_0.png" alt="png"></p>
<h3 id="Normalizing-Numerical-Features"><a href="#Normalizing-Numerical-Features" class="headerlink" title="Normalizing Numerical Features"></a>Normalizing Numerical Features</h3><p>In addition to performing transformations on features that are highly skewed, it is often good practice to perform some type of scaling on numerical features. Applying a scaling to the data does not change the shape of each feature’s distribution (such as <code>&#39;capital-gain&#39;</code> or <code>&#39;capital-loss&#39;</code> above); however, normalization ensures that each feature is treated equally when applying supervised learners. Note that once scaling is applied, observing the data in its raw form will no longer have the same original meaning, as exampled below.</p>
<p>Run the code cell below to normalize each numerical feature. We will use <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" target="_blank" rel="noopener"><code>sklearn.preprocessing.MinMaxScaler</code></a> for this.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import sklearn.preprocessing.StandardScaler</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a scaler, then apply it to the features</span></span><br><span class="line">scaler = MinMaxScaler() <span class="comment"># default=(0, 1)</span></span><br><span class="line">numerical = [<span class="string">'age'</span>, <span class="string">'education-num'</span>, <span class="string">'capital-gain'</span>, <span class="string">'capital-loss'</span>, <span class="string">'hours-per-week'</span>]</span><br><span class="line"></span><br><span class="line">features_log_minmax_transform = pd.DataFrame(data = features_log_transformed)</span><br><span class="line">features_log_minmax_transform[numerical] = scaler.fit_transform(features_log_transformed[numerical])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show an example of a record with scaling applied</span></span><br><span class="line">display(features_log_minmax_transform.head(n = <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<pre><code>/home/jason/anaconda3/lib/python3.7/site-packages/sklearn/preprocessing/data.py:334: DataConversionWarning: Data with input dtype int64, float64 were all converted to float64 by MinMaxScaler.
  return self.partial_fit(X, y)</code></pre><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>workclass</th>
      <th>education_level</th>
      <th>education-num</th>
      <th>marital-status</th>
      <th>occupation</th>
      <th>relationship</th>
      <th>race</th>
      <th>sex</th>
      <th>capital-gain</th>
      <th>capital-loss</th>
      <th>hours-per-week</th>
      <th>native-country</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.301370</td>
      <td>State-gov</td>
      <td>Bachelors</td>
      <td>0.800000</td>
      <td>Never-married</td>
      <td>Adm-clerical</td>
      <td>Not-in-family</td>
      <td>White</td>
      <td>Male</td>
      <td>0.667492</td>
      <td>0.0</td>
      <td>0.397959</td>
      <td>United-States</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.452055</td>
      <td>Self-emp-not-inc</td>
      <td>Bachelors</td>
      <td>0.800000</td>
      <td>Married-civ-spouse</td>
      <td>Exec-managerial</td>
      <td>Husband</td>
      <td>White</td>
      <td>Male</td>
      <td>0.000000</td>
      <td>0.0</td>
      <td>0.122449</td>
      <td>United-States</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.287671</td>
      <td>Private</td>
      <td>HS-grad</td>
      <td>0.533333</td>
      <td>Divorced</td>
      <td>Handlers-cleaners</td>
      <td>Not-in-family</td>
      <td>White</td>
      <td>Male</td>
      <td>0.000000</td>
      <td>0.0</td>
      <td>0.397959</td>
      <td>United-States</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.493151</td>
      <td>Private</td>
      <td>11th</td>
      <td>0.400000</td>
      <td>Married-civ-spouse</td>
      <td>Handlers-cleaners</td>
      <td>Husband</td>
      <td>Black</td>
      <td>Male</td>
      <td>0.000000</td>
      <td>0.0</td>
      <td>0.397959</td>
      <td>United-States</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.150685</td>
      <td>Private</td>
      <td>Bachelors</td>
      <td>0.800000</td>
      <td>Married-civ-spouse</td>
      <td>Prof-specialty</td>
      <td>Wife</td>
      <td>Black</td>
      <td>Female</td>
      <td>0.000000</td>
      <td>0.0</td>
      <td>0.397959</td>
      <td>Cuba</td>
    </tr>
  </tbody>
</table>
</div>


<h3 id="Implementation-Data-Preprocessing"><a href="#Implementation-Data-Preprocessing" class="headerlink" title="Implementation: Data Preprocessing"></a>Implementation: Data Preprocessing</h3><p>From the table in <strong>Exploring the Data</strong> above, we can see there are several features for each record that are non-numeric. Typically, learning algorithms expect input to be numeric, which requires that non-numeric features (called <em>categorical variables</em>) be converted. One popular way to convert categorical variables is by using the <strong>one-hot encoding</strong> scheme. One-hot encoding creates a <em>“dummy”</em> variable for each possible category of each non-numeric feature. For example, assume <code>someFeature</code> has three possible entries: <code>A</code>, <code>B</code>, or <code>C</code>. We then encode this feature into <code>someFeature_A</code>, <code>someFeature_B</code> and <code>someFeature_C</code>.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">someFeature</th>
<th></th>
<th align="center">someFeature_A</th>
<th align="center">someFeature_B</th>
<th align="center">someFeature_C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">B</td>
<td></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">C</td>
<td>—-&gt; one-hot encode —-&gt;</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">A</td>
<td></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>Additionally, as with the non-numeric features, we need to convert the non-numeric target label, <code>&#39;income&#39;</code> to numerical values for the learning algorithm to work. Since there are only two possible categories for this label (“&lt;=50K” and “&gt;50K”), we can avoid using one-hot encoding and simply encode these two categories as <code>0</code> and <code>1</code>, respectively. In code cell below, you will need to implement the following:</p>
<ul>
<li>Use <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html?highlight=get_dummies#pandas.get_dummies" target="_blank" rel="noopener"><code>pandas.get_dummies()</code></a> to perform one-hot encoding on the <code>&#39;features_log_minmax_transform&#39;</code> data.</li>
<li>Convert the target label <code>&#39;income_raw&#39;</code> to numerical entries.<ul>
<li>Set records with “&lt;=50K” to <code>0</code> and records with “&gt;50K” to <code>1</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> One-hot encode the 'features_log_minmax_transform' data using pandas.get_dummies()</span></span><br><span class="line">features_final = pd.get_dummies(features_log_minmax_transform)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Encode the 'income_raw' data to numerical values</span></span><br><span class="line">income = pd.get_dummies(income_raw, drop_first=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the number of features after one-hot encoding</span></span><br><span class="line">encoded = list(features_final.columns)</span><br><span class="line">print(<span class="string">"&#123;&#125; total features after one-hot encoding."</span>.format(len(encoded)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to see the encoded feature names</span></span><br><span class="line"><span class="comment"># print (encoded)</span></span><br></pre></td></tr></table></figure>

<pre><code>103 total features after one-hot encoding.</code></pre><h3 id="Shuffle-and-Split-Data"><a href="#Shuffle-and-Split-Data" class="headerlink" title="Shuffle and Split Data"></a>Shuffle and Split Data</h3><p>Now all <em>categorical variables</em> have been converted into numerical features, and all numerical features have been normalized. As always, we will now split the data (both features and their labels) into training and test sets. 80% of the data will be used for training and 20% for testing.</p>
<p>Run the code cell below to perform this split.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import train_test_split</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># Split the 'features' and 'income' data into training and testing sets</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(features_final, </span><br><span class="line">                                                    income, </span><br><span class="line">                                                    test_size = <span class="number">0.2</span>, </span><br><span class="line">                                                    random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show the results of the split</span></span><br><span class="line">print(<span class="string">"Training set has &#123;&#125; samples."</span>.format(X_train.shape[<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"Testing set has &#123;&#125; samples."</span>.format(X_test.shape[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>Training set has 36177 samples.
Testing set has 9045 samples.</code></pre><hr>
<h2 id="Evaluating-Model-Performance"><a href="#Evaluating-Model-Performance" class="headerlink" title="Evaluating Model Performance"></a>Evaluating Model Performance</h2><p>In this section, we will investigate four different algorithms, and determine which is best at modeling the data. Three of these algorithms will be supervised learners of your choice, and the fourth algorithm is known as a <em>naive predictor</em>.</p>
<h3 id="Metrics-and-the-Naive-Predictor"><a href="#Metrics-and-the-Naive-Predictor" class="headerlink" title="Metrics and the Naive Predictor"></a>Metrics and the Naive Predictor</h3><p><em>CharityML</em>, equipped with their research, knows individuals that make more than $50,000 are most likely to donate to their charity. Because of this, <em>CharityML</em> is particularly interested in predicting who makes more than $50,000 accurately. It would seem that using <strong>accuracy</strong> as a metric for evaluating a particular model’s performace would be appropriate. Additionally, identifying someone that <em>does not</em> make more than $50,000 as someone who does would be detrimental to <em>CharityML</em>, since they are looking to find individuals willing to donate. Therefore, a model’s ability to precisely predict those that make more than $50,000 is <em>more important</em> than the model’s ability to <strong>recall</strong> those individuals. We can use <strong>F-beta score</strong> as a metric that considers both precision and recall:</p>
<p>$$ F_{\beta} = (1 + \beta^2) \cdot \frac{precision \cdot recall}{\left( \beta^2 \cdot precision \right) + recall} $$</p>
<p>In particular, when $\beta = 0.5$, more emphasis is placed on precision. This is called the <strong>F$_{0.5}$ score</strong> (or F-score for simplicity).</p>
<p>Looking at the distribution of classes (those who make at most $50,000, and those who make more), it’s clear most individuals do not make more than $50,000. This can greatly affect <strong>accuracy</strong>, since we could simply say *”this person does not make more than $50,000”* and generally be right, without ever looking at the data! Making such a statement would be called <strong>naive</strong>, since we have not considered any information to substantiate the claim. It is always important to consider the <em>naive prediction</em> for your data, to help establish a benchmark for whether a model is performing well. That been said, using that prediction would be pointless: If we predicted all people made less than $50,000, <em>CharityML</em> would identify no one as donors. </p>
<h4 id="Note-Recap-of-accuracy-precision-recall"><a href="#Note-Recap-of-accuracy-precision-recall" class="headerlink" title="Note: Recap of accuracy, precision, recall"></a>Note: Recap of accuracy, precision, recall</h4><p>** Accuracy ** measures how often the classifier makes the correct prediction. It’s the ratio of the number of correct predictions to the total number of predictions (the number of test data points).</p>
<p>** Precision ** tells us what proportion of messages we classified as spam, actually were spam.<br>It is a ratio of true positives(words classified as spam, and which are actually spam) to all positives(all words classified as spam, irrespective of whether that was the correct classificatio), in other words it is the ratio of</p>
<p><code>[True Positives/(True Positives + False Positives)]</code></p>
<p>** Recall(sensitivity)** tells us what proportion of messages that actually were spam were classified by us as spam.<br>It is a ratio of true positives(words classified as spam, and which are actually spam) to all the words that were actually spam, in other words it is the ratio of</p>
<p><code>[True Positives/(True Positives + False Negatives)]</code></p>
<p>For classification problems that are skewed in their classification distributions like in our case, for example if we had a 100 text messages and only 2 were spam and the rest 98 weren’t, accuracy by itself is not a very good metric. We could classify 90 messages as not spam(including the 2 that were spam but we classify them as not spam, hence they would be false negatives) and 10 as spam(all 10 false positives) and still get a reasonably good accuracy score. For such cases, precision and recall come in very handy. These two metrics can be combined to get the F1 score, which is weighted average(harmonic mean) of the precision and recall scores. This score can range from 0 to 1, with 1 being the best possible F1 score(we take the harmonic mean as we are dealing with ratios).</p>
<h3 id="Question-1-Naive-Predictor-Performace"><a href="#Question-1-Naive-Predictor-Performace" class="headerlink" title="Question 1 - Naive Predictor Performace"></a>Question 1 - Naive Predictor Performace</h3><ul>
<li>If we chose a model that always predicted an individual made more than $50,000, what would  that model’s accuracy and F-score be on this dataset? You must use the code cell below and assign your results to <code>&#39;accuracy&#39;</code> and <code>&#39;fscore&#39;</code> to be used later.</li>
</ul>
<p>** Please note ** that the the purpose of generating a naive predictor is simply to show what a base model without any intelligence would look like. In the real world, ideally your base model would be either the results of a previous model or could be based on a research paper upon which you are looking to improve. When there is no benchmark model set, getting a result better than random choice is a place you could start from.</p>
<p>** HINT: ** </p>
<ul>
<li>When we have a model that always predicts ‘1’ (i.e. the individual makes more than 50k) then our model will have no True Negatives(TN) or False Negatives(FN) as we are not making any negative(‘0’ value) predictions. Therefore our Accuracy in this case becomes the same as our Precision(True Positives/(True Positives + False Positives)) as every prediction that we have made with value ‘1’ that should have ‘0’ becomes a False Positive; therefore our denominator in this case is the total number of records we have in total. </li>
<li>Our Recall score(True Positives/(True Positives + False Negatives)) in this setting becomes 1 as we have no False Negatives.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TP = np.sum(income)<span class="comment"># Counting the ones as this is the naive case. Note that 'income' is the 'income_raw' data </span></span><br><span class="line"><span class="comment"># encoded to numerical values done in the data preprocessing step.</span></span><br><span class="line">FP = income.count() - TP <span class="comment"># Specific to the naive case</span></span><br><span class="line"></span><br><span class="line">TN = <span class="number">0</span> <span class="comment"># No predicted negatives in the naive case</span></span><br><span class="line">FN = <span class="number">0</span> <span class="comment"># No predicted negatives in the naive case</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Calculate accuracy, precision and recall</span></span><br><span class="line">accuracy = TP/(TP+FP+FN+TN)</span><br><span class="line">recall = TP/(TP+FN)</span><br><span class="line">precision = TP/(TP+FP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Calculate F-score using the formula above for beta = 0.5 and correct values for precision and recall.</span></span><br><span class="line">fscore = (<span class="number">1</span>+<span class="number">0.5</span>*<span class="number">0.5</span>)*(precision[<span class="number">0</span>]*recall[<span class="number">0</span>])/(precision[<span class="number">0</span>]*<span class="number">0.5</span>*<span class="number">0.5</span>+recall[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the results </span></span><br><span class="line">print(<span class="string">"Naive Predictor: [Accuracy score: &#123;:.4f&#125;, F-score: &#123;:.4f&#125;]"</span>.format(accuracy[<span class="number">0</span>],fscore))</span><br></pre></td></tr></table></figure>

<pre><code>Naive Predictor: [Accuracy score: 0.2478, F-score: 0.2917]</code></pre><h3 id="Supervised-Learning-Models"><a href="#Supervised-Learning-Models" class="headerlink" title="Supervised Learning Models"></a>Supervised Learning Models</h3><p><strong>The following are some of the supervised learning models that are currently available in</strong> <a href="http://scikit-learn.org/stable/supervised_learning.html" target="_blank" rel="noopener"><code>scikit-learn</code></a> <strong>that you may choose from:</strong></p>
<ul>
<li>Gaussian Naive Bayes (GaussianNB)</li>
<li>Decision Trees</li>
<li>Ensemble Methods (Bagging, AdaBoost, Random Forest, Gradient Boosting)</li>
<li>K-Nearest Neighbors (KNeighbors)</li>
<li>Stochastic Gradient Descent Classifier (SGDC)</li>
<li>Support Vector Machines (SVM)</li>
<li>Logistic Regression</li>
</ul>
<h3 id="Question-2-Model-Application"><a href="#Question-2-Model-Application" class="headerlink" title="Question 2 - Model Application"></a>Question 2 - Model Application</h3><p>List three of the supervised learning models above that are appropriate for this problem that you will test on the census data. For each model chosen</p>
<ul>
<li>Describe one real-world application in industry where the model can be applied. </li>
<li>What are the strengths of the model; when does it perform well?</li>
<li>What are the weaknesses of the model; when does it perform poorly?</li>
<li>What makes this model a good candidate for the problem, given what you know about the data?</li>
</ul>
<p>** HINT: **</p>
<p>Structure your answer in the same format as above^, with 4 parts for each of the three models you pick. Please include references with your answer.</p>
<p>*<em>Answer: *</em></p>
<h3 id="1-Logistic-Regression"><a href="#1-Logistic-Regression" class="headerlink" title="1. Logistic Regression"></a>1. Logistic Regression</h3><p>1) It can be used in banking system to determine whether a customer will default or not.</p>
<p>2) When the targeted is a dummy variable this model can perform well. It’s highly interpretable and very efficient.</p>
<p>3) It is not suitable for non-linear problems and it is relatively perform worse than other complex methods.</p>
<p>4) In this problem we want to estimate the dummy which are people who have salary over or below 50k. This model is exactly suitable for this situation.</p>
<h3 id="2-Ensemble-Methods-Random-Forest"><a href="#2-Ensemble-Methods-Random-Forest" class="headerlink" title="2. Ensemble Methods (Random Forest)"></a>2. Ensemble Methods (Random Forest)</h3><p>1) It can be used to determine span e-mails or classify user’s profile.</p>
<p>2) It performs better than many other simple models and not likely to be overfitting. It suits non-linear problems.</p>
<p>3) It is not suitable for linear problems, it is hard to interpret, and it requires high computational power.</p>
<p>4) In this problem we have a classification problem and ensemble methods can give us a good model.</p>
<h3 id="3-Support-Vector-Machines-SVM"><a href="#3-Support-Vector-Machines-SVM" class="headerlink" title="3.Support Vector Machines (SVM)"></a>3.Support Vector Machines (SVM)</h3><p>1) It can also be used for classification problems like whether a customer will default or not.</p>
<p>2) SVM is effective in high dimensional spaces and fast.</p>
<p>3) Not suitable for large dataset.</p>
<p>4) In our problem, we have many dimensions, SVM might perform good.</p>
<h3 id="Implementation-Creating-a-Training-and-Predicting-Pipeline"><a href="#Implementation-Creating-a-Training-and-Predicting-Pipeline" class="headerlink" title="Implementation - Creating a Training and Predicting Pipeline"></a>Implementation - Creating a Training and Predicting Pipeline</h3><p>To properly evaluate the performance of each model you’ve chosen, it’s important that you create a training and predicting pipeline that allows you to quickly and effectively train models using various sizes of training data and perform predictions on the testing data. Your implementation here will be used in the following section.<br>In the code block below, you will need to implement the following:</p>
<ul>
<li>Import <code>fbeta_score</code> and <code>accuracy_score</code> from <a href="http://scikit-learn.org/stable/modules/classes.html#sklearn-metrics-metrics" target="_blank" rel="noopener"><code>sklearn.metrics</code></a>.</li>
<li>Fit the learner to the sampled training data and record the training time.</li>
<li>Perform predictions on the test data <code>X_test</code>, and also on the first 300 training points <code>X_train[:300]</code>.<ul>
<li>Record the total prediction time.</li>
</ul>
</li>
<li>Calculate the accuracy score for both the training subset and testing set.</li>
<li>Calculate the F-score for both the training subset and testing set.<ul>
<li>Make sure that you set the <code>beta</code> parameter!</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Import two metrics from sklearn - fbeta_score and accuracy_score</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> fbeta_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_predict</span><span class="params">(learner, sample_size, X_train, y_train, X_test, y_test)</span>:</span> </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    inputs:</span></span><br><span class="line"><span class="string">       - learner: the learning algorithm to be trained and predicted on</span></span><br><span class="line"><span class="string">       - sample_size: the size of samples (number) to be drawn from training set</span></span><br><span class="line"><span class="string">       - X_train: features training set</span></span><br><span class="line"><span class="string">       - y_train: income training set</span></span><br><span class="line"><span class="string">       - X_test: features testing set</span></span><br><span class="line"><span class="string">       - y_test: income testing set</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Fit the learner to the training data using slicing with 'sample_size' using .fit(training_features[:], training_labels[:])</span></span><br><span class="line">    start = time() <span class="comment"># Get start time</span></span><br><span class="line">    learner = learner.fit(X_train[:sample_size:], y_train[:sample_size].values.ravel())</span><br><span class="line">    end = time() <span class="comment"># Get end time</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Calculate the training time</span></span><br><span class="line">    results[<span class="string">'train_time'</span>] = end - start</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Get the predictions on the test set(X_test),</span></span><br><span class="line">    <span class="comment">#       then get predictions on the first 300 training samples(X_train) using .predict()</span></span><br><span class="line">    start = time() <span class="comment"># Get start time</span></span><br><span class="line">    predictions_test = learner.predict(X_test)</span><br><span class="line">    predictions_train = learner.predict(X_train[:<span class="number">300</span>])</span><br><span class="line">    end = time() <span class="comment"># Get end time</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Calculate the total prediction time</span></span><br><span class="line">    results[<span class="string">'pred_time'</span>] = end - start</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Compute accuracy on the first 300 training samples which is y_train[:300]</span></span><br><span class="line">    results[<span class="string">'acc_train'</span>] = accuracy_score(y_train[:<span class="number">300</span>], predictions_train)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Compute accuracy on test set using accuracy_score()</span></span><br><span class="line">    results[<span class="string">'acc_test'</span>] = accuracy_score(y_test, predictions_test)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Compute F-score on the the first 300 training samples using fbeta_score()</span></span><br><span class="line">    results[<span class="string">'f_train'</span>] = fbeta_score(y_train[:<span class="number">300</span>], predictions_train, beta = <span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Compute F-score on the test set which is y_test</span></span><br><span class="line">    results[<span class="string">'f_test'</span>] = fbeta_score(y_test, predictions_test, beta = <span class="number">0.5</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># Success</span></span><br><span class="line">    print(<span class="string">"&#123;&#125; trained on &#123;&#125; samples."</span>.format(learner.__class__.__name__, sample_size))</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Return the results</span></span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h3 id="Implementation-Initial-Model-Evaluation"><a href="#Implementation-Initial-Model-Evaluation" class="headerlink" title="Implementation: Initial Model Evaluation"></a>Implementation: Initial Model Evaluation</h3><p>In the code cell, you will need to implement the following:</p>
<ul>
<li>Import the three supervised learning models you’ve discussed in the previous section.</li>
<li>Initialize the three models and store them in <code>&#39;clf_A&#39;</code>, <code>&#39;clf_B&#39;</code>, and <code>&#39;clf_C&#39;</code>.<ul>
<li>Use a <code>&#39;random_state&#39;</code> for each model you use, if provided.</li>
<li><strong>Note:</strong> Use the default settings for each model — you will tune one specific model in a later section.</li>
</ul>
</li>
<li>Calculate the number of records equal to 1%, 10%, and 100% of the training data.<ul>
<li>Store those values in <code>&#39;samples_1&#39;</code>, <code>&#39;samples_10&#39;</code>, and <code>&#39;samples_100&#39;</code> respectively.</li>
</ul>
</li>
</ul>
<p><strong>Note:</strong> Depending on which algorithms you chose, the following implementation may take some time to run!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Import the three supervised learning models from sklearn</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Initialize the three models</span></span><br><span class="line">clf_A = LogisticRegression(solver = <span class="string">'liblinear'</span>) <span class="comment"># set the default value manually in order to get rid of warnings</span></span><br><span class="line">clf_B = RandomForestClassifier(n_estimators = <span class="number">100</span>) <span class="comment"># set the default value manually in order to get rid of warnings</span></span><br><span class="line">clf_C = SVC(gamma = <span class="string">'scale'</span>) <span class="comment"># set the default value manually in order to get rid of warnings</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Calculate the number of samples for 1%, 10%, and 100% of the training data</span></span><br><span class="line"><span class="comment"># HINT: samples_100 is the entire training set i.e. len(y_train)</span></span><br><span class="line"><span class="comment"># HINT: samples_10 is 10% of samples_100 (ensure to set the count of the values to be `int` and not `float`)</span></span><br><span class="line"><span class="comment"># HINT: samples_1 is 1% of samples_100 (ensure to set the count of the values to be `int` and not `float`)</span></span><br><span class="line">samples_100 = len(y_train)</span><br><span class="line">samples_10 = int(len(y_train)*<span class="number">0.1</span>)</span><br><span class="line">samples_1 = int(len(y_train)*<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Collect results on the learners</span></span><br><span class="line">results = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> clf <span class="keyword">in</span> [clf_A, clf_B, clf_C]:</span><br><span class="line">    clf_name = clf.__class__.__name__</span><br><span class="line">    results[clf_name] = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, samples <span class="keyword">in</span> enumerate([samples_1, samples_10, samples_100]):</span><br><span class="line">        results[clf_name][i] = \</span><br><span class="line">        train_predict(clf, samples, X_train, y_train, X_test, y_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run metrics visualization for the three supervised learning models chosen</span></span><br><span class="line">vs.evaluate(results, accuracy[<span class="number">0</span>], fscore)</span><br></pre></td></tr></table></figure>

<pre><code>LogisticRegression trained on 361 samples.
LogisticRegression trained on 3617 samples.
LogisticRegression trained on 36177 samples.
RandomForestClassifier trained on 361 samples.
RandomForestClassifier trained on 3617 samples.
RandomForestClassifier trained on 36177 samples.
SVC trained on 361 samples.
SVC trained on 3617 samples.
SVC trained on 36177 samples.</code></pre><p><img src="/2020/01/22/%E5%AF%BB%E6%89%BE%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%8D%90%E6%AC%BE%E8%80%85/output_29_1.png" alt="png"></p>
<hr>
<h2 id="Improving-Results"><a href="#Improving-Results" class="headerlink" title="Improving Results"></a>Improving Results</h2><p>In this final section, you will choose from the three supervised learning models the <em>best</em> model to use on the student data. You will then perform a grid search optimization for the model over the entire training set (<code>X_train</code> and <code>y_train</code>) by tuning at least one parameter to improve upon the untuned model’s F-score. </p>
<h3 id="Question-3-Choosing-the-Best-Model"><a href="#Question-3-Choosing-the-Best-Model" class="headerlink" title="Question 3 - Choosing the Best Model"></a>Question 3 - Choosing the Best Model</h3><ul>
<li>Based on the evaluation you performed earlier, in one to two paragraphs, explain to <em>CharityML</em> which of the three models you believe to be most appropriate for the task of identifying individuals that make more than $50,000. </li>
</ul>
<p>** HINT: **<br>Look at the graph at the bottom left from the cell above(the visualization created by <code>vs.evaluate(results, accuracy, fscore)</code>) and check the F score for the testing set when 100% of the training set is used. Which model has the highest score? Your answer should include discussion of the:</p>
<ul>
<li>metrics - F score on the testing when 100% of the training data is used, </li>
<li>prediction/training time</li>
<li>the algorithm’s suitability for the data.</li>
</ul>
<p>*<em>Answer: *</em></p>
<p>The Logistic Regression model is the best model in this situation. </p>
<p>When 100% of the training data is used, the Logistic Regression model has the second highest F-score on testing set with only very slightly difference compared with the best model (SVM). However, it has the lowest training and prediction times, which is faster than the third(best) model quite a lot. Therefore it is wise to choose Logistic Regression model. Actually, Logistic Regression model is very suitable for this data because the targeted variable is a dummy.</p>
<h3 id="Question-4-Describing-the-Model-in-Layman’s-Terms"><a href="#Question-4-Describing-the-Model-in-Layman’s-Terms" class="headerlink" title="Question 4 - Describing the Model in Layman’s Terms"></a>Question 4 - Describing the Model in Layman’s Terms</h3><ul>
<li>In one to two paragraphs, explain to <em>CharityML</em>, in layman’s terms, how the final model chosen is supposed to work. Be sure that you are describing the major qualities of the model, such as how the model is trained and how the model makes a prediction. Avoid using advanced mathematical jargon, such as describing equations.</li>
</ul>
<p>** HINT: **</p>
<p>When explaining your model, if using external resources please include all citations.</p>
<p>*<em>Answer: *</em> </p>
<p>The logistic regression model will create a linear boundary cutting the data points, which can classify whether people have high income or not. It estimates the probability of a person belongs to high income group or low income group based on the change of explaining variables. Logistic regression uses the natural logarithm function to find the relationship between the variables and uses test data to find the coefficients. The function can then predict the future results using these coefficients in the logistic equation.[1] Therefore, this model can split our dataset successfully.</p>
<p><img src="/2020/01/22/%E5%AF%BB%E6%89%BE%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%8D%90%E6%AC%BE%E8%80%85/LogReg_1__1_.png" alt="image_name"></p>
<p>It can be seen in th graph, different from linear model, logistic model is a non-linear function with probability between 0 to 1.</p>
<p>[1] Wikipedia. (2020). Logistic Regression. [online] Available at: <a href="https://simple.wikipedia.org/wiki/Logistic_Regression" target="_blank" rel="noopener">https://simple.wikipedia.org/wiki/Logistic_Regression</a> [Accessed 13 Jan. 2020].</p>
<h3 id="Implementation-Model-Tuning"><a href="#Implementation-Model-Tuning" class="headerlink" title="Implementation: Model Tuning"></a>Implementation: Model Tuning</h3><p>Fine tune the chosen model. Use grid search (<code>GridSearchCV</code>) with at least one important parameter tuned with at least 3 different values. You will need to use the entire training set for this. In the code cell below, you will need to implement the following:</p>
<ul>
<li>Import <a href="http://scikit-learn.org/0.17/modules/generated/sklearn.grid_search.GridSearchCV.html" target="_blank" rel="noopener"><code>sklearn.grid_search.GridSearchCV</code></a> and <a href="http://scikit-learn.org/stable/modules/generated/sklearn.metrics.make_scorer.html" target="_blank" rel="noopener"><code>sklearn.metrics.make_scorer</code></a>.</li>
<li>Initialize the classifier you’ve chosen and store it in <code>clf</code>.<ul>
<li>Set a <code>random_state</code> if one is available to the same state you set before.</li>
</ul>
</li>
<li>Create a dictionary of parameters you wish to tune for the chosen model.<ul>
<li>Example: <code>parameters = {&#39;parameter&#39; : [list of values]}</code>.</li>
<li><strong>Note:</strong> Avoid tuning the <code>max_features</code> parameter of your learner if that parameter is available!</li>
</ul>
</li>
<li>Use <code>make_scorer</code> to create an <code>fbeta_score</code> scoring object (with $\beta = 0.5$).</li>
<li>Perform grid search on the classifier <code>clf</code> using the <code>&#39;scorer&#39;</code>, and store it in <code>grid_obj</code>.</li>
<li>Fit the grid search object to the training data (<code>X_train</code>, <code>y_train</code>), and store it in <code>grid_fit</code>.</li>
</ul>
<p><strong>Note:</strong> Depending on the algorithm chosen and the parameter list, the following implementation may take some time to run!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Import 'GridSearchCV', 'make_scorer', and any other necessary libraries</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> make_scorer</span><br><span class="line">random.seed(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Initialize the classifier</span></span><br><span class="line">clf = LogisticRegression(solver = <span class="string">'liblinear'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Create the parameters list you wish to tune, using a dictionary if needed.</span></span><br><span class="line"><span class="comment"># HINT: parameters = &#123;'parameter_1': [value1, value2], 'parameter_2': [value1, value2]&#125;</span></span><br><span class="line">parameters = &#123;<span class="string">'solver'</span>:[<span class="string">'lbfgs'</span>, <span class="string">'newton-cg'</span>, <span class="string">'sag'</span>, <span class="string">'saga'</span>], <span class="string">'max_iter'</span>:[<span class="number">700</span>, <span class="number">1000</span>, <span class="number">1200</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Make an fbeta_score scoring object using make_scorer()</span></span><br><span class="line">scorer = make_scorer(fbeta_score, beta = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Perform grid search on the classifier using 'scorer' as the scoring method using GridSearchCV()</span></span><br><span class="line">grid_obj = GridSearchCV(clf, parameters, scoring=scorer, cv = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Fit the grid search object to the training data and find the optimal parameters using fit()</span></span><br><span class="line">grid_fit = grid_obj.fit(X_train, y_train.values.ravel())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the estimator</span></span><br><span class="line">best_clf = grid_fit.best_estimator_</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions using the unoptimized and model</span></span><br><span class="line">predictions = (clf.fit(X_train, y_train.values.ravel())).predict(X_test)</span><br><span class="line">best_predictions = best_clf.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report the before-and-afterscores</span></span><br><span class="line">print(<span class="string">"Unoptimized model\n------"</span>)</span><br><span class="line">print(<span class="string">"Accuracy score on testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, predictions)))</span><br><span class="line">print(<span class="string">"F-score on testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, predictions, beta = <span class="number">0.5</span>)))</span><br><span class="line">print(<span class="string">"\nOptimized Model\n------"</span>)</span><br><span class="line">print(<span class="string">"Final accuracy score on the testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, best_predictions)))</span><br><span class="line">print(<span class="string">"Final F-score on the testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, best_predictions, beta = <span class="number">0.5</span>)))</span><br></pre></td></tr></table></figure>

<pre><code>Unoptimized model
------
Accuracy score on testing data: 0.8419
F-score on testing data: 0.6832

Optimized Model
------
Final accuracy score on the testing data: 0.8418
Final F-score on the testing data: 0.6829</code></pre><h3 id="Question-5-Final-Model-Evaluation"><a href="#Question-5-Final-Model-Evaluation" class="headerlink" title="Question 5 - Final Model Evaluation"></a>Question 5 - Final Model Evaluation</h3><ul>
<li>What is your optimized model’s accuracy and F-score on the testing data? </li>
<li>Are these scores better or worse than the unoptimized model? </li>
<li>How do the results from your optimized model compare to the naive predictor benchmarks you found earlier in <strong>Question 1</strong>?_  </li>
</ul>
<p><strong>Note:</strong> Fill in the table below with your results, and then provide discussion in the <strong>Answer</strong> box.</p>
<h4 id="Results"><a href="#Results" class="headerlink" title="Results:"></a>Results:</h4><table>
<thead>
<tr>
<th align="center">Metric</th>
<th align="center">Unoptimized Model</th>
<th align="center">Optimized Model</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accuracy Score</td>
<td align="center">0.8419</td>
<td align="center">0.8418</td>
</tr>
<tr>
<td align="center">F-score</td>
<td align="center">0.6832</td>
<td align="center">0.6829</td>
</tr>
</tbody></table>
<p>*<em>Answer: *</em></p>
<p>The scores for the optimized model is worse than the unoptimized model. The scores for the optimized model improves a lot compared with the naive model.</p>
<hr>
<h2 id="Feature-Importance"><a href="#Feature-Importance" class="headerlink" title="Feature Importance"></a>Feature Importance</h2><p>An important task when performing supervised learning on a dataset like the census data we study here is determining which features provide the most predictive power. By focusing on the relationship between only a few crucial features and the target label we simplify our understanding of the phenomenon, which is most always a useful thing to do. In the case of this project, that means we wish to identify a small number of features that most strongly predict whether an individual makes at most or more than $50,000.</p>
<p>Choose a scikit-learn classifier (e.g., adaboost, random forests) that has a <code>feature_importance_</code> attribute, which is a function that ranks the importance of features according to the chosen classifier.  In the next python cell fit this classifier to training set and use this attribute to determine the top 5 most important features for the census dataset.</p>
<h3 id="Question-6-Feature-Relevance-Observation"><a href="#Question-6-Feature-Relevance-Observation" class="headerlink" title="Question 6 - Feature Relevance Observation"></a>Question 6 - Feature Relevance Observation</h3><p>When <strong>Exploring the Data</strong>, it was shown there are thirteen available features for each individual on record in the census data. Of these thirteen records, which five features do you believe to be most important for prediction, and in what order would you rank them and why?</p>
<p><strong>Answer:</strong></p>
<ol>
<li><p>education_num: more education might get better jobs</p>
</li>
<li><p>hours-per-week: more working hours more money</p>
</li>
<li><p>age: higher age implies more experience thus more income</p>
</li>
<li><p>marital status: married people might have more incentive to earn more money</p>
</li>
<li><p>sex: it might exists sex discrimination.</p>
</li>
</ol>
<h3 id="Implementation-Extracting-Feature-Importance"><a href="#Implementation-Extracting-Feature-Importance" class="headerlink" title="Implementation - Extracting Feature Importance"></a>Implementation - Extracting Feature Importance</h3><p>Choose a <code>scikit-learn</code> supervised learning algorithm that has a <code>feature_importance_</code> attribute availble for it. This attribute is a function that ranks the importance of each feature when making predictions based on the chosen algorithm.</p>
<p>In the code cell below, you will need to implement the following:</p>
<ul>
<li>Import a supervised learning model from sklearn if it is different from the three used earlier.</li>
<li>Train the supervised model on the entire training set.</li>
<li>Extract the feature importances using <code>&#39;.feature_importances_&#39;</code>.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Import a supervised learning model that has 'feature_importances_'</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Train the supervised model on the training set using .fit(X_train, y_train)</span></span><br><span class="line">param_dist = &#123;<span class="string">"max_depth"</span>: [<span class="number">3</span>, <span class="literal">None</span>],</span><br><span class="line">              <span class="string">"n_estimators"</span>: list(range(<span class="number">10</span>, <span class="number">200</span>)),</span><br><span class="line">              <span class="string">"max_features"</span>: list(range(<span class="number">1</span>, X_test.shape[<span class="number">1</span>]+<span class="number">1</span>)),</span><br><span class="line">              <span class="string">"min_samples_split"</span>: list(range(<span class="number">2</span>, <span class="number">11</span>)),</span><br><span class="line">              <span class="string">"min_samples_leaf"</span>: list(range(<span class="number">1</span>, <span class="number">11</span>)),</span><br><span class="line">              <span class="string">"bootstrap"</span>: [<span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">              <span class="string">"criterion"</span>: [<span class="string">"gini"</span>, <span class="string">"entropy"</span>]&#125;</span><br><span class="line">model = RandomizedSearchCV(clf_B, param_distributions=param_dist)</span><br><span class="line">model.fit(X_train, y_train.values.ravel())</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Extract the feature importances using .feature_importances_ </span></span><br><span class="line">importances = model.best_estimator_.feature_importances_</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">vs.feature_plot(importances, X_train, y_train)</span><br></pre></td></tr></table></figure>

<pre><code>/home/jason/anaconda3/lib/python3.7/site-packages/sklearn/model_selection/_split.py:2053: FutureWarning: You should specify a value for &apos;cv&apos; instead of relying on the default value. The default value will change from 3 to 5 in version 0.22.
  warnings.warn(CV_WARNING, FutureWarning)</code></pre><p><img src="/2020/01/22/%E5%AF%BB%E6%89%BE%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%8D%90%E6%AC%BE%E8%80%85/output_47_1.png" alt="png"></p>
<h3 id="Question-7-Extracting-Feature-Importance"><a href="#Question-7-Extracting-Feature-Importance" class="headerlink" title="Question 7 - Extracting Feature Importance"></a>Question 7 - Extracting Feature Importance</h3><p>Observe the visualization created above which displays the five most relevant features for predicting if an individual makes at most or above $50,000.  </p>
<ul>
<li>How do these five features compare to the five features you discussed in <strong>Question 6</strong>?</li>
<li>If you were close to the same answer, how does this visualization confirm your thoughts? </li>
<li>If you were not close, why do you think these features are more relevant?</li>
</ul>
<p><strong>Answer:</strong></p>
<p>Compared with what I thought before, the importance of marital status, ages and years of education are comfirmed by the graph because their weights are high. However, capital-gain and relationship_Husband is not what I predicted. </p>
<p>For capital-gain it might be only whealthy people can have more gain in capital since they have more free money to invest. For relationship, it is kind of overlap with the marital status so the reason is similar as what I explained before that married people are more likely try to earn more money to support the family especially for males.</p>
<h3 id="Feature-Selection"><a href="#Feature-Selection" class="headerlink" title="Feature Selection"></a>Feature Selection</h3><p>How does a model perform if we only use a subset of all the available features in the data? With less features required to train, the expectation is that training and prediction time is much lower — at the cost of performance metrics. From the visualization above, we see that the top five most important features contribute more than half of the importance of <strong>all</strong> features present in the data. This hints that we can attempt to <em>reduce the feature space</em> and simplify the information required for the model to learn. The code cell below will use the same optimized model you found earlier, and train it on the same training set <em>with only the top five important features</em>. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import functionality for cloning a model</span></span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> clone</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce the feature space</span></span><br><span class="line">X_train_reduced = X_train[X_train.columns.values[(np.argsort(importances)[::<span class="number">-1</span>])[:<span class="number">5</span>]]]</span><br><span class="line">X_test_reduced = X_test[X_test.columns.values[(np.argsort(importances)[::<span class="number">-1</span>])[:<span class="number">5</span>]]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train on the "best" model found from grid search earlier</span></span><br><span class="line">clf = (clone(best_clf)).fit(X_train_reduced, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make new predictions</span></span><br><span class="line">reduced_predictions = clf.predict(X_test_reduced)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report scores from the final model using both versions of data</span></span><br><span class="line">print(<span class="string">"Final Model trained on full data\n------"</span>)</span><br><span class="line">print(<span class="string">"Accuracy on testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, best_predictions)))</span><br><span class="line">print(<span class="string">"F-score on testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, best_predictions, beta = <span class="number">0.5</span>)))</span><br><span class="line">print(<span class="string">"\nFinal Model trained on reduced data\n------"</span>)</span><br><span class="line">print(<span class="string">"Accuracy on testing data: &#123;:.4f&#125;"</span>.format(accuracy_score(y_test, reduced_predictions)))</span><br><span class="line">print(<span class="string">"F-score on testing data: &#123;:.4f&#125;"</span>.format(fbeta_score(y_test, reduced_predictions, beta = <span class="number">0.5</span>)))</span><br></pre></td></tr></table></figure>

<pre><code>Final Model trained on full data
------
Accuracy on testing data: 0.8418
F-score on testing data: 0.6829

Final Model trained on reduced data
------
Accuracy on testing data: 0.8258
F-score on testing data: 0.6462


/home/jason/anaconda3/lib/python3.7/site-packages/sklearn/utils/validation.py:761: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().
  y = column_or_1d(y, warn=True)</code></pre><h3 id="Question-8-Effects-of-Feature-Selection"><a href="#Question-8-Effects-of-Feature-Selection" class="headerlink" title="Question 8 - Effects of Feature Selection"></a>Question 8 - Effects of Feature Selection</h3><ul>
<li>How does the final model’s F-score and accuracy score on the reduced data using only five features compare to those same scores when all features are used?</li>
<li>If training time was a factor, would you consider using the reduced data as your training set?</li>
</ul>
<p><strong>Answer:</strong></p>
<p>It is actually very close to the full features with slightly lower scores. However since I am using Logistic Regression model, I will not use the reduced data. Because the training time is alreay very short with the full features. The algorithm is very efficient so the room for improvement is quite limited. Therefore it is not wise to sacrifice the model accuracy to save only a few seconds.</p>
<blockquote>
<p><strong>Note</strong>: Once you have completed all of the code implementations and successfully answered each question above, you may finalize your work by exporting the iPython Notebook as an HTML document. You can do this by using the menu above and navigating to<br><strong>File -&gt; Download as -&gt; HTML (.html)</strong>. Include the finished document along with this notebook as your submission.</p>
</blockquote>
]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>R速查表</title>
    <url>/2020/01/22/R%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<font size="3">
R 各种速查表, Cheat Sheet。不支持手机浏览...

<a id="more"></a>
<hr>
<h1 id="1-R-基础"><a href="#1-R-基础" class="headerlink" title="1. R 基础"></a>1. R 基础</h1><h2 id="R-basic"><a href="#R-basic" class="headerlink" title="R basic"></a>R basic</h2><div class="pdf" target="./base-r.pdf" height></div>

<h2 id="R-advanced"><a href="#R-advanced" class="headerlink" title="R advanced"></a>R advanced</h2><div class="pdf" target="./advancedR.pdf" height></div>  

<h2 id="Regular-expressions"><a href="#Regular-expressions" class="headerlink" title="Regular expressions"></a>Regular expressions</h2><div class="pdf" target="./regex.pdf" height></div>

<h2 id="R-Markdown"><a href="#R-Markdown" class="headerlink" title="R Markdown"></a>R Markdown</h2><div class="pdf" target="./rmarkdown-2.0.pdf" height></div> 

<h2 id="Use-Python-in-R"><a href="#Use-Python-in-R" class="headerlink" title="Use Python in R"></a>Use Python in R</h2><div class="pdf" target="./reticulate.pdf" height></div> 

<h1 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2. 数据处理"></a>2. 数据处理</h1><h2 id="Data-import"><a href="#Data-import" class="headerlink" title="Data import"></a>Data import</h2><div class="pdf" target="./data-import.pdf" height></div>

<h2 id="dplyr"><a href="#dplyr" class="headerlink" title="dplyr"></a>dplyr</h2><div class="pdf" target="./dplyr.pdf" height></div> 

<h2 id="Data-transformation"><a href="#Data-transformation" class="headerlink" title="Data transformation"></a>Data transformation</h2><div class="pdf" target="./data-transformation.pdf" height></div> 

<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><div class="pdf" target="./strings.pdf" height></div>

<h2 id="Factors"><a href="#Factors" class="headerlink" title="Factors"></a>Factors</h2><div class="pdf" target="./factors.pdf" height></div>  

<h2 id="Dates-and-times-with-lubridate"><a href="#Dates-and-times-with-lubridate" class="headerlink" title="Dates and times with lubridate"></a>Dates and times with lubridate</h2><div class="pdf" target="./lubridate.pdf" height></div>

<h2 id="Apply-functions-with-purrr"><a href="#Apply-functions-with-purrr" class="headerlink" title="Apply functions with purrr"></a>Apply functions with purrr</h2><div class="pdf" target="./purrr.pdf" height></div>

<h2 id="Data-Science-in-Spark-with-sparklyr"><a href="#Data-Science-in-Spark-with-sparklyr" class="headerlink" title="Data Science in Spark with sparklyr"></a>Data Science in Spark with sparklyr</h2><div class="pdf" target="./sparklyr.pdf" height></div>


<h1 id="3-数据可视化"><a href="#3-数据可视化" class="headerlink" title="3. 数据可视化"></a>3. 数据可视化</h1><h2 id="ggplot2"><a href="#ggplot2" class="headerlink" title="ggplot2"></a>ggplot2</h2><div class="pdf" target="./ggplot2.pdf" height></div>

<h2 id="Thematic-maps-with-cartography"><a href="#Thematic-maps-with-cartography" class="headerlink" title="Thematic maps with cartography"></a>Thematic maps with cartography</h2><div class="pdf" target="./cartography.pdf" height></div>

<h1 id="4-机器学习"><a href="#4-机器学习" class="headerlink" title="4. 机器学习"></a>4. 机器学习</h1><h2 id="R-自带"><a href="#R-自带" class="headerlink" title="R 自带"></a>R 自带</h2><div class="pdf" target="./Rmachinelearning.pdf" height></div>

<h2 id="caret-Classification-And-REgression-Training"><a href="#caret-Classification-And-REgression-Training" class="headerlink" title="caret(Classification And REgression Training)"></a>caret(Classification And REgression Training)</h2><div class="pdf" target="./caret.pdf" height></div>

<h2 id="Deep-Learning-with-Keras"><a href="#Deep-Learning-with-Keras" class="headerlink" title="Deep Learning with Keras"></a>Deep Learning with Keras</h2><div class="pdf" target="./keras.pdf" height></div>

<h2 id="Time-series"><a href="#Time-series" class="headerlink" title="Time series"></a>Time series</h2><div class="pdf" target="./time-series.pdf" height></div>  
<h1 id="来源以及最后"><a href="#来源以及最后" class="headerlink" title="来源以及最后"></a>来源以及最后</h1><ol>
<li><a href="https://rstudio.com/resources/cheatsheets/" target="_blank" rel="noopener">https://rstudio.com/resources/cheatsheets/</a></li>
<li>大家有好的Cheat sheet欢迎留言补充</li>
</ol>
</font>]]></content>
      <categories>
        <category>R学习</category>
      </categories>
      <tags>
        <tag>速查表</tag>
      </tags>
  </entry>
  <entry>
    <title>Python速查表</title>
    <url>/2020/01/22/Python%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<font size="3">
Python 各种速查表,Cheat Sheet。不支持手机浏览...

<a id="more"></a>
<hr>
<h1 id="1-Python-基础"><a href="#1-Python-基础" class="headerlink" title="1. Python 基础"></a>1. Python 基础</h1><h2 id="Python-basic"><a href="#Python-basic" class="headerlink" title="Python basic"></a>Python basic</h2><div class="pdf" target="./Python_basic.pdf" height></div>

<h2 id="Python-classes"><a href="#Python-classes" class="headerlink" title="Python classes"></a>Python classes</h2><div class="pdf" target="./Python_classes.pdf" height></div>  

<h2 id="Python-dictionaries"><a href="#Python-dictionaries" class="headerlink" title="Python dictionaries"></a>Python dictionaries</h2><div class="pdf" target="./Python_dictionaries.pdf" height></div>  

<h2 id="Python-lists"><a href="#Python-lists" class="headerlink" title="Python lists"></a>Python lists</h2><div class="pdf" target="./Python_lists.pdf" height></div>  

<h2 id="Python-functions"><a href="#Python-functions" class="headerlink" title="Python functions"></a>Python functions</h2><div class="pdf" target="./Python_functions.pdf" height></div>

<h2 id="Python-if-and-while"><a href="#Python-if-and-while" class="headerlink" title="Python if and while"></a>Python if and while</h2><div class="pdf" target="./Python_if_while.pdf" height></div> 

<h2 id="Python-regular-expressions"><a href="#Python-regular-expressions" class="headerlink" title="Python regular expressions"></a>Python regular expressions</h2><div class="pdf" target="./python_regular_expressions.pdf" height></div> 

<h2 id="Python-read-files"><a href="#Python-read-files" class="headerlink" title="Python read files"></a>Python read files</h2><div class="pdf" target="./Python_files_exceptions.pdf" height></div>  

<h1 id="2-Python-各种包"><a href="#2-Python-各种包" class="headerlink" title="2. Python 各种包"></a>2. Python 各种包</h1><h2 id="1-Numpy"><a href="#1-Numpy" class="headerlink" title="1. Numpy"></a>1. Numpy</h2><div class="pdf" target="./Numpy.pdf" height></div>  

<h2 id="2-Pandas"><a href="#2-Pandas" class="headerlink" title="2. Pandas"></a>2. Pandas</h2><div class="pdf" target="./Pandas.pdf" height></div>  

<h2 id="3-Matplotlib"><a href="#3-Matplotlib" class="headerlink" title="3. Matplotlib"></a>3. Matplotlib</h2><div class="pdf" target="./Matplotlib.pdf" height></div>  

<h2 id="4-Seaborn"><a href="#4-Seaborn" class="headerlink" title="4. Seaborn"></a>4. Seaborn</h2><div class="pdf" target="./Seaborn.pdf" height></div>  

<h2 id="5-Scikit-learn"><a href="#5-Scikit-learn" class="headerlink" title="5. Scikit-learn"></a>5. Scikit-learn</h2><div class="pdf" target="./Sklearn.pdf" height></div> 

<p><img src="/2020/01/22/Python%E9%80%9F%E6%9F%A5%E8%A1%A8/1.png" alt="sklearn"></p>
<h2 id="6-Pytorch"><a href="#6-Pytorch" class="headerlink" title="6. Pytorch"></a>6. Pytorch</h2><p>官方文档: <a href="https://pytorch.org/tutorials/beginner/ptcheat.html" target="_blank" rel="noopener">https://pytorch.org/tutorials/beginner/ptcheat.html</a></p>
<h1 id="来源以及最后"><a href="#来源以及最后" class="headerlink" title="来源以及最后"></a>来源以及最后</h1><ol>
<li><a href="https://ehmatthes.github.io/pcc_2e/cheat_sheets/cheat_sheets/" target="_blank" rel="noopener">https://ehmatthes.github.io/pcc_2e/cheat_sheets/cheat_sheets/</a></li>
<li><a href="https://www.datacamp.com/community/data-science-cheatsheets" target="_blank" rel="noopener">https://www.datacamp.com/community/data-science-cheatsheets</a></li>
<li><a href="https://www.dataquest.io/blog/regex-cheatsheet/" target="_blank" rel="noopener">https://www.dataquest.io/blog/regex-cheatsheet/</a></li>
<li>一个很好的python基础速查表: <a href="https://github.com/crazyguitar/pysheeet" target="_blank" rel="noopener">https://github.com/crazyguitar/pysheeet</a> </li>
<li>大家有好的Cheat sheet欢迎留言补充</li>
</ol>
</font>]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>速查表</tag>
      </tags>
  </entry>
  <entry>
    <title>基于python的基金定投分析</title>
    <url>/2020/01/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<font size="3">
使用python可视化分析基金定投和普通投资之间的区别和优缺点。探讨基金定投的降低风险作用。

<a id="more"></a>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<h2 id="爬取东方财富网关于基金的数据并处理数据"><a href="#爬取东方财富网关于基金的数据并处理数据" class="headerlink" title="爬取东方财富网关于基金的数据并处理数据"></a>爬取东方财富网关于基金的数据并处理数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">link=<span class="string">"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&amp;code=000311&amp;page=1&amp;sdate=2018-01-02&amp;edate=2020-01-10&amp;per=20"</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36"</span>,</span><br><span class="line">&#125;</span><br><span class="line">r=requests.get(link,headers=headers)</span><br><span class="line"></span><br><span class="line">s1 = requests.get(link)</span><br><span class="line">s1.encoding = <span class="string">'utf-8'</span></span><br><span class="line">soup1=BeautifulSoup(s1.text,<span class="string">'lxml'</span>)</span><br><span class="line">fund_detail=soup1.find_all(<span class="string">'tr'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###获取总页数</span></span><br><span class="line">pattern=re.compile(<span class="string">r'pages:(.*),'</span>)</span><br><span class="line">html=r.text</span><br><span class="line">result=re.search(pattern,html).group(<span class="number">1</span>)</span><br><span class="line">pages=int(result)</span><br><span class="line">pages</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, pages+<span class="number">1</span>):</span><br><span class="line">    link=<span class="string">'http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&amp;code=000311&amp;page='</span>+str(i)+<span class="string">'&amp;sdate=2018-01-02&amp;edate=2020-01-10&amp;per=20'</span></span><br><span class="line">    r=requests.get(link,headers=headers)</span><br><span class="line">    s1 = requests.get(link)</span><br><span class="line">    s1.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    soup1=BeautifulSoup(s1.text,<span class="string">'lxml'</span>)</span><br><span class="line">    fund_detail=soup1.find_all(<span class="string">'tr'</span>)</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> fund_detail:</span><br><span class="line">       <span class="keyword">if</span> each.td <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">        date=each.td.text.strip()<span class="comment">##only first td</span></span><br><span class="line">        unit_value=each.find(<span class="string">'td'</span>,class_=<span class="string">'tor bold'</span>).text.strip()<span class="comment">##first tor bold</span></span><br><span class="line">        cum_value=each.find(<span class="string">'td'</span>,class_=<span class="string">'tor bold'</span>).next_sibling.text.strip()<span class="comment">##second td</span></span><br><span class="line">        percent=each.find(<span class="string">'td'</span>).next_sibling.next_sibling.next_sibling.text.strip()</span><br><span class="line">        purchase_condition=each.find(<span class="string">'td'</span>).next_sibling.next_sibling.next_sibling.next_sibling.text.strip()</span><br><span class="line">        sale_condition=each.find(<span class="string">'td'</span>).next_sibling.next_sibling.next_sibling.next_sibling.next_sibling.text.strip()</span><br><span class="line">        dividend=each.find(<span class="string">'td'</span>,class_=<span class="string">'red unbold'</span>).text.strip()</span><br><span class="line">        code= <span class="string">'000311'</span></span><br><span class="line">        name=  <span class="string">'景顺长城沪深300增强'</span></span><br><span class="line">        data_list.append([code, name, date,unit_value, cum_value, percent,purchase_condition, sale_condition, dividend])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">len(data_list)</span><br></pre></td></tr></table></figure>




<pre><code>497</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fund_000311 = pd.DataFrame(data_list)<span class="comment"># 设置列名</span></span><br><span class="line">fund_000311.columns=[<span class="string">'代码'</span>,<span class="string">'名字'</span>,<span class="string">'时间'</span>,<span class="string">'单位净值'</span>,<span class="string">'累计净值'</span>,<span class="string">'涨跌幅'</span>,<span class="string">'申购'</span>,<span class="string">'赎回'</span>,<span class="string">'分红'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fund_000311.to_csv(<span class="string">"data0003111"</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fund_000311.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>代码</th>
      <th>名字</th>
      <th>时间</th>
      <th>单位净值</th>
      <th>累计净值</th>
      <th>涨跌幅</th>
      <th>申购</th>
      <th>赎回</th>
      <th>分红</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>000311</td>
      <td>景顺长城沪深300增强</td>
      <td>2020-01-10</td>
      <td>2.2260</td>
      <td>2.5660</td>
      <td>0.32%</td>
      <td>开放申购</td>
      <td>开放赎回</td>
      <td></td>
    </tr>
    <tr>
      <th>1</th>
      <td>000311</td>
      <td>景顺长城沪深300增强</td>
      <td>2020-01-09</td>
      <td>2.2190</td>
      <td>2.5590</td>
      <td>1.46%</td>
      <td>开放申购</td>
      <td>开放赎回</td>
      <td></td>
    </tr>
    <tr>
      <th>2</th>
      <td>000311</td>
      <td>景顺长城沪深300增强</td>
      <td>2020-01-08</td>
      <td>2.1870</td>
      <td>2.5270</td>
      <td>-1.44%</td>
      <td>开放申购</td>
      <td>开放赎回</td>
      <td></td>
    </tr>
    <tr>
      <th>3</th>
      <td>000311</td>
      <td>景顺长城沪深300增强</td>
      <td>2020-01-07</td>
      <td>2.2190</td>
      <td>2.5590</td>
      <td>0.91%</td>
      <td>开放申购</td>
      <td>开放赎回</td>
      <td></td>
    </tr>
    <tr>
      <th>4</th>
      <td>000311</td>
      <td>景顺长城沪深300增强</td>
      <td>2020-01-06</td>
      <td>2.1990</td>
      <td>2.5390</td>
      <td>-0.36%</td>
      <td>开放申购</td>
      <td>开放赎回</td>
      <td></td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##画出走势图(累计净值),共1328个交易日,累计净值=单位净值+累计分红</span></span><br><span class="line">cum_price=fund_000311[[<span class="string">'单位净值'</span>]]</span><br><span class="line">cum_price=np.array(cum_price)</span><br><span class="line">cum_price=cum_price.tolist()</span><br><span class="line">cum_value=list()</span><br><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">497.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> reversed(cum_price):<span class="comment">##倒序 从头开始</span></span><br><span class="line"> cum_price=float(*each)</span><br><span class="line"> cum_value.append(cum_price)</span><br><span class="line">plt.plot(t,cum_value,<span class="string">'r-'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'value'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'time'</span>) </span><br><span class="line">plt.title(<span class="string">'Fund 000311 HuSheng 300 '</span>)</span><br></pre></td></tr></table></figure>




<pre><code>Text(0.5, 1.0, &apos;Fund 000311 HuSheng 300 &apos;)</code></pre><p><img src="/2020/01/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E5%88%86%E6%9E%90/output_6_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##涨跌情况</span></span><br><span class="line">percent=fund_000311[[<span class="string">'涨跌幅'</span>]]</span><br><span class="line">percent=np.array(percent)</span><br><span class="line">percent=percent.tolist()</span><br><span class="line"><span class="keyword">while</span> [<span class="string">''</span>] <span class="keyword">in</span> percent:</span><br><span class="line"> percent.remove([<span class="string">''</span>])<span class="comment">#去除三个空白值</span></span><br><span class="line">percent_val=[]</span><br><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">494.0</span>, <span class="number">1</span>)</span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> reversed(percent):<span class="comment">##倒序 从头开始</span></span><br><span class="line">   each=float(str(*each).strip(<span class="string">'%'</span>))</span><br><span class="line">   percent_val.append(each)</span><br><span class="line">   i=i+<span class="number">1</span>  </span><br><span class="line">plt.plot(t,percent_val,<span class="string">'r-'</span>,linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.ylabel(<span class="string">'ratio(%)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'time'</span>) </span><br><span class="line">plt.title(<span class="string">'Fund 000311 HuSheng 300 '</span>)</span><br><span class="line"><span class="comment">##可以看到在第二百到第三百个交易日波动率明显变大,400到500明显波动率小。</span></span><br></pre></td></tr></table></figure>




<pre><code>Text(0.5, 1.0, &apos;Fund 000311 HuSheng 300 &apos;)</code></pre><p><img src="/2020/01/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E5%88%86%E6%9E%90/output_7_1.png" alt="png"></p>
<h2 id="基金定投研究"><a href="#基金定投研究" class="headerlink" title="基金定投研究"></a>基金定投研究</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unit_price=fund_000311[[<span class="string">'单位净值'</span>]]</span><br><span class="line">unit_price=np.array(unit_price)</span><br><span class="line">unit_price=unit_price.tolist()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查出分红情况</span></span><br><span class="line">dividend=fund_000311.loc[fund_000311[<span class="string">'分红'</span>] != <span class="string">''</span>]</span><br><span class="line">dividend <span class="comment"># 期间无分红</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>代码</th>
      <th>名字</th>
      <th>时间</th>
      <th>单位净值</th>
      <th>累计净值</th>
      <th>涨跌幅</th>
      <th>申购</th>
      <th>赎回</th>
      <th>分红</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



<h4 id="1-简单情况一次买入"><a href="#1-简单情况一次买入" class="headerlink" title="1. 简单情况一次买入"></a>1. 简单情况一次买入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算年化收益</span></span><br><span class="line"></span><br><span class="line">total_yearly_once = []</span><br><span class="line">unit_price_new = unit_price[<span class="number">50</span>:<span class="number">494</span>] <span class="comment"># 避免投资时间太短不考虑近50个交易日</span></span><br><span class="line">dayday = <span class="number">497</span> <span class="comment"># 投资时长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(unit_price_new):</span><br><span class="line"> i=float(*i)</span><br><span class="line"> pie=<span class="number">1000</span>/i <span class="comment">##份额</span></span><br><span class="line"> temp = pie*<span class="number">2.226</span> <span class="comment"># 2.226 20年1月10日</span></span><br><span class="line"> total_return = (temp<span class="number">-1000</span>)/<span class="number">1000</span></span><br><span class="line"> yearly_return = total_return/dayday*<span class="number">250</span> <span class="comment"># 250个交易日</span></span><br><span class="line"> total_yearly_once.append(yearly_return)</span><br><span class="line"> dayday = dayday - <span class="number">1</span></span><br><span class="line">total_yearly_once_df=pd.DataFrame(total_yearly_once)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画图</span></span><br><span class="line"></span><br><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">444.0</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t,total_yearly_once_df,<span class="string">'r-'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'ratio(%)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'time'</span>) </span><br><span class="line">plt.title(<span class="string">'Fund 000311 normal investment '</span>)</span><br></pre></td></tr></table></figure>




<pre><code>Text(0.5, 1.0, &apos;Fund 000311 normal investment &apos;)</code></pre><p><img src="/2020/01/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E5%88%86%E6%9E%90/output_13_1.png" alt="png"></p>
<p>可以看到收益率的波动率在这段期间非常的大,大致从0到将近60%,并且存在负收益率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(total_yearly_once, bins=<span class="number">5</span>,facecolor=<span class="string">"red"</span>, edgecolor=<span class="string">"black"</span>, alpha=<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([101., 110., 124.,  78.,  31.]),
 array([-0.02019805,  0.09804444,  0.21628694,  0.33452944,  0.45277193,
         0.57101443]),
 &lt;a list of 5 Patch objects&gt;)</code></pre><p><img src="/2020/01/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E5%88%86%E6%9E%90/output_15_1.png" alt="png"></p>
<ol start="2">
<li>定投简单情况(不考虑时间价值)automatic investment plan</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算年化收益</span></span><br><span class="line">total_yearly_auto = []</span><br><span class="line">times= np.arange(<span class="number">494</span>, <span class="number">50</span>, <span class="number">-1</span>)</span><br><span class="line">dayday = <span class="number">497</span> <span class="comment"># 投资时长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> times:</span><br><span class="line">    unit_price_new = unit_price[<span class="number">50</span>:i+<span class="number">1</span>] <span class="comment"># 避免投资时间太短不考虑近50个交易日</span></span><br><span class="line">    each_pie=[]</span><br><span class="line">    each_amount=<span class="number">1000</span>/(len(unit_price_new)) <span class="comment"># 每笔投资多少</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> (unit_price_new):</span><br><span class="line">        each=float(*each)</span><br><span class="line">        pie=each_amount/each</span><br><span class="line">        each_pie.append(pie)</span><br><span class="line">    total_return=(sum(each_pie)*<span class="number">2.226</span><span class="number">-1000</span>)/<span class="number">1000</span></span><br><span class="line">    yearly_return = total_return/dayday*<span class="number">250</span></span><br><span class="line">    total_yearly_auto.append(yearly_return)</span><br><span class="line">    dayday = dayday - <span class="number">1</span></span><br><span class="line">total_yearly_auto_df=pd.DataFrame(total_yearly_auto)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">444.0</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t,total_yearly_auto_df,<span class="string">'b-'</span>, label=<span class="string">'auto'</span>)</span><br><span class="line">plt.plot(t,total_yearly_once_df,<span class="string">'r-'</span>, label=<span class="string">'normal'</span>)</span><br><span class="line">plt.legend(loc=<span class="string">'upper right'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'ratio(%)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'time'</span>) </span><br><span class="line">plt.title(<span class="string">'Fund 000311 auto investment'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>Text(0.5, 1.0, &apos;Fund 000311 auto investment&apos;)</code></pre><p><img src="/2020/01/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E5%88%86%E6%9E%90/output_18_1.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(total_yearly_once, bins=<span class="number">10</span>,facecolor=<span class="string">"red"</span>, edgecolor=<span class="string">"black"</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">plt.hist(total_yearly_auto, bins=<span class="number">10</span>,facecolor=<span class="string">"blue"</span>, edgecolor=<span class="string">"black"</span>, alpha=<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(array([ 52., 107., 148., 108.,   6.,  12.,   2.,   5.,   2.,   2.]),
 array([0.07401984, 0.09161269, 0.10920555, 0.1267984 , 0.14439126,
        0.16198411, 0.17957697, 0.19716982, 0.21476267, 0.23235553,
        0.24994838]),
 &lt;a list of 10 Patch objects&gt;)</code></pre><p><img src="/2020/01/21/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E5%88%86%E6%9E%90/output_19_1.png" alt="png"></p>
<p>通过画图可以看出,定投具有更小的收益率波动性,因此也具有更小的风险。收益率大致在10%到15%之间,没有负收益率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出定投具有所谓的“削峰填谷”的作用, 可以达到随时买入而年化收益波动不大的效果。而普通投资的收益率不稳定,可能一下子“暴富”也可能“白忙活”,需要投资者掌握投资时机。定投对于想要稳定增值资产的投资者是一个相对比较好的选择。</p>
<p> 最后项目在GitHub上网址:<a href="https://github.com/JasonVictor17/Stock-market-analysis" target="_blank" rel="noopener">https://github.com/JasonVictor17/Stock-market-analysis</a></p>
</font>]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>金融股市</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建设6-主题的配置Next</title>
    <url>/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/</url>
    <content><![CDATA[<font size="3">
个人博客建设第六步:本篇介绍如何配置Next主题,使其更加个性化,其他主题的配置其实也大同小异可以参考,这篇也是本教程的最后一篇,以后可能会更新更多关于博客建设的内容。

<a id="more"></a>
<hr>
<p>首先我们找到主题文件夹Next里的配置文件,对,就是那个和站点配置文件一样名字的_config.yml。 打开会发现里面有几百行。。。不过没关系我会介绍最主要的几个配置。其他就留给大家自行探索了。 </p>
<h3 id="1-菜单栏"><a href="#1-菜单栏" class="headerlink" title="1. 菜单栏"></a>1. 菜单栏</h3><p>看我的博客可以看见有很多标签和分类,但是初始状态是没有的,我们需要配置。<br>首先我们找到menu 栏,把tags(标签),Categories(分类)或者其他需要的标签前的#号删除,表面我们使用这行代码</p>
<p><img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/1.png" alt="peizhi">  </p>
<p>保存后我们在博客主目录下输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>我们就会在source文件夹内发现生成了一个tags的文件夹,打开里面的index.md文件按照如下设置</p>
<p><img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/2.png" alt="peizhi"> </p>
<p> 然后保存就行了,其他的标签也是类似操作就不赘述了。之后我们在写文章时候按照如下格式写开头:</p>
<p> <img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/3.png" alt="peizhi">  </p>
<p>就可以自动生成标签和分类了。每一次有新的标签和分类都会自动在网页生成,方便快捷~(自动保存在public文件夹内)</p>
<h3 id="2-语言"><a href="#2-语言" class="headerlink" title="2.语言"></a>2.语言</h3><p> 在站点配置文件中填写: language: ‘zh-CN’就可以设置中文了,其他语言参考如下:</p>
<p> <img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/4.png" alt="peizhi"></p>
<h3 id="3-添加搜索功能"><a href="#3-添加搜索功能" class="headerlink" title="3. 添加搜索功能"></a>3. 添加搜索功能</h3><p>首先在博客根目录安装插件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件最后加上:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>最后在主题配置文件中:找到 local_search 改为true(在vs code中可以使用搜索找到该参数)<br>这样部署一下博客内搜索功能就上线了。</p>
<h3 id="4-设置作者昵称和站点介绍等"><a href="#4-设置作者昵称和站点介绍等" class="headerlink" title="4.设置作者昵称和站点介绍等"></a>4.设置作者昵称和站点介绍等</h3><p>打开站点配置文件,第一项里进行编辑,title,author和description等</p>
<h3 id="5-修改favicon图标"><a href="#5-修改favicon图标" class="headerlink" title="5. 修改favicon图标"></a>5. 修改favicon图标</h3><p>也就是网页的图标,我的博客是一只手工画的小老鼠。<br>使用工具将需要的图片裁剪成16<em>16和32</em>32大小,然后打开next文件夹下的source文件夹,再打开images文件夹将图片保存其中。<br>打开主题配置文件找到favicon,如下输入自己文件名字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;mouse16.ico</span><br><span class="line">  medium: &#x2F;images&#x2F;mouse32.ico</span><br></pre></td></tr></table></figure>
<p>再部署就可以看见图标已经更改。图片剪裁工具:<a href="http://www.bitbug.net/" target="_blank" rel="noopener">比特虫</a></p>
<h3 id="6-开通评论功能"><a href="#6-开通评论功能" class="headerlink" title="6. 开通评论功能"></a>6. 开通评论功能</h3><p>注册<a href="https://www.livere.com/" target="_blank" rel="noopener">来必力</a>,填写网站后可以得到一串代码,我们只需要其中一部分。<br> <img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/5.jpg" alt="peizhi"><br>复制这一串数字后我们打开主题配置文件,找到LiveRe comments system,去掉#注释,在livere_uid后粘贴上就完成了。</p>
<h3 id="7-赞赏"><a href="#7-赞赏" class="headerlink" title="7.赞赏"></a>7.赞赏</h3><p> 找到主题配置文件下的reward,把自己的微信收款或者支付宝收款二维码放上去就行了。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>到这里一个自己的博客基本上就搭好了,接下来就是自我探索折腾的过程了,网上资源很多可以慢慢折腾自己的博客,我也会不定期的更新我所获得的搭博客小技巧。</p>
<p>在属于自己的一片小天地尽情发挥吧!</p>
<hr>
<p>上一步: <a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE5-Markdown%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">个人博客建设5-Markdown语法</a><br>目录: <a href="https://www.guojingde.cn/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用GitHub搭建个人博客(目录)</a></p>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建设5-Markdown语法</title>
    <url>/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE5-Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<font size="3">
个人博客建设第五步:用基本的Markdown语法来写博客...

<a id="more"></a>
<hr>
<h3 id="为什么markdown"><a href="#为什么markdown" class="headerlink" title="为什么markdown"></a>为什么markdown</h3><p>首先我们写的每一篇博客都是基于md也就是markdown文件的,其次Markdown 是一种轻量级标记语言,它允许人们使用易读易写的纯文本格式编写文档,非常适合写博客。</p>
<h3 id="编辑器的选择"><a href="#编辑器的选择" class="headerlink" title="编辑器的选择"></a>编辑器的选择</h3><p>可以使用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VS code</a>, <a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a>或者<a href="https://sosfos.wordpress.com/" target="_blank" rel="noopener">BookPad</a>(注意这个收费14块)<br>具体的选择结合自身喜好,没有什么大的区别,都具有实时预览功能我觉得就够了。</p>
<h3 id="简单的几个语法"><a href="#简单的几个语法" class="headerlink" title="简单的几个语法"></a>简单的几个语法</h3><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hello</span><br><span class="line">## hello</span><br></pre></td></tr></table></figure>
<p>上面两个分别是主标题和次级标题的区别,井号越多字体就越小,标题也越次级。</p>
<h4 id="2-字体和颜色"><a href="#2-字体和颜色" class="headerlink" title="2. 字体和颜色"></a>2. 字体和颜色</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;</span><br><span class="line">&lt;font color&#x3D;red size&#x3D;4&gt;</span><br><span class="line">&lt;font color&#x3D;red size&#x3D;4 face&#x3D;&quot;黑体&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>使用如上方式在之后加上文字的效果分别如下:<br><font face="黑体" size="4">我是好人<br><font color="red" size="4">我是好人<br><font color="red" size="6" face="黑体">我是好人</font></font></font></p>
<p>:kissing:</p>
<p><font size="3" face="微软雅黑">想要打出如上表情我们只需要输入</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:kissing:</span><br></pre></td></tr></table></figure>
<p>具体可以参考GitHub上: <a href="https://github.com/guodongxiaren/README/blob/master/emoji.md" target="_blank" rel="noopener">https://github.com/guodongxiaren/README/blob/master/emoji.md</a></p>
<h4 id="3-图片的插入"><a href="#3-图片的插入" class="headerlink" title="3. 图片的插入"></a>3. 图片的插入</h4><p>当我们使用Hexo建立博客的时候免不了要插入图片,我们可以在source下创建一个image文件夹然后通过:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](&#x2F;image&#x2F;image.png)</span><br></pre></td></tr></table></figure>
<p>来访问。但是这里我推荐以下一种用法虽然略有点麻烦,但是以后处理图片会很方便。<br>首先在博客的目录blog下用命令行运行如下代码安装一个小插件, 参考:<a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">https://github.com/xcodebuild/hexo-asset-image</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后我们在站点配置文件_congif.yml中设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>之后我们我们只要在撰写博客的目录下,也就是source目录下的_posts文件夹内创建一个和这篇博客名字一样的文件夹,把图片放入其中,就可以按照如下来插入图片了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片命名](logo.jpg)</span><br></pre></td></tr></table></figure>
<p>不需要指定图片的路径,另外如果是在命令行使用 hexo new 命令来创立新的md文件时会自动生成同名文件夹不需要手动另外创建。</p>
<h4 id="4-网站链接"><a href="#4-网站链接" class="headerlink" title="4. 网站链接"></a>4. 网站链接</h4><p>比起直接复制链接更好的方式是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[VS code](https:&#x2F;&#x2F;code.visualstudio.com&#x2F;)</span><br></pre></td></tr></table></figure>
<p>前面写在文章中呈现的名字,后面写链接,这样直接点文字就可以进入链接。</p>
<h4 id="5-强调"><a href="#5-强调" class="headerlink" title="5.强调"></a>5.强调</h4><p>使用如下命令就可以达到对某些文字强调的作用  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line">_single underscores_  </span><br><span class="line">**double asterisks**</span><br><span class="line">__double underscores__</span><br></pre></td></tr></table></figure>
<p><em>single asterisks</em><br><em>single underscores</em><br><strong>double asterisks</strong><br><strong>double underscores</strong> </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学会这几个基本命令就差不多可以开始写博客了,至于其他更多的命令请参考<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown中文版说明</a>。<br>希望大家写博客愉快!</p>
<hr>
<p>上一步: <a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE4-%E9%80%89%E6%8B%A9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">个人博客建设4-选择博客主题</a><br>下一步: <a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/" target="_blank" rel="noopener">个人博客建设6-主题的配置Next</a><br>目录: <a href="https://www.guojingde.cn/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用GitHub搭建个人博客(目录)</a></p>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建设4-选择博客主题</title>
    <url>/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE4-%E9%80%89%E6%8B%A9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<font size="3">
个人博客建设第四步:选择一个自己喜欢的主题模板...

<a id="more"></a>
<hr>
<h3 id="为什么使用模板"><a href="#为什么使用模板" class="headerlink" title="为什么使用模板"></a>为什么使用模板</h3><p>因为简单快速,自己开发的话。。。就要系统学习了。总之关于模板的选择我们可以参考知乎的之一篇回答:<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的 Hexo 主题</a>, 以及官网<a href="https://hexo.io/themes/。" target="_blank" rel="noopener">https://hexo.io/themes/。</a><br>我选用的是我个人觉得还蛮好的Next主题,大致样子可以参照我现在的博客。</p>
<h3 id="部署模板"><a href="#部署模板" class="headerlink" title="部署模板"></a>部署模板</h3><p>找到我们喜欢的模板后,在终端窗口下,定位到 Hexo 站点目录下,也就是blog文件夹内。使用 Git checkout 代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>等待下载完成后我们可以在站点目录下的themes看到多出来一个next文件夹,这就是我们的主题所在位置了。接着我们需要在站点配置文件里修改我们的主题(注意在我们的主题,也就是next文件夹里面也有一个同样名字的配置文件,那是主题配置文件,不要搞错了。)</p>
<p><img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE4-%E9%80%89%E6%8B%A9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/1.png" alt="moban"></p>
<p>把主题如图修改完成后,我们输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>就可以部署我们新的主题上线了,当然也可以使用hexo server在本地查看主题的变化,不推送上线。<br>我们可以下载不止一个模板来查看他们是否适合我们,只需要重复如上步骤下载主题到themes文件夹内,然后修改站点配置文件就行了。<br>希望大家可以找到自己心仪的网站主题!!!</p>
<hr>
<p>上一步: <a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/#more" target="_blank" rel="noopener">个人博客建设3-申请并绑定域名</a><br>下一步: <a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE5-Markdown%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">个人博客建设5-Markdown语法</a><br>目录: <a href="https://www.guojingde.cn/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用GitHub搭建个人博客(目录)</a></p>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建设3-申请并绑定域名</title>
    <url>/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<font size="3">
个人博客建设第三步:申请并绑定域名...

<a id="more"></a>
<hr>
<h3 id="阿里云申请域名"><a href="#阿里云申请域名" class="headerlink" title="阿里云申请域名"></a>阿里云申请域名</h3><p>为什么要申请一个域名?因为酷炫啊!这里可以在任何地方申请域名,现在大多数平台都有云解析服务所以无所谓。这里以<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云</a>举例子。</p>
<p><img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/1.png" alt="github"></p>
<p>输入想要的域名然后搜索,可以选择还未被注册的域名。.com是国际域名.cn是国内域名,二者没有实质区别,当然也有些特别的选项…</p>
<p>买好域名后我们就要进行解析,登录阿里云后我们就可以开始解析了。</p>
<p><img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/3.jpg" alt="github"></p>
<p>点进我们的域名后来到解析设置,添加两条A记录和一条CNAME记录(红圈),A记录的记录值是固定的192.30.252.153和190.30.252.154,为GitHub地址,CNAME记录为: 用户名.github.io 的形式。</p>
<p>这里A记录可实现将域名指向 IP 地址,当需要将域名指向另一个域名,再由另一个域名提供 IP 地址,就需要添加 CNAME 记录。</p>
<p>添加完记录后打开GitHub进入我们之前设置博客的仓库,点击settings(设置),我们拉到页面偏下方。</p>
<p><img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/4.png" alt="github"></p>
<p>输入你申请的域名然后保存。</p>
<p>终于最后一步了,完成这步之后你的博客就可以通过域名访问了。冷静一下,我们打开本地保存博客的文件夹,进入source文件夹创建一个空白记事本在里面输入你申请的域名,然后把它保存为所有文件格式并且命名为CNAME。</p>
<p><img src="/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/5.png" alt="github"></p>
<p>然后常规操作g+d就可以使用自己的域名登录网站啦。</p>
<hr>
<p>上一步: <a href="https://www.guojingde.cn/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE2-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENode.js%E4%BB%A5%E5%8F%8AHexo/" target="_blank" rel="noopener">个人博客建设2-安装并配置Node.js以及Hexo</a><br>下一步: <a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE4-%E9%80%89%E6%8B%A9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">个人博客建设4-选择博客主题</a><br>目录: <a href="https://www.guojingde.cn/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用GitHub搭建个人博客(目录)</a></p>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建设2:安装并配置Node.js以及Hexo</title>
    <url>/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE2-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENode.js%E4%BB%A5%E5%8F%8AHexo/</url>
    <content><![CDATA[<font size="3">
个人博客建设第二步:安装并配置所需框架和环境...

<a id="more"></a>
<hr>
<h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>Node.js允许通过JavaScript和一系列模块来编写服务器端应用和网络相关的r应用。</p>
<p>我们通过官网<a href="https://nodejs.org/en/download/来选择合适的版本进行下载,并且安装。安装完成后再window命令行或者windows自带的powershell输入" target="_blank" rel="noopener">https://nodejs.org/en/download/来选择合适的版本进行下载,并且安装。安装完成后再window命令行或者windows自带的powershell输入</a>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p>出现对应版本号说明安装成功,npm会随着安装包自动安装,输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>同样出现对应版本号说明安装成功。到这里就完成来了环境安装。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Hexo是一个快速、简洁且高效的博客框架。 Hexo使用Markdown解析文章,在几秒内,即可利用靓丽的主题生成静态网页。</p>
<p>第二步就是安装这个博客的框架,同样打开命令行输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>我们就开始安装Hexo了,等待他安装完后我们使用命令行移动到我们希望保存我们博客所有内容的文件夹内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &lt;当前目录下文件夹名字&gt;</span><br></pre></td></tr></table></figure>
<p>使用如上命令就可以移动至我们希望博客项目保存的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>接着使用如上命令就可以初始化我们的博客项目了。至此我们就可以在本地看我们的网站雏形了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new stest_my_site</span><br><span class="line">hexo g </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>按照顺序输入如上命令,就会弹出提示,此时我们在浏览器访问localhost:4000就可以看见我们博客的雏形了。<br>hexo s = hexo server 启动服务预览<br>hexo g = hexo generate 生成<br>其他hexo命令:<br>hexo n “博客名称”  =&gt; hexo new “博客名称”   #这两个都是创建新文章,前者是简写模式<br>hexo clean   #清除缓存,网页正常情况下可以忽略此条命令<br>hexo d  =&gt; hexo deploy  #部署网站上线 (推送到GitHub)</p>
<p><img src="/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE2-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENode.js%E4%BB%A5%E5%8F%8AHexo/1.jpg" alt="github"></p>
<p>这时候我们可以看到blog文件夹内大致是图中的样子,这时候我们打开站点配置文件,可以使用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>来编辑。</p>
<p><img src="/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE2-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENode.js%E4%BB%A5%E5%8F%8AHexo/2.png" alt="github"></p>
<p>我们翻到如图中的部署选项下,把之前在GitHub创建的库完整连接复制粘贴上并在结尾加上.git。(xxx.github.io.git )<br>然后在命令行输入如下命令来安装部署模块,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后常规操作g+s,就可以在浏览器通过访问xxx.github.io来进入个人主页了。<br>但是这个似乎有点傻,这时候我们需要一个帅气的域名!<br>于是下一篇就是:申请并绑定域名</p>
<hr>
<p>上一步: <a href="https://www.guojingde.cn/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/" target="_blank" rel="noopener">个人博客建设1-在GitHub创建一个仓库并配置Git</a></p>
<p>下一步: <a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/#more" target="_blank" rel="noopener">个人博客建设3-申请并绑定域名</a></p>
<p>目录: <a href="https://www.guojingde.cn/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用GitHub搭建个人博客(目录)</a></p>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的几个基本指令</title>
    <url>/2020/01/20/Git%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>Git以及Git的几个最常用的指令,初步了解版本管理。</p>
<a id="more"></a>
<hr>
<h1 id="什么是Git以及为何使用Git"><a href="#什么是Git以及为何使用Git" class="headerlink" title="什么是Git以及为何使用Git?"></a>什么是Git以及为何使用Git?</h1><p>Git 是目前使用人数最多的版本管理工具。为什么会有Git呢?因为要版本控制。 举一个例子,小德要写论文那么他就可能要修改好几次,这时候比起在一个文件里修改小德可能会复制一个新的论文文件在新文件里修改。这时候就可能会有好几个版本的论文。其实平时使用的快捷键ctrl+z的撤回就是最简单的版本管理。</p>
<p>情况再复杂些,小德可能做的是一个小组作业,大家都有各自要做的部分,那么好玩的情况就是大家做完一部分后就要在微信或者邮箱里传来传去,而有了Git 一个团队就可以轻松合作。想要更加深入了解什么是Git 的可以访问 <a href="http://blog.a0z.me/2014/05/21/GitBeginning/" target="_blank" rel="noopener">Ghosty Core 的博客</a>。</p>
<p>Git 官网: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<h1 id="Git-的基本操作"><a href="#Git-的基本操作" class="headerlink" title="Git 的基本操作"></a>Git 的基本操作</h1><h3 id="1-命令行基本操作-和Linux一样"><a href="#1-命令行基本操作-和Linux一样" class="headerlink" title="1. 命令行基本操作(和Linux一样)"></a>1. 命令行基本操作(和Linux一样)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd blog # 切换到当前目录下叫blog的文件夹</span><br><span class="line">cd .. # 退回上一级目录</span><br><span class="line">ls # 查看当前目录下所有文件和文件夹</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd # 返回home目录~</span><br><span class="line">ls -ah # 查看当前目录下所有文件,文件夹以及隐藏文件</span><br><span class="line">pwd # 查看当前路径</span><br><span class="line">touch balabala.py # 在当前目录创建一个名字叫做balabala的python文件</span><br><span class="line">mkdir blog # 在当前目录创建一个叫blog的文件夹</span><br><span class="line">rm balabala.py # 删除该文件</span><br><span class="line">rm -r blog # 删除该文件夹</span><br><span class="line">mv &#123;src&#125; &#123;dest&#125; # 移动文件,如果 dest 是目录,则移动,是文件名则覆盖</span><br></pre></td></tr></table></figure>
<p>要使用git掌握前三个可以把目录移到工作目录init就行了… 下面的作为补充, 万一哪天没有图形化界面只有个命令行呢。</p>
<h3 id="2-创建一个仓库-初始化"><a href="#2-创建一个仓库-初始化" class="headerlink" title="2. 创建一个仓库,初始化"></a>2. 创建一个仓库,初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>在一个工作目录下输入后,就完成了初始化,可以看到隐藏文件有git文件夹。我们就有了一个仓库。</p>
<h3 id="3-查看目前状态"><a href="#3-查看目前状态" class="headerlink" title="3. 查看目前状态"></a>3. 查看目前状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>会提示你当前库的状态,追踪的文件,未追踪的文件,做过修改未commit(注释)的文件。</p>
<h3 id="4-提交修改"><a href="#4-提交修改" class="headerlink" title="4. 提交修改"></a>4. 提交修改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt; # 指定一个文件提交</span><br><span class="line">git add . # 提交所有当前目录下文件</span><br></pre></td></tr></table></figure>
<p>修改文件完首先要把文件推送到staging index,选择要推送的文件或全部</p>
<h3 id="5-commit-注释"><a href="#5-commit-注释" class="headerlink" title="5. commit(注释)"></a>5. commit(注释)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;descriptions&quot; # 直接注释</span><br><span class="line">git commit 打开编辑器进行注释</span><br><span class="line">git commit --amend 对最近一次的提交做内容修改</span><br></pre></td></tr></table></figure>
<p>推送到staging index后需要添加注释,可以直接注释也可以选择自己喜欢的文本编辑器进行注释,Linux下的话可以是vim和nano等,Windows下可以是Notepad++等。注释完后文件就从staging index 推送到 repo仓库了。</p>
<h3 id="6-克隆GitHub远程仓库"><a href="#6-克隆GitHub远程仓库" class="headerlink" title="6. 克隆GitHub远程仓库"></a>6. 克隆GitHub远程仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;remote address&gt;</span><br></pre></td></tr></table></figure>
<p>可以下载远程Github的仓库到本地,例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;JasonVictor17&#x2F;Housing.git</span><br></pre></td></tr></table></figure>
<p>就可以复制我的一个repo到本地了。</p>
<h3 id="7-关联并推送到Github远程仓库"><a href="#7-关联并推送到Github远程仓库" class="headerlink" title="7. 关联并推送到Github远程仓库"></a>7. 关联并推送到Github远程仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;remote address&gt;	在本地工作区目录下按照 GitHub 提示进行关联</span><br><span class="line">git remote rm origin			解除错误关联</span><br><span class="line">git push -u origin master		第一次将本地仓库推送至远程仓库(每次在本地提交后进行操作)</span><br><span class="line">git push origin master			以后每次将本地仓库推送至远程仓库(每次在本地提交后进行操作)</span><br></pre></td></tr></table></figure>

<p>第一步要把本地库关联到一个GitHub库,在GitHub创建新库时会有提示如何操作。第二步就是推送本地库到远程库,第一次操作有所不同以后都一样。</p>
<h3 id="8-流程图"><a href="#8-流程图" class="headerlink" title="8.流程图"></a>8.流程图</h3><p>至此,一个大致的结构就可以形成了。</p>
<p><img src="/2020/01/20/Git%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/1.png" alt="github"></p>
]]></content>
      <categories>
        <category>Git &amp; GitHub</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客建设1:在GitHub创建一个仓库并配置Git</title>
    <url>/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/</url>
    <content><![CDATA[<font size="3">
个人博客建设第一步:配置GitHub,安装Git Bash并配置Git...

<a id="more"></a>
<hr>
<h3 id="首先什么是GitHub-以下是维基百科的定义"><a href="#首先什么是GitHub-以下是维基百科的定义" class="headerlink" title="首先什么是GitHub,以下是维基百科的定义:"></a>首先什么是GitHub,以下是维基百科的定义:</h3><p>GitHub是通过Git进行版本控制的软件源代码托管服务平台。</p>
<h3 id="那什么是Git"><a href="#那什么是Git" class="headerlink" title="那什么是Git?"></a>那什么是Git?</h3><p>Git是一个分布式版本控制软件,最初由林纳斯·托瓦兹创作,于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。</p>
<h3 id="看不懂没关系-只要会使用一样可以搭建个人博客。"><a href="#看不懂没关系-只要会使用一样可以搭建个人博客。" class="headerlink" title="看不懂没关系,只要会使用一样可以搭建个人博客。"></a>看不懂没关系,只要会使用一样可以搭建个人博客。</h3><p>首先我们要创建一个GitHub的账号,网址:<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>创建完后我们就需要创建一个新的库,具体如图:</p>
<p><img src="/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/1.png" alt="github"></p>
<p>点击Repositories 再点击 New,然后进入到下个界面:</p>
<p><img src="/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/2.png" alt="github"></p>
<p>Repositories name 按照固定的格式写 username.github.io<br>这里的username就是你注册时候的用户名,像我就是JasonVictor17</p>
<p>到这里Github就配置好了,我们接着下一个Git Bash到Windows系统以便使用Git,<br>网址:<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a> 会自动下载</p>
<p>安装成功后需要配置Git Bash,打开Git bash我们看到命令行,输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>然后生成一个SSH密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/4.jpg" alt="github"></p>
<p>默认回车,然后系统会自动生成一个文件,然后在C盘user中找到.ssh文件夹(路径如图), 并复制其中id_rsa.pub的内容。然后打开 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">Github上的ssh key设置</a>。</p>
<p><img src="/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/3.png" alt="github"></p>
<p>点击new ssh key后输入名称和复制的内容确认就可以了。</p>
<p>(如果找不到SSH密匙文件有两个办法:1. <a href="https://desktop.github.com/" target="_blank" rel="noopener">下载GitHub桌面版</a>就可以无需密匙   2. 下载一个小程序: <a href="https://www.voidtools.com/zh-cn/" target="_blank" rel="noopener">everything</a> 输入文件名字就可以查找)<br>接着输入如图就成功配置完成了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/5.png" alt="github"></p>
<p>绑定SSH Key的目的是为了之后每次pull和push的时候不需要输入密码和账号,怪麻烦的。同时也避免一些可能产生的错误。</p>
<p>关于Git的基本使用请参考: <a href="https://www.guojingde.cn/2020/01/19/Git%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/#more" target="_blank" rel="noopener">Git的几个基本指令</a></p>
<hr>
<p>下一步: <a href="https://www.guojingde.cn/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE2-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENode.js%E4%BB%A5%E5%8F%8AHexo/" target="_blank" rel="noopener">个人博客建设2-安装并配置Node.js以及Hexo</a><br>目录: <a href="https://www.guojingde.cn/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">用GitHub搭建个人博客(目录)</a></p>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Image Classifier with Deep learning</title>
    <url>/2020/01/19/Image%20Classifier%20with%20Deep%20learning/</url>
    <content><![CDATA[<h1 id="Image-Classifier-with-Deep-learning"><a href="#Image-Classifier-with-Deep-learning" class="headerlink" title="Image Classifier with Deep learning"></a>Image Classifier with Deep learning</h1><p>Going forward, AI algorithms will be incorporated into more and more everyday applications. For example, you might want to include an image classifier in a smart phone app. To do this, you’d use a deep learning model trained on hundreds of thousands of images as part of the overall application architecture. A large part of software development in the future will be using these types of models as common parts of applications. </p>
<a id="more"></a>

<p>In this project, you’ll train an image classifier to recognize different species of flowers. You can imagine using something like this in a phone app that tells you the name of the flower your camera is looking at. In practice you’d train this classifier, then export it for use in your application. We’ll be using <a href="http://www.robots.ox.ac.uk/~vgg/data/flowers/102/index.html" target="_blank" rel="noopener">this dataset</a> of 102 flower categories, you can see a few examples below. </p>
<p><img src="/2020/01/19/Image%20Classifier%20with%20Deep%20learning/Flowers.png" alt="flowers"></p>
<p>The project is broken down into multiple steps:</p>
<ul>
<li>Load and preprocess the image dataset</li>
<li>Train the image classifier on your dataset</li>
<li>Use the trained classifier to predict image content</li>
</ul>
<p>We’ll lead you through each part which you’ll implement in Python.</p>
<p>When you’ve completed this project, you’ll have an application that can be trained on any set of labeled images. Here your network will be learning about flowers and end up as a command line application. But, what you do with your new skills depends on your imagination and effort in building a dataset. For example, imagine an app where you take a picture of a car, it tells you what the make and model is, then looks up information about it. Go build your own dataset and make something new.</p>
<p>First up is importing the packages you’ll need. It’s good practice to keep all the imports at the beginning of your code. As you work through this notebook and find you need to import a package, make sure to add the import up here.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Imports here</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms, models</span><br><span class="line"><span class="keyword">import</span> helper</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure>

<h2 id="Load-the-data"><a href="#Load-the-data" class="headerlink" title="Load the data"></a>Load the data</h2><p>Here you’ll use <code>torchvision</code> to load the data (<a href="http://pytorch.org/docs/0.3.0/torchvision/index.html" target="_blank" rel="noopener">documentation</a>). The data should be included alongside this notebook, otherwise you can <a href="https://s3.amazonaws.com/content.udacity-data.com/nd089/flower_data.tar.gz" target="_blank" rel="noopener">download it here</a>. The dataset is split into three parts, training, validation, and testing. For the training, you’ll want to apply transformations such as random scaling, cropping, and flipping. This will help the network generalize leading to better performance. You’ll also need to make sure the input data is resized to 224x224 pixels as required by the pre-trained networks.</p>
<p>The validation and testing sets are used to measure the model’s performance on data it hasn’t seen yet. For this you don’t want any scaling or rotation transformations, but you’ll need to resize then crop the images to the appropriate size.</p>
<p>The pre-trained networks you’ll use were trained on the ImageNet dataset where each color channel was normalized separately. For all three sets you’ll need to normalize the means and standard deviations of the images to what the network expects. For the means, it’s <code>[0.485, 0.456, 0.406]</code> and for the standard deviations <code>[0.229, 0.224, 0.225]</code>, calculated from the ImageNet images.  These values will shift each color channel to be centered at 0 and range from -1 to 1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_dir = <span class="string">'flowers'</span></span><br><span class="line">train_dir = data_dir + <span class="string">'/train'</span></span><br><span class="line">valid_dir = data_dir + <span class="string">'/valid'</span></span><br><span class="line">test_dir = data_dir + <span class="string">'/test'</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Define your transforms for the training, validation, and testing sets</span></span><br><span class="line">train_transforms = transforms.Compose([transforms.RandomRotation(<span class="number">30</span>),</span><br><span class="line">                                       transforms.RandomResizedCrop(<span class="number">224</span>),</span><br><span class="line">                                       transforms.RandomHorizontalFlip(),</span><br><span class="line">                                       transforms.ToTensor(),</span><br><span class="line">                                       transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], </span><br><span class="line">                                                            [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])]) </span><br><span class="line">valid_transforms = transforms.Compose([transforms.Resize(<span class="number">255</span>),</span><br><span class="line">                                      transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                                      transforms.ToTensor(),</span><br><span class="line">                                      transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], </span><br><span class="line">                                                            [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br><span class="line"></span><br><span class="line">test_transforms = transforms.Compose([transforms.Resize(<span class="number">255</span>),</span><br><span class="line">                                      transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                                      transforms.ToTensor(),</span><br><span class="line">                                      transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], </span><br><span class="line">                                                            [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Load the datasets with ImageFolder</span></span><br><span class="line">train_data = datasets.ImageFolder(train_dir, transform=train_transforms)</span><br><span class="line">valid_data = datasets.ImageFolder(valid_dir, transform=valid_transforms)</span><br><span class="line">test_data = datasets.ImageFolder(test_dir, transform=test_transforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Using the image datasets and the trainforms, define the dataloaders</span></span><br><span class="line">trainloader = torch.utils.data.DataLoader(train_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">validloader = torch.utils.data.DataLoader(valid_data, batch_size=<span class="number">64</span>)</span><br><span class="line">testloader = torch.utils.data.DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">image_datasets = [train_data, valid_data, test_data]</span><br><span class="line">dataloaders = [trainloader, validloader, testloader]</span><br></pre></td></tr></table></figure>

<h3 id="Label-mapping"><a href="#Label-mapping" class="headerlink" title="Label mapping"></a>Label mapping</h3><p>You’ll also need to load in a mapping from category label to category name. You can find this in the file <code>cat_to_name.json</code>. It’s a JSON object which you can read in with the <a href="https://docs.python.org/2/library/json.html" target="_blank" rel="noopener"><code>json</code> module</a>. This will give you a dictionary mapping the integer encoded categories to the actual names of the flowers.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'cat_to_name.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    cat_to_name = json.load(f)</span><br></pre></td></tr></table></figure>

<h1 id="Building-and-training-the-classifier"><a href="#Building-and-training-the-classifier" class="headerlink" title="Building and training the classifier"></a>Building and training the classifier</h1><p>Now that the data is ready, it’s time to build and train the classifier. As usual, you should use one of the pretrained models from <code>torchvision.models</code> to get the image features. Build and train a new feed-forward classifier using those features.</p>
<p>We’re going to leave this part up to you. Refer to <a href="https://review.udacity.com/#!/rubrics/1663/view" target="_blank" rel="noopener">the rubric</a> for guidance on successfully completing this section. Things you’ll need to do:</p>
<ul>
<li>Load a <a href="http://pytorch.org/docs/master/torchvision/models.html" target="_blank" rel="noopener">pre-trained network</a> (If you need a starting point, the VGG networks work great and are straightforward to use)</li>
<li>Define a new, untrained feed-forward network as a classifier, using ReLU activations and dropout</li>
<li>Train the classifier layers using backpropagation using the pre-trained network to get the features</li>
<li>Track the loss and accuracy on the validation set to determine the best hyperparameters</li>
</ul>
<p>We’ve left a cell open for you below, but use as many as you need. Our advice is to break the problem up into smaller parts you can run separately. Check that each part is doing what you expect, then move on to the next. You’ll likely find that as you work through each part, you’ll need to go back and modify your previous code. This is totally normal!</p>
<p>When training make sure you’re updating only the weights of the feed-forward network. You should be able to get the validation accuracy above 70% if you build everything right. Make sure to try different hyperparameters (learning rate, units in the classifier, epochs, etc) to find the best model. Save those hyperparameters to use as default values in the next part of the project.</p>
<p>One last important tip if you’re using the workspace to run your code: To avoid having your workspace disconnect during the long-running tasks in this notebook, please read in the earlier page in this lesson called Intro to<br>GPU Workspaces about Keeping Your Session Active. You’ll want to include code from the workspace_utils.py module.</p>
<p><strong>Note for Workspace users:</strong> If your network is over 1 GB when saved as a checkpoint, there might be issues with saving backups in your workspace. Typically this happens with wide dense layers after the convolutional layers. If your saved checkpoint is larger than 1 GB (you can open a terminal and check with <code>ls -lh</code>), you should reduce the size of your hidden layers and train again.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Build and train your network</span></span><br><span class="line">model = models.vgg19(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Freeze parameters so we don't backprop through them</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">model.classifier = nn.Sequential(nn.Linear(<span class="number">25088</span>, <span class="number">2048</span>),</span><br><span class="line">                                 nn.ReLU(),</span><br><span class="line">                                 nn.Dropout(<span class="number">0.25</span>),</span><br><span class="line">                                 nn.Linear(<span class="number">2048</span>, <span class="number">102</span>),</span><br><span class="line">                                 nn.LogSoftmax(dim=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">criterion = nn.NLLLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Only train the classifier parameters, feature parameters are frozen</span></span><br><span class="line">optimizer = optim.Adam(model.classifier.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">model</span><br></pre></td></tr></table></figure>




<pre><code>VGG(
  (features): Sequential(
    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU(inplace=True)
    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU(inplace=True)
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (6): ReLU(inplace=True)
    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (8): ReLU(inplace=True)
    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (11): ReLU(inplace=True)
    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (13): ReLU(inplace=True)
    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (15): ReLU(inplace=True)
    (16): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (17): ReLU(inplace=True)
    (18): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (19): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (20): ReLU(inplace=True)
    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (22): ReLU(inplace=True)
    (23): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (24): ReLU(inplace=True)
    (25): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (26): ReLU(inplace=True)
    (27): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (29): ReLU(inplace=True)
    (30): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (31): ReLU(inplace=True)
    (32): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (33): ReLU(inplace=True)
    (34): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (35): ReLU(inplace=True)
    (36): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (avgpool): AdaptiveAvgPool2d(output_size=(7, 7))
  (classifier): Sequential(
    (0): Linear(in_features=25088, out_features=2048, bias=True)
    (1): ReLU()
    (2): Dropout(p=0.25, inplace=False)
    (3): Linear(in_features=2048, out_features=102, bias=True)
    (4): LogSoftmax()
  )
)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.to(device)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epochs = <span class="number">8</span></span><br><span class="line">steps = <span class="number">0</span></span><br><span class="line">running_loss = <span class="number">0</span></span><br><span class="line">print_every = <span class="number">50</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> trainloader:</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line">        </span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        </span><br><span class="line">        logps = model.forward(inputs)</span><br><span class="line">        loss = criterion(logps, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> steps % print_every == <span class="number">0</span>:</span><br><span class="line">            test_loss = <span class="number">0</span></span><br><span class="line">            accuracy = <span class="number">0</span></span><br><span class="line">            model.eval()</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> validloader:</span><br><span class="line">                    inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line">                    logps = model.forward(inputs)</span><br><span class="line">                    batch_loss = criterion(logps, labels)</span><br><span class="line">                    </span><br><span class="line">                    test_loss += batch_loss.item()</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Calculate accuracy</span></span><br><span class="line">                    ps = torch.exp(logps)</span><br><span class="line">                    top_p, top_class = ps.topk(<span class="number">1</span>, dim=<span class="number">1</span>)</span><br><span class="line">                    equals = top_class == labels.view(*top_class.shape)</span><br><span class="line">                    accuracy += torch.mean(equals.type(torch.FloatTensor)).item()</span><br><span class="line">                    </span><br><span class="line">            print(<span class="string">"Epoch: &#123;&#125;/&#123;&#125;.. "</span>.format(e+<span class="number">1</span>, epochs),</span><br><span class="line">                  <span class="string">f"Train loss: <span class="subst">&#123;running_loss/print_every:<span class="number">.3</span>f&#125;</span>.. "</span></span><br><span class="line">                  <span class="string">f"Valid loss: <span class="subst">&#123;test_loss/len(validloader):<span class="number">.3</span>f&#125;</span>.. "</span></span><br><span class="line">                  <span class="string">f"Valid accuracy: <span class="subst">&#123;accuracy/len(validloader):<span class="number">.3</span>f&#125;</span>"</span>)</span><br><span class="line">            running_loss = <span class="number">0</span></span><br><span class="line">            model.train()</span><br><span class="line">time_end = time.time() - start</span><br><span class="line">print(<span class="string">"\nTotal time: &#123;:.0f&#125;m &#123;:.0f&#125;s"</span>.format(time_end//<span class="number">60</span>, time_end % <span class="number">60</span>))</span><br></pre></td></tr></table></figure>

<pre><code>Epoch: 1/8..  Train loss: 3.569.. Valid loss: 1.455.. Valid accuracy: 0.612
Epoch: 1/8..  Train loss: 1.689.. Valid loss: 0.859.. Valid accuracy: 0.768
Epoch: 2/8..  Train loss: 1.296.. Valid loss: 0.759.. Valid accuracy: 0.784
Epoch: 2/8..  Train loss: 1.181.. Valid loss: 0.720.. Valid accuracy: 0.800
Epoch: 3/8..  Train loss: 1.054.. Valid loss: 0.655.. Valid accuracy: 0.809
Epoch: 3/8..  Train loss: 1.020.. Valid loss: 0.517.. Valid accuracy: 0.839
Epoch: 4/8..  Train loss: 0.988.. Valid loss: 0.487.. Valid accuracy: 0.850
Epoch: 4/8..  Train loss: 0.932.. Valid loss: 0.596.. Valid accuracy: 0.832
Epoch: 5/8..  Train loss: 0.893.. Valid loss: 0.517.. Valid accuracy: 0.857
Epoch: 5/8..  Train loss: 0.854.. Valid loss: 0.493.. Valid accuracy: 0.870
Epoch: 6/8..  Train loss: 0.790.. Valid loss: 0.508.. Valid accuracy: 0.861
Epoch: 6/8..  Train loss: 0.806.. Valid loss: 0.491.. Valid accuracy: 0.873
Epoch: 7/8..  Train loss: 0.806.. Valid loss: 0.565.. Valid accuracy: 0.861
Epoch: 7/8..  Train loss: 0.825.. Valid loss: 0.449.. Valid accuracy: 0.887
Epoch: 8/8..  Train loss: 0.734.. Valid loss: 0.453.. Valid accuracy: 0.882
Epoch: 8/8..  Train loss: 0.773.. Valid loss: 0.539.. Valid accuracy: 0.860

Total time: 14m 39s</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Testing-your-network"><a href="#Testing-your-network" class="headerlink" title="Testing your network"></a>Testing your network</h2><p>It’s good practice to test your trained network on test data, images the network has never seen either in training or validation. This will give you a good estimate for the model’s performance on completely new images. Run the test images through the network and measure the accuracy, the same way you did validation. You should be able to reach around 70% accuracy on the test set if the model has been trained well.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Do validation on the test set</span></span><br><span class="line">model.eval()</span><br><span class="line">accuracy = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> testloader:</span><br><span class="line">        inputs, labels = inputs.to(device), labels.to(device)</span><br><span class="line">        logps = model.forward(inputs)</span><br><span class="line">        batch_loss = criterion(logps, labels)</span><br><span class="line">                    </span><br><span class="line">        test_loss += batch_loss.item()</span><br><span class="line">                    </span><br><span class="line">        <span class="comment"># Calculate accuracy</span></span><br><span class="line">        ps = torch.exp(logps)</span><br><span class="line">        top_p, top_class = ps.topk(<span class="number">1</span>, dim=<span class="number">1</span>)</span><br><span class="line">        equals = top_class == labels.view(*top_class.shape)</span><br><span class="line">        accuracy += torch.mean(equals.type(torch.FloatTensor)).item()</span><br><span class="line">print(<span class="string">f"Valid accuracy: <span class="subst">&#123;accuracy/len(testloader):<span class="number">.3</span>f&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Valid accuracy: 0.854</code></pre><h2 id="Save-the-checkpoint"><a href="#Save-the-checkpoint" class="headerlink" title="Save the checkpoint"></a>Save the checkpoint</h2><p>Now that your network is trained, save the model so you can load it later for making predictions. You probably want to save other things such as the mapping of classes to indices which you get from one of the image datasets: <code>image_datasets[&#39;train&#39;].class_to_idx</code>. You can attach this to the model as an attribute which makes inference easier later on.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Remember that you&#39;ll want to completely rebuild the model later so you can use it for inference. Make sure to include any information you need in the checkpoint. If you want to load the model and keep training, you&#39;ll want to save the number of epochs as well as the optimizer state, &#96;optimizer.state_dict&#96;. You&#39;ll likely want to use this trained model in the next part of the project, so best to save it now.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># TODO: Save the checkpoint     </span><br><span class="line">classifier &#x3D; nn.Sequential(nn.Linear(25088, 2048),</span><br><span class="line">                           nn.ReLU(),</span><br><span class="line">                           nn.Dropout(0.25),</span><br><span class="line">                           nn.Linear(2048, 102),</span><br><span class="line">                           nn.LogSoftmax(dim&#x3D;1))</span><br><span class="line"></span><br><span class="line">model.class_to_idx &#x3D; image_datasets[0].class_to_idx</span><br><span class="line">checkpoint &#x3D; &#123;&#39;input_size&#39;: 25088,</span><br><span class="line">              &#39;output_size&#39;: 102,</span><br><span class="line">              &#39;classifier&#39; : classifier,</span><br><span class="line">              &#39;arch&#39;: &#39;vgg19&#39;,</span><br><span class="line">              &#39;optimizer&#39;: optimizer.state_dict(),</span><br><span class="line">              &#39;state_dict&#39;: model.state_dict(),</span><br><span class="line">              &#39;class_to_idx&#39;: model.class_to_idx&#125;</span><br><span class="line">torch.save(checkpoint, &#39;checkpoint.pth&#39;)</span><br></pre></td></tr></table></figure>

<h2 id="Loading-the-checkpoint"><a href="#Loading-the-checkpoint" class="headerlink" title="Loading the checkpoint"></a>Loading the checkpoint</h2><p>At this point it’s good to write a function that can load a checkpoint and rebuild the model. That way you can come back to this project and keep working on it without having to retrain the network.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Write a function that loads a checkpoint and rebuilds the model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_checkpoint</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    checkpoints = torch.load(filepath)</span><br><span class="line">    model = models.vgg19(pretrained=<span class="literal">True</span>)</span><br><span class="line">    model.class_to_idx = checkpoints[<span class="string">'class_to_idx'</span>]</span><br><span class="line">    </span><br><span class="line">    model.classifier = checkpoints[<span class="string">'classifier'</span>]</span><br><span class="line">    </span><br><span class="line">    model.load_state_dict(checkpoints[<span class="string">'state_dict'</span>])</span><br><span class="line">    optimizer.load_state_dict(checkpoints[<span class="string">'optimizer'</span>])                       </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = load_checkpoint(<span class="string">'checkpoint.pth'</span>)</span><br><span class="line">print(model)</span><br></pre></td></tr></table></figure>

<pre><code>VGG(
  (features): Sequential(
    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU(inplace=True)
    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU(inplace=True)
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (6): ReLU(inplace=True)
    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (8): ReLU(inplace=True)
    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (11): ReLU(inplace=True)
    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (13): ReLU(inplace=True)
    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (15): ReLU(inplace=True)
    (16): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (17): ReLU(inplace=True)
    (18): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (19): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (20): ReLU(inplace=True)
    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (22): ReLU(inplace=True)
    (23): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (24): ReLU(inplace=True)
    (25): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (26): ReLU(inplace=True)
    (27): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (29): ReLU(inplace=True)
    (30): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (31): ReLU(inplace=True)
    (32): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (33): ReLU(inplace=True)
    (34): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (35): ReLU(inplace=True)
    (36): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (avgpool): AdaptiveAvgPool2d(output_size=(7, 7))
  (classifier): Sequential(
    (0): Linear(in_features=25088, out_features=2048, bias=True)
    (1): ReLU()
    (2): Dropout(p=0.25, inplace=False)
    (3): Linear(in_features=2048, out_features=102, bias=True)
    (4): LogSoftmax()
  )
)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Inference-for-classification"><a href="#Inference-for-classification" class="headerlink" title="Inference for classification"></a>Inference for classification</h1><p>Now you’ll write a function to use a trained network for inference. That is, you’ll pass an image into the network and predict the class of the flower in the image. Write a function called <code>predict</code> that takes an image and a model, then returns the top $K$ most likely classes along with the probabilities. It should look like </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">probs, classes = predict(image_path, model)</span><br><span class="line">print(probs)</span><br><span class="line">print(classes)</span><br><span class="line">&gt; [ <span class="number">0.01558163</span>  <span class="number">0.01541934</span>  <span class="number">0.01452626</span>  <span class="number">0.01443549</span>  <span class="number">0.01407339</span>]</span><br><span class="line">&gt; [<span class="string">'70'</span>, <span class="string">'3'</span>, <span class="string">'45'</span>, <span class="string">'62'</span>, <span class="string">'55'</span>]</span><br></pre></td></tr></table></figure>

<p>First you’ll need to handle processing the input image such that it can be used in your network. </p>
<h2 id="Image-Preprocessing"><a href="#Image-Preprocessing" class="headerlink" title="Image Preprocessing"></a>Image Preprocessing</h2><p>You’ll want to use <code>PIL</code> to load the image (<a href="https://pillow.readthedocs.io/en/latest/reference/Image.html" target="_blank" rel="noopener">documentation</a>). It’s best to write a function that preprocesses the image so it can be used as input for the model. This function should process the images in the same manner used for training. </p>
<p>First, resize the images where the shortest side is 256 pixels, keeping the aspect ratio. This can be done with the <a href="http://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.Image.thumbnail" target="_blank" rel="noopener"><code>thumbnail</code></a> or <a href="http://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.Image.thumbnail" target="_blank" rel="noopener"><code>resize</code></a> methods. Then you’ll need to crop out the center 224x224 portion of the image.</p>
<p>Color channels of images are typically encoded as integers 0-255, but the model expected floats 0-1. You’ll need to convert the values. It’s easiest with a Numpy array, which you can get from a PIL image like so <code>np_image = np.array(pil_image)</code>.</p>
<p>As before, the network expects the images to be normalized in a specific way. For the means, it’s <code>[0.485, 0.456, 0.406]</code> and for the standard deviations <code>[0.229, 0.224, 0.225]</code>. You’ll want to subtract the means from each color channel, then divide by the standard deviation. </p>
<p>And finally, PyTorch expects the color channel to be the first dimension but it’s the third dimension in the PIL image and Numpy array. You can reorder dimensions using <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.transpose.html" target="_blank" rel="noopener"><code>ndarray.transpose</code></a>. The color channel needs to be first and retain the order of the other two dimensions.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Process a PIL image for use in a PyTorch model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_image</span><span class="params">(image)</span>:</span></span><br><span class="line">    <span class="string">''' Scales, crops, and normalizes a PIL image for a PyTorch model,</span></span><br><span class="line"><span class="string">        returns an Numpy array</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    im = Image.open(image)</span><br><span class="line">    im = im.resize((<span class="number">256</span>,<span class="number">256</span>))</span><br><span class="line">    transform = transforms.Compose([transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                                    transforms.ToTensor(),</span><br><span class="line">                                    transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], </span><br><span class="line">                                                         [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])])</span><br><span class="line">    im = transform(im)</span><br><span class="line">    <span class="keyword">return</span> im</span><br></pre></td></tr></table></figure>

<p>To check your work, the function below converts a PyTorch tensor and displays it in the notebook. If your <code>process_image</code> function works, running the output through this function should return the original image (except for the cropped out portions).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span><span class="params">(image, ax=None, title=None)</span>:</span></span><br><span class="line">    <span class="string">"""Imshow for Tensor."""</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        fig, ax = plt.subplots()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># PyTorch tensors assume the color channel is the first dimension</span></span><br><span class="line">    <span class="comment"># but matplotlib assumes is the third dimension</span></span><br><span class="line">    image = image.numpy().transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Undo preprocessing</span></span><br><span class="line">    mean = np.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">    std = np.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    image = std * image + mean</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Image needs to be clipped between 0 and 1 or it looks like noise when displayed</span></span><br><span class="line">    image = np.clip(image, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    ax.imshow(image)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show original pics</span></span><br><span class="line">image_path = test_dir + <span class="string">'/17/image_03911.jpg'</span></span><br><span class="line">pic = Image.open(image_path)</span><br><span class="line">pic</span><br></pre></td></tr></table></figure>




<p><img src="/2020/01/19/Image%20Classifier%20with%20Deep%20learning/output_24_0.png" alt="花"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show processed pics</span></span><br><span class="line">pic_process = process_image(image_path)</span><br><span class="line">imshow(pic_process)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x2ae83fbbf08&gt;</code></pre><p><img src="/2020/01/19/Image%20Classifier%20with%20Deep%20learning/output_25_1.png" alt="花"></p>
<h2 id="Class-Prediction"><a href="#Class-Prediction" class="headerlink" title="Class Prediction"></a>Class Prediction</h2><p>Once you can get images in the correct format, it’s time to write a function for making predictions with your model. A common practice is to predict the top 5 or so (usually called top-$K$) most probable classes. You’ll want to calculate the class probabilities then find the $K$ largest values.</p>
<p>To get the top $K$ largest values in a tensor use <a href="http://pytorch.org/docs/master/torch.html#torch.topk" target="_blank" rel="noopener"><code>x.topk(k)</code></a>. This method returns both the highest <code>k</code> probabilities and the indices of those probabilities corresponding to the classes. You need to convert from these indices to the actual class labels using <code>class_to_idx</code> which hopefully you added to the model or from an <code>ImageFolder</code> you used to load the data (<a href="#Save-the-checkpoint">see here</a>). Make sure to invert the dictionary so you get a mapping from index to class as well.</p>
<p>Again, this method should take a path to an image and a model checkpoint, then return the probabilities and classes.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">probs, classes = predict(image_path, model)</span><br><span class="line">print(probs)</span><br><span class="line">print(classes)</span><br><span class="line">&gt; [ <span class="number">0.01558163</span>  <span class="number">0.01541934</span>  <span class="number">0.01452626</span>  <span class="number">0.01443549</span>  <span class="number">0.01407339</span>]</span><br><span class="line">&gt; [<span class="string">'70'</span>, <span class="string">'3'</span>, <span class="string">'45'</span>, <span class="string">'62'</span>, <span class="string">'55'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(image_path, model, topk=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">''' Predict the class (or classes) of an image using a trained deep learning model.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    processed_image = process_image(image_path)</span><br><span class="line">    processed_image.unsqueeze_(<span class="number">0</span>)</span><br><span class="line">    probs = torch.exp(model.forward(processed_image))</span><br><span class="line">    top_probs, top_index = probs.topk(topk)</span><br><span class="line">    top_index = top_index[<span class="number">0</span>].numpy()</span><br><span class="line">    index = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(model.class_to_idx.items())):</span><br><span class="line">        index.append(list(model.class_to_idx.items())[i][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    label = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        label.append(index[top_index[i]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top_probs, label</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_path = test_dir  + <span class="string">'/17/image_03911.jpg'</span></span><br><span class="line">predict(img_path, model, topk=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(tensor([[9.8274e-01, 1.6505e-02, 3.9908e-04, 1.0707e-04, 9.1983e-05]],
        grad_fn=&lt;TopkBackward&gt;), [&apos;17&apos;, &apos;100&apos;, &apos;18&apos;, &apos;34&apos;, &apos;92&apos;])</code></pre><h2 id="Sanity-Checking"><a href="#Sanity-Checking" class="headerlink" title="Sanity Checking"></a>Sanity Checking</h2><p>Now that you can use a trained model for predictions, check to make sure it makes sense. Even if the testing accuracy is high, it’s always good to check that there aren’t obvious bugs. Use <code>matplotlib</code> to plot the probabilities for the top 5 classes as a bar graph, along with the input image. It should look like this:</p>
<p><img src="/2020/01/19/Image%20Classifier%20with%20Deep%20learning/inference_example.png" alt="flowers"></p>
<p>You can convert from the class integer encoding to actual flower names with the <code>cat_to_name.json</code> file (should have been loaded earlier in the notebook). To show a PyTorch tensor as an image, use the <code>imshow</code> function defined above.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Display an image along with the top 5 classes</span></span><br><span class="line">prob, classes = predict(img_path, model)</span><br><span class="line">prob = prob[<span class="number">0</span>].detach().numpy()</span><br><span class="line">labels = []</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> classes:</span><br><span class="line">    labels.append(cat_to_name[each])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize = (<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax = plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">flower_num = img_path.split(<span class="string">'/'</span>)[<span class="number">2</span>] <span class="comment"># find the index of the flower</span></span><br><span class="line">title= cat_to_name[flower_num] </span><br><span class="line">img = process_image(img_path)</span><br><span class="line">plt.title(title)</span><br><span class="line">imshow(img, ax)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sns.barplot(prob, y=labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/01/19/Image%20Classifier%20with%20Deep%20learning/output_31_0.png" alt="花"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test a flower pic outside the dataset</span></span><br><span class="line">img_path = <span class="string">'C:\\Users\\jasonguo\\Desktop\\flowers_zwy\\11.JPG'</span></span><br><span class="line">prob, classes = predict(img_path, model)</span><br><span class="line">prob = prob[<span class="number">0</span>].detach().numpy()</span><br><span class="line">labels = []</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> classes:</span><br><span class="line">    labels.append(cat_to_name[each])</span><br><span class="line">plt.figure(figsize = (<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax = plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">img = process_image(img_path)</span><br><span class="line">imshow(img, ax)</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sns.barplot(prob, y=labels)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># wihch is exactly true</span></span><br></pre></td></tr></table></figure>


<p><img src="/2020/01/19/Image%20Classifier%20with%20Deep%20learning/output_32_0.png" alt="花"></p>
]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>用GitHub搭建个人博客(目录)</title>
    <url>/2020/01/19/%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<font size="3">
快速上手使用GitHub+Hexo建立博客,适合新手。
系统环境:Windows
本文是目录篇,包含了所有关于使用GitHub+Hexo建立博客的相关教程。会逐渐更新。。。

<a id="more"></a>
<hr>
<h1 id="首先为什么使用GitHub-Hexo建立博客"><a href="#首先为什么使用GitHub-Hexo建立博客" class="headerlink" title="首先为什么使用GitHub+Hexo建立博客"></a>首先为什么使用GitHub+Hexo建立博客</h1><h2 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h2><ol>
<li>不需要服务器省钱省时间呀(主要原因)</li>
<li>适合新手以及对建站不熟悉的小白(本人)</li>
<li>有很多现成精美模板</li>
<li>无流量限制</li>
</ol>
<h2 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h2><ol>
<li><p>个性化空间小</p>
</li>
<li><p>静态页面(虽然博客以及足矣)</p>
</li>
<li><p>没有数据库,不适合大型网站,运行一次就要遍历所有网站内容</p>
<p><font color="red" size="4"> <strong>总之就是非常适合做个人博客就对了。</strong></font></p>
</li>
</ol>
<p>完成这个博客项目你需要: </p>
<ol>
<li>非常基础的Git知识,熟悉命令行(参照文末辅助资料)</li>
<li>喜欢折腾</li>
<li>耐心</li>
</ol>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><a href="https://www.guojingde.cn/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE1-%E5%9C%A8GitHub%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%B9%B6%E9%85%8D%E7%BD%AEGit/" target="_blank" rel="noopener">个人博客建设1-在GitHub创建一个仓库并配置Git</a></li>
<li><a href="https://www.guojingde.cn/2020/01/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE2-%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AENode.js%E4%BB%A5%E5%8F%8AHexo/" target="_blank" rel="noopener">个人博客建设2-安装并配置Node.js以及Hexo</a></li>
<li><a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE3-%E7%94%B3%E8%AF%B7%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/#more" target="_blank" rel="noopener">个人博客建设3-申请并绑定域名</a></li>
<li><a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE4-%E9%80%89%E6%8B%A9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">个人博客建设4-选择博客主题</a></li>
<li><a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE5-Markdown%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">个人博客建设5-Markdown语法</a></li>
<li><a href="https://www.guojingde.cn/2020/01/21/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE6-%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AENext/" target="_blank" rel="noopener">个人博客建设6-主题的配置Next</a></li>
</ol>
<h1 id="其他辅助资料"><a href="#其他辅助资料" class="headerlink" title="其他辅助资料"></a>其他辅助资料</h1><ol>
<li><a href="https://www.guojingde.cn/2020/01/20/Git%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/" target="_blank" rel="noopener">Git的几个基本指令</a></li>
<li><a href="https://www.guojingde.cn/2020/01/25/Hexo%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%8A%A0%E5%85%A5Rmarkdown%E7%94%9F%E6%88%90%E7%9A%84html%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">Hexo 如何优雅的加入Rmarkdown生成的html/pdf文件</a></li>
</ol>
</font>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
